<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>tudurikata - Static Site Generator</title>
        <link>https://tudurikata.com</link>
        <description>personal notes</description>
        <generator>Zola</generator>
        <language>ja</language>
        <atom:link href="https://tudurikata.com/tags/static-site-generator/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Mon, 22 Mar 2021 00:00:00 +0000</lastBuildDate>
        <item>
            <title>バックアップについて考える</title>
            <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
            <link>https://tudurikata.com/post/about-backup/</link>
            <guid>https://tudurikata.com/post/about-backup/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;tudurikata.com&#x2F;post&#x2F;reinstall-arch&#x2F;&quot;&gt;Arch Linuxを再インストールした話&lt;&#x2F;a&gt;に関連して。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dotfilesnoxi-ifang&quot;&gt;dotfilesの扱い方&lt;&#x2F;h3&gt;
&lt;p&gt;今回感じたのは、最低限i3と、ターミナルエミュレーター &#x2F; vifm &#x2F; nvimを入れて、dotfilesをリモートリポジトリから引っ張ってくれば作業環境は整うわけなので、追加のバックアップ作業はもしかしたら要らないのかも、ということ。これまではtimeshiftで定期的にバックアップをとっていたのだが、結局一度も使わないままだったし…。&lt;br &#x2F;&gt;
逆に上記のパッケージのdotfilesがリモートに存在しない場合、動くことは動くが、細かい設定を整えようとするとかなり面倒くさいことになってしまうので、思っていた以上にdotfilesのバックアップは大事だったとも言える（r&#x2F;unixpornに貼りつけるだけのアレじゃなかった）。&lt;&#x2F;p&gt;
&lt;p&gt;シェルスクリプトでdotfilesの設定ファイルのシンボリックリンクを各所に貼るプログラムを書いている人が多いと思うが、同じようなものをNimでさくっと書いてみたので貼っておきます。&lt;&#x2F;p&gt;
&lt;script src=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;kyoheiu&#x2F;9b5c634d38f26d1b67ad1d34bb29ef76.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;p&gt;&lt;code&gt;os&lt;&#x2F;code&gt;ライブラリの&lt;code&gt;createSymlink&lt;&#x2F;code&gt;は同名のファイルが存在した場合failになるので、ファイルを削除してからシンボリックリンクを作成している。利用する場合は自己責任でお願いします。
nvimのcolorsディレクトリを除いているのはこれ以上コードが入れ子になるのが嫌だったから、程度の理由。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shu-kitupanasikodonoxi-ifang&quot;&gt;書きっぱなしコードの扱い方&lt;&#x2F;h3&gt;
&lt;p&gt;これまで練習用に書いてきたHaskellやらRustやらのコードはクリーンインストールによりすべて消えてしまった。まあ見返すことはほとんどなかったし、作り途中のプロジェクトはGitLabのプライベートリポジトリに上げながらやっているから無事だ。それ以外にも、ちょっと面倒な感じの、たとえばHaskellでスクレイピングするプログラムの骨子などはサイトに上げているので、残りのちまちましたやつ（Project Eulerの解答とか）は別にいいかな…と思いつつ、でもやっぱりちょっとさびしい。&lt;br &#x2F;&gt;
こういう断片的なコードをいちいちGitHub GistsやGitLab Snippetsに上げるか、それとも書き捨てのつもりで気にしないかはけっこう微妙な問題だと思う。見返さなかったとはいえ、振り返ると意外と発見があったり、最近書いていない言語を思い出すのに使ったり、ということもあるだろうし、悩ましい。&lt;br &#x2F;&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;note.com&#x2F;konojunya&#x2F;n&#x2F;n461544d2f881&quot;&gt;Gistsに自動アップロードするCLIを書いている&lt;&#x2F;a&gt;方を見つけて、なるほど、と思ったが、書いた端から上げたい感じもある。VS Codeのエクステンションとか、もうありそうだな…と思ったら&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kenhowardpdx&#x2F;vscode-gist&quot;&gt;あった&lt;&#x2F;a&gt;。自分なりに使いそうなフローで何かCLIを作ってみてもいいかもしれない。&lt;br &#x2F;&gt;
GitLabも&lt;a href=&quot;https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;api&#x2F;snippets.html#get-a-single-snippet&quot;&gt;Snippets APIの紹介がとてもよくまとまっている&lt;&#x2F;a&gt;のでけっこう使いやすそう。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jing-de-saitozieneretanoluo-tosixue&quot;&gt;静的サイトジェネレーターの落とし穴(?)&lt;&#x2F;h3&gt;
&lt;p&gt;それと、Hugo &#x2F; Zolaなどの静的サイトジェネレーターを使っている場合は、サイト上にフロントマター付きの.mdファイルが存在するわけではないので、もしデータが消えてしまった場合はサイト上のテキストをコピーしてきて、あらためて.mdとしてタグ付けをしないといけない（もしくはサイトをスクレイピングして.mdファイルを生成するプログラムを書くか。できなくはないが面倒ではある）。&lt;br &#x2F;&gt;
幸い、数か月前までプライベートリポジトリにサイトごと上げていたので、手作業での.md復旧は数記事で済んだのだが、これがまったくバックアップがない状況だったらけっこう辛かったかもしれない。プライベートリポジトリでもいいので更新時にpushしておくのが大事だとしみじみ思った（もちろん、github.ioなどでサイトをホスティングしている場合は当然バックアップがとれているのでこんなことは考えなくていい）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;owarini&quot;&gt;おわりに&lt;&#x2F;h3&gt;
&lt;p&gt;以上に書いたものはすべてgitのリモートリポジトリの存在が前提になっている。ここに何か落とし穴がまだあるかもしれない。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Nimで静的サイトジェネレーターを実装する</title>
            <pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate>
            <link>https://tudurikata.com/post/nim-ssg/</link>
            <guid>https://tudurikata.com/post/nim-ssg/</guid>
            <description>&lt;p&gt;Rust製の静的サイトジェネレーターZolaでスクラッチからテーマを自作したことで、静的サイトジェネレーターそのものに興味が出てきた（以下、「ジェネレーター」と略す箇所が多々あります）。&lt;br &#x2F;&gt;
そこで調べてみて初めて知ったのだが、実は世の中には無数といっていい数の静的サイトジェネレーターがある。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jamstack.org&#x2F;generators&#x2F;&quot;&gt;Static Site Generators - Top Open Source SSGs | Jamstack&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;このページでは、GitHubのスターが多い順に322ものジェネレーターをリストアップしている。Next.js、Hugoに始まり、見たこともないジェネレーターも上のほうにけっこうあったりする。&lt;br &#x2F;&gt;
中には、同じ言語・同じテンプレートエンジンで作られているものもある。たとえば[Pytyon, jinja2]の組み合わせはちょっと数えただけでも10以上ある。それぞれ実装している機能が異なるのだろうし、使い勝手も違うのだろうと思うが、それにしても静的サイトジェネレーターの機能というのはコアの部分はシンプルなはずなので、「ジェネレーターがたくさん作られている」というこの現象は面白い。&lt;br &#x2F;&gt;
なぜなのか、少し考えてみたけれど、まず触っていて気持ちがいいというのは大きいと思う。バッとビルドすれば自分のホームが完成する。こうなるだろうと思ったところから外れることはほとんどない。それでいて、成果物は自分好みのページになっている。これは楽しい。&lt;br &#x2F;&gt;
そして仕組みも、いじっているうちにだんだんわかってくる。テンプレートがあって、マークダウンのファイルがあって、組み合わせて…と、なんだか自分で作れそうな気持ちが湧いてくる。そんな風にして、すでに存在しているジェネレーターと機能は被っている（あるいは場合によっては劣っている）としても、みんなジェネレーターを作ってみたくなるんじゃないだろうか。&lt;&#x2F;p&gt;
&lt;p&gt;僕も実装してみたところ、ざっくりしたプリミティブなジェネレーターが出来たので、紹介してみたい。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;gitlab.com&#x2F;kyoheiu&#x2F;casa&quot;&gt;Kyohei Uto &#x2F; Casa · GitLab&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;今回は、ただジェネレーターを実装するだけでなく、若い言語Nimを触りながら何かを作ってみる、という狙いもあった。&lt;br &#x2F;&gt;
ちなみにNim製の静的サイトジェネレーターはすでに存在しているし、機能も今のところそちらのほうがずっと多い。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nazenimnanoka&quot;&gt;なぜNimなのか&lt;&#x2F;h3&gt;
&lt;p&gt;ジェネレーターを作るとして、言語の縛りはない。というかむしろ、自分の好きな言語／テンプレートエンジンでジェネレーターを実装する、というところが楽しいはずだ。&lt;br &#x2F;&gt;
最初に検討したのはHaskell。Pandocがあるということ、自分がある程度慣れた言語であるということ、Haskell製のジェネレーターHakyllは公式のテーマリストが長らく更新されていないこと、が理由だったのだが、これは厳しかった。最近触る機会がなかったというのもあるけれど、やっぱりHaskellは難しい。Haskellは好きだけど、今回はできればあまり血と涙と時間を費やしたくなかったので、他の言語を検討することに。&lt;&#x2F;p&gt;
&lt;p&gt;一方でなるべく新しい言語に触れたいという気持ちがあって最近ドキュメントを読んでいたのがJuliaとNimだったが、どちらかというとNimのほうが実行まわりで個人的に相性がよさそうだな…というくらいの感じで、Nimでジェネレーターを作ることに決めた。後述するがNimには言語付属のテンプレートエンジンがあり、これが実にサイトジェネレーター向けの仕様だった。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gou-cheng&quot;&gt;構成&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;.
├── casa
├── casa.nim
├── config.json
├── content
│   ├── 1
│   │   ├── 1.json
│   │   └── 1.md
│   ...
├── css
├── public
└── templates
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;全体のフローは非常にシンプルで、contentフォルダに対してforループをまわし、markdownファイルをパースしつつjsonで書いた各記事の設定ファイルを読み込んで、記事ページ、ランディングページおよびタクソノミーのテンプレートに必要な変数を渡す、という流れになる。&lt;&#x2F;p&gt;
&lt;p&gt;テンプレートについては、Nim付属のSource Code Filtersと呼ばれるテンプレートエンジンを使った。たとえば各記事ページのテンプレートを用意したい場合は、こうなる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;#? stdtmpl(subsChar = &amp;#x27;$&amp;#x27;, metaChar = &amp;#x27;#&amp;#x27;)
#proc generatePageHtml(siteTitle, siteUrl, pageContent, pageDate, pageTitle: string, pageCategories, pageTags: seq): string =
#  result = &amp;quot;&amp;quot;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;
      $pageTitle | $siteTitle
    &amp;lt;&amp;#x2F;title&amp;gt;

  &amp;lt;link rel=&amp;quot;shortcut icon&amp;quot; type=&amp;quot;image&amp;#x2F;png&amp;quot; href=&amp;quot;$siteUrl&amp;#x2F;static&amp;#x2F;image&amp;#x2F;icon.png&amp;quot;&amp;gt;
  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt;
  &amp;lt;link id=&amp;quot;style&amp;quot; rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text&amp;#x2F;css&amp;quot; href=&amp;quot;..&amp;#x2F;..&amp;#x2F;main.css&amp;quot;&amp;gt;
&amp;lt;&amp;#x2F;head&amp;gt;

&amp;lt;h2&amp;gt;
  $pageTitle
&amp;lt;&amp;#x2F;h2&amp;gt;

&amp;lt;div class=&amp;quot;date&amp;quot;&amp;gt;
  $pageDate
&amp;lt;&amp;#x2F;div&amp;gt;

#for category in items(pageCategories) :
  &amp;lt;a href=&amp;quot;$siteUrl&amp;#x2F;categories&amp;#x2F;$category&amp;quot;&amp;gt;&amp;#x2F;$category&amp;lt;&amp;#x2F;a&amp;gt;
#end for

#for tag in items(pageTags) :
  &amp;lt;a href=&amp;quot;$siteUrl&amp;#x2F;tags&amp;#x2F;$tag&amp;quot;&amp;gt;#$tag&amp;lt;&amp;#x2F;a&amp;gt;
#end for

&amp;lt;p&amp;gt;
  $pageContent
&amp;lt;&amp;#x2F;p&amp;gt;

&amp;lt;div class=&amp;quot;footer&amp;quot;&amp;gt;
  &amp;lt;a href=&amp;quot;$siteUrl&amp;quot;&amp;gt;$siteTitle&amp;lt;&amp;#x2F;a&amp;gt; | built in Nim
&amp;lt;&amp;#x2F;div&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;SCFのテンプレート内では、#を文頭につければNimのコードを動かせる。このMetaCharは自由に変更可能なので、#をテンプレート内の文頭で使いたいときは、たとえば+なり@なりを設定すればいい。ただし１行目の#?だけは変更不可なので注意して!!&lt;br &#x2F;&gt;
これにpage_base.nimfと名前をつけ（拡張子は自由だがコンベンションとして.nimfが推奨されている）、.nimファイル内でincludeした上で、テンプレート内の関数を呼び出す。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;import markdown, ...

include &amp;quot;templates&amp;#x2F;page_base.nimf&amp;quot;
...

let pageHtml   = generatePageHtml(siteTitle, siteUrl, pageContent,...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これでHTMLファイルとして生成できる。今の設定で生成できるpublicディレクトリの内容は以下の通り。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;.
├── categories # サンプルとして色名をカテゴリに
│   ├── blue
│   ...
│   └── yellow
├── content # 1から100までのサンプル記事
│   ├── 1
│   ...
│   └── 100
├── index.html
├── main.css
└── tags　# サンプルとして色名をタグに
    ├── blue
    ...
    └── yellow
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;ただしjinja2やTera Templateにおけるextendsのような拡張機能はまだ実装されていないので、各テンプレート毎に一から実装する必要がある、というのは難点といえば難点。headerやfooterをいじるとき、ちょっと面倒かも。&lt;br &#x2F;&gt;
また、設定ファイルをいじったとき、ビルドし直さないと反映されない。&lt;br &#x2F;&gt;
さらに、静的サイトジェネレーターというのはしばしば、サイト全体の設定ファイルに自前の変数を追加し、各テンプレートで使用する…ということをやるわけだが、このSCFを使う場合は、そもそもNimのコードから書き直して実装しなければならない。ここまでくると、お世辞にも手軽なテンプレートエンジンとは言えなさそう。その意味でも、HugoやZolaの拡張性の高さ・自由度は本当にすごいと思う。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pahuomansu&quot;&gt;パフォーマンス&lt;&#x2F;h3&gt;
&lt;p&gt;現在自分が使っているRust製ジェネレーターのZola、そして以前使っていたHugoと、自作ジェネレーターCasaのパフォーマンスを比較してみる。サンプルとして作成した100記事からなるサイトを生成するのにかかった時間は以下の通り。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Casa（リリースビルド）&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Casa(通常ビルド)&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Zola&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Hugo&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;0.220s&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;0.600s&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;0.094s&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;0.101s&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;ちなみに、ジェネレーターの草分け的存在・Jekyllは、 &lt;a href=&quot;https:&#x2F;&#x2F;forestry.io&#x2F;blog&#x2F;hugo-vs-jekyll-benchmark&#x2F;&quot;&gt;Hugo vs Jekyll: Benchmarked | Forestry.io&lt;&#x2F;a&gt; こちらの記事によると100記事で3〜4s程度。&lt;&#x2F;p&gt;
&lt;p&gt;ただし、サンプルに用いたファイルはわずかなmarkdownパースしか必要としない。複雑なmarkdownファイルを使うと、Zola&#x2F;Hugoへのビハインドはもっと大きくなる。&lt;&#x2F;p&gt;
&lt;p&gt;ちなみに最初はさらに遅かったので、設定ファイルの形式を変更した。元々はZolaにならってmarkdownのテキストデータと各記事のフロントマター（toml形式）を１つのファイルに同居させ、あとでsplitしてそれぞれを読み込む…ということをしていたのだが、このsplit周りのコードがかなり汚くて微妙だったのと、パフォーマンス的にこの辺で時間を食ってそう、という感じがあったので、割り切って本文のmarkdownファイルとjsonファイルは分けて作る形に切り替えた。これでビルド時間を半減。&lt;&#x2F;p&gt;
&lt;p&gt;markdownパーサはnim-markdownを使用。パフォーマンスのボトルネックがこのパーサなのでどうにかできるといいのだが、現状、Nimのパッケージライブラリにあるmarkdownパーサが実質的にはnim-markdownしかない。とりあえず高速化はここまで。&lt;br &#x2F;&gt;
とはいえ、当然markdownファイルのパース以外にも色々処理をしているわけなので、全体としてNimが確かに速いということは実感できた。正直ここまでとは思っていなかった。まだコードの内容も未熟だから、きっともっと速くできる。&lt;br &#x2F;&gt;
（ついでに言うと、やっぱりZolaはHugoよりもちょっとだけ速そうな気配）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nimza-gan&quot;&gt;Nim雑感&lt;&#x2F;h3&gt;
&lt;p&gt;以前小さなスクリプトを書いたときに「素直な言語」という手応えを得たが、今回ジェネレーターを実装したことで、ただ単に素直なだけではない、「実直でパワフルな言語」という認識に変わった。コードの書き心地がとてもシンプルで、書いたことがそのまま反映されるし、しかも速い。forループをぶん回しても涼しい顔をしている。ライブラリのさらなる充実に期待（どこかでmarkdownパーサを書いてみたい…）。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>静的サイトジェネレーターZolaへ移行する</title>
            <pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate>
            <link>https://tudurikata.com/post/zola-ssg/</link>
            <guid>https://tudurikata.com/post/zola-ssg/</guid>
            <description>&lt;h3 id=&quot;gai-yao&quot;&gt;概要&lt;&#x2F;h3&gt;
&lt;p&gt;以前はGo製のSSG(Static Site Generator)Hugoを使っていたのだけれど、色々考えた結果、Rust製SSGのZolaに乗り換えることに。そしていじっているうちに自分で納得いくまでやりたくなってしまい、テーマも作成してみました、という話です。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yi-xing-li-you&quot;&gt;移行理由&lt;&#x2F;h3&gt;
&lt;p&gt;HugoではAcademicという（おそらく）メジャーなthemeを使っていて、特に支障があったわけでもなかったのだけれど、気になるといえば気になっていたのが、「細かいところが気になったとき、すらすらと自分で書き直せるほどの理解を得ないまま使っている感じ」。ただしこれについては、デザインを自分で本格的にいじっていないために手になじんでいないだけかもしれない。&lt;&#x2F;p&gt;
&lt;p&gt;直接的な動機になったのは、各記事のカテゴリやタグを記事一覧でちゃんと表示してくれる、かつデザイン的に好みのthemeが見つからなかったことだったが、結果的には、Zolaに移行してテーマも自作したことで、とてもスッキリした。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zolanituitenoge-ren-de-pros-cons&quot;&gt;Zolaについての個人的pros&#x2F;cons&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;pros&quot;&gt;pros&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;zola buildが通ればだいたい大丈夫という安心感&lt;&#x2F;li&gt;
&lt;li&gt;しかも早い。Hugoよりも体感的にはちょっとだけ早い気がする。&lt;&#x2F;li&gt;
&lt;li&gt;buildエラー時のメッセージが丁寧かつ有用
&lt;ul&gt;
&lt;li&gt;Hugoでは何も考えずthemeを使っていたのでそもそもあまりエラーが出なかった印象だが、一から独自変数ありの.htmlを組んでいく中でこれはとても有難かった。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;zola checkがけっこう使える
&lt;ul&gt;
&lt;li&gt;内部及び外部リンクをチェックしてくれるコマンドで、リンクミス・リンク切れを教えてくれる。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;cons&quot;&gt;cons&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;手間がかかる
&lt;ul&gt;
&lt;li&gt;zola init時に勝手に各ページのサンプルを生成してくれればいいのにな…と、自作themeを作りながら何回か感じた。git cloneでthemeを入れた後、全体の構造を理解した上で.htmlをいじらないといけない局面があり、SSGに詳しくない人がいきなり手を出すのはややつらい気がする。最初のSSGとしてはHugoのほうがよさそう。&lt;&#x2F;li&gt;
&lt;li&gt;そして.htmlやconfig.tomlをいじっていく際、Tera Templateという独特のテンプレートエンジンを使う必要があり、学習コストが高いとまでは言わないけれど、お目当ての機能にたどり着くのにけっこう時間はかかるというのが実感。&lt;&#x2F;li&gt;
&lt;li&gt;慣れるとそこそこ扱いやすいこのTera Template、Rust用のエンジンということなので、Rustを普段書いている人にとっては学習しておくと一石二鳥…かどうかはよくわかりません。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;themeがまだまだ少なそう
&lt;ul&gt;
&lt;li&gt;公式で紹介されているのは2021年初頭時点で29。一方さすがのHugoは公式に載っているものだけでも300近くあるようなので、ここの差は人によっては大きいと思う。ただし、結局自分好みのサイトにしようとするなら、自分でいじらないといけない（いじることのできる）範囲が広いので、自力で全部書くのであれば関係ない。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;公式ドキュメントが若干わかりにくい
&lt;ul&gt;
&lt;li&gt;トータルで見ると必要なことは全部書いてあるのだが、知りたいことがどこに書いてあるのか直感的に掴みづらい。たとえば、使用できるシンタックスハイライトのテーマ一覧がSyntax HighlightingというページではなくConfigurationにある、など。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;hugo new post&#x2F;new.mdのような記事作成コマンドがない
&lt;ul&gt;
&lt;li&gt;人によっては若干不親切と感じられるかもしれない。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;総合して考えると個人的にはZolaのほうが馬が合う感じで好み。いちから自分の手でちまちま構築する（必要がある）雰囲気がArchと似ていて、「これについては自分が一番よく知っているし、何かあったら自分でなんとかできるはず」という感覚を得られる。これが個人的にはけっこう大事なポイントなので。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;getting-started&quot;&gt;Getting Started&lt;&#x2F;h3&gt;
&lt;p&gt;以下は、themeを使用しない場合の導入方法です。&lt;&#x2F;p&gt;
&lt;p&gt;基本的な仕組みは、公式のドキュメントのGetting Startedに。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;$ tree
.
├── config.toml
├── content
├── sass
├── static
├── templates
└── themes
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;さらにtemplatesの中身は以下。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[templates]$ tree
.
├── base.html
├── categories
│   ├── list.html
│   └── single.html
├── index.html
├── post.html
├── post-page.html
└── tags
    ├── list.html
    └── single.html
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;templatesに入っているこれらすべてのファイルと、親ディレクトリのconfig.tomlが必須要素。（タグ等の分類を使わなければtags及びcategoriesディレクトリは不要）。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;quan-ti-gou-zao&quot;&gt;全体構造&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;base.html すべてのページのテンプレート。head、header、footerなどはここに書く。&lt;&#x2F;li&gt;
&lt;li&gt;index.html いわゆるトップページの内容。&lt;&#x2F;li&gt;
&lt;li&gt;post.html, post-page.html それぞれ、記事一覧と各記事ページのテンプレートになる。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre&gt;&lt;code&gt;( base.html &amp;gt; index.html     ) + main.scss = example.com&amp;#x2F;index.html
( base.html &amp;gt; post.html      ) + main.scss = example.com&amp;#x2F;post
( base.html &amp;gt; post-page.html ) + main.scss + content&amp;#x2F;post&amp;#x2F;hoge.md   = example.com&amp;#x2F;post&amp;#x2F;hoge
( base.html &amp;gt; post-page.html ) + main.scss + content&amp;#x2F;hoge&amp;#x2F;index.md  = example.com&amp;#x2F;hoge
content&amp;#x2F;post&amp;#x2F;_index.md = content&amp;#x2F;post以下の記事群についてのメタデータ
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;このように、雛形の.htmlをベースにして（記事の場合は.mdファイルの各変数が代入され）そこに.scssから生成されるCSSファイルが適応されて最終的なhtmlが出力される、という流れになっている。この流れを可能にしているのがTera Template流の変数の仕組み。&lt;&#x2F;p&gt;
&lt;p&gt;content&#x2F;hoge&#x2F;index.mdとcontent&#x2F;hoge&#x2F;_index.mdの違いは、前者はexample.com&#x2F;hogeへアクセスしたときに表示されるページとしてレンダリングされるが、後者はcontent&#x2F;hoge以下の記事群についてのメタデータを記したファイルであるということ。&lt;&#x2F;p&gt;
&lt;p&gt;たとえばexample.com&#x2F;aboutに直接aboutページを載せたいときは、content&#x2F;about&#x2F;index.mdにその内容を書く。逆に、記事一覧など、content&#x2F;hoge以下の記事群に対応する変数はcontent&#x2F;hoge&#x2F;_index.mdに記載しておく。（この説明はちょっと怪しいけど…）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tips&quot;&gt;tips&lt;&#x2F;h3&gt;
&lt;p&gt;以上が分かればあとは自分好みに仕上げていくだけだが、個人的に詰まったところ・記録しておきたいところを書いておく。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hugo-academic-karanoyi-xing&quot;&gt;Hugo(Academic)からの移行&lt;&#x2F;h4&gt;
&lt;p&gt;Academicの.mdテンプレートはフロントマター（タイトルや投稿日などの記事のメタデータ）の区切りが+++でなく---になっているので、逐一変換する必要がある。記事数が多い場合は何らかのスクリプトを組まないと厳しい。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;sintatukusuhairaito&quot;&gt;シンタックスハイライト&lt;&#x2F;h4&gt;
&lt;p&gt;config.tomlに好みのテーマを書き、各.mdのコードブロック先頭に言語を明示することで適用される。対応しているテーマがまだ少ないので、こだわりのある人は先に公式をチェックしておきましょう。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;nei-bu-rinku&quot;&gt;内部リンク&lt;&#x2F;h4&gt;
&lt;p&gt;独特の内部リンク文法を使用しており、たとえば記事内で&#x2F;post&#x2F;hoge.mdにリンクを貼りたいときは@&#x2F;post&#x2F;hoge.mdとなる。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;taxonomies&quot;&gt;taxonomies&lt;&#x2F;h4&gt;
&lt;p&gt;Zolaにおけるタグやカテゴリなどのtaxonomiesは各記事のフロントマターに明示するだけではダメで、templatesにTAXONOMIES&#x2F;list.html, TAXONOMIES&#x2F;single.htmlという２種類のテンプレートを作る必要がある。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;scss&quot;&gt;scss&lt;&#x2F;h4&gt;
&lt;p&gt;cssのメタ言語だが、学習コストはかなり低いので触っておいて損はないと思う。といっても自分はscss独自の機能はほぼ使用していないけれど…。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;index-htmlnizhi-jie-ji-shi-yi-lan-wobiao-shi-suru&quot;&gt;index.htmlに直接記事一覧を表示する&lt;&#x2F;h4&gt;
&lt;p&gt;set_section関数を使用してpage.htmlを拾った上で、for構文を用いて表示する。&lt;&#x2F;p&gt;
&lt;p&gt;全記事でなく一部のみを表示したい場合はループカウントすることになるが、Tera Templateはloop.indexという特殊変数を用いてカウントするので注意。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;config-extra-variable&quot;&gt;config.extra.variable&lt;&#x2F;h4&gt;
&lt;p&gt;config.tomlの[extra]（自作の設定）でなるべく変数定義することでコードがクリーンになる気がする。ただし、.scss内で自作変数を使うことはできないっぽい。.scssでなく直接.cssを書いて置いておくのであれば使えそう。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;shu-shi&quot;&gt;数式&lt;&#x2F;h4&gt;
&lt;p&gt;数式の表示はMathJaxを使用した。関連する部分のコードを貼っておくので参考までに。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;html&quot; class=&quot;language-html &quot;&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;  {% if page.extra.math %}
  &amp;lt;script&amp;gt;
    MathJax = {
      tex: {
        inlineMath: [[&amp;#x27;$&amp;#x27;, &amp;#x27;$&amp;#x27;], [&amp;#x27;\\(&amp;#x27;, &amp;#x27;\\)&amp;#x27;]]
      }
    };
  &amp;lt;&amp;#x2F;script&amp;gt;
  &amp;lt;script type=&amp;quot;text&amp;#x2F;javascript&amp;quot; id=&amp;quot;MathJax-script&amp;quot; async
    src=&amp;quot;https:&amp;#x2F;&amp;#x2F;cdn.jsdelivr.net&amp;#x2F;npm&amp;#x2F;mathjax@3&amp;#x2F;es5&amp;#x2F;tex-chtml.js&amp;quot;&amp;gt;
  &amp;lt;&amp;#x2F;script&amp;gt;
  {% endif %}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;matomeruto&quot;&gt;まとめると&lt;&#x2F;h3&gt;
&lt;p&gt;わかってくると楽しい、そういうジェネレーターです。興味がある方はぜひ。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;theme&quot;&gt;theme&lt;&#x2F;h3&gt;
&lt;p&gt;自分で構築さえできれば、それそのものをテーマとして配布することができる。手順も簡単で、通常のサイトディレクトリにtheme.tomlを追加するだけ。&lt;&#x2F;p&gt;
&lt;p&gt;自分のサイトをテーマ化して独立させたものをGitLabに載せています。&lt;br &#x2F;&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;gitlab.com&#x2F;kyoheiu&#x2F;emily_zola_theme&quot;&gt;Kyohei Uto &#x2F; emily_zola_theme · GitLab&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
    </channel>
</rss>
