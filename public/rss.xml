<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>kyoheiu.gitlab.io</title>
        <link>https://kyoheiu.gitlab.io</link>
        <description>personal notes</description>
        <generator>Zola</generator>
        <language>ja</language>
        <atom:link href="https://kyoheiu.gitlab.io/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Wed, 09 Mar 2022 00:00:00 +0000</lastBuildDate>
        <item>
            <title>JavaScriptをdenoでシンプルに書く</title>
            <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/just-js-deno/</link>
            <guid>https://kyoheiu.gitlab.io/post/just-js-deno/</guid>
            <description>&lt;p&gt;ちょっとしたタスクでTwitter APIを叩かないといけなくなり、前は叩くところからデータフォーマットまで全部Rustのファイル１枚で書いたので、今度は別の言語にするかな～と、軽い気持ちでGoで書いてみたらなぜかうまくいかなかった。&lt;&#x2F;p&gt;
&lt;p&gt;json.Unmarshalがよしなに動いてくれなかったのがうまくいかなかった理由（多分）。jsonの処理はあまりにも普遍的なのでどの言語でも一緒だろ～～とか思ってたら意外とそんなことはなかった…。Unmarshalが動かなかったときのデバッグってどうすればいいんだろう。&lt;&#x2F;p&gt;
&lt;p&gt;Goに慣れていないので、全部をGoのStandard Libraryのせいにする気はないけれど、たとえばRustのserdeと比べてみると、Goのほうが一段高いレベルでざっくり抽象化されているような気がしていて、その分デバッグも微妙にやりにくいように思う。&lt;&#x2F;p&gt;
&lt;p&gt;（最近ずっとRustを書いているという理由で別言語を選んだわけなので、そもそもGoを選んだのはちょっと違ったかな…とは思っている）&lt;&#x2F;p&gt;
&lt;p&gt;ん～どうするかな…と３秒くらい考えて、どうせレスポンスのjsonをあれこれするならもうJs&#x2F;Tsでいいのでは？となり、Jsを50行くらい書いて&lt;code&gt;deno run&lt;&#x2F;code&gt;したら一瞬でタスクが終わったので、denoいいね…となった。HTTPリクエスト送る系のタスクはこれでいいのかもしれない。データ量が膨大だったり後処理が複雑だと話は変わってくるのだろうけど。シェルスクリプトの代替としてのJs&#x2F;Tsというのも案外ありなのかな、とも思った。zxというのもあるけど、別に文法を変えなくても生Jsで良くないかな？&lt;&#x2F;p&gt;
&lt;p&gt;あと、この程度の規模だと型なくても全然いいね…というのも実感としてあった。Haskellから入ったくらいなので、型がないともうどうしていいか分からないくらいuntyped langへの苦手意識があったのだが、アロー記法とか高階関数のおかげでかなり息がしやすくなっていて良かった。denoのエラーメッセージもけっこう親切で、シンプルにJsそのものに向き合える感じがあるというか。&lt;&#x2F;p&gt;
&lt;p&gt;denoはTs、というイメージが強いように思うが、Jsも普通に書けるので、ちょっとしたタスクにJsを使ってみようかなという向きには非常におすすめの組み合わせです。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>fcitxが壊れたので設定を見直す</title>
            <pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/fcitx-does-not-work/</link>
            <guid>https://kyoheiu.gitlab.io/post/fcitx-does-not-work/</guid>
            <description>&lt;h3 id=&quot;huai-retayuan-yin&quot;&gt;壊れた原因&lt;&#x2F;h3&gt;
&lt;p&gt;普段はMac bookでzoomを使っていたのだけれど、ちょっとした用事でメインのデスクトップにもzoomを入れることになり、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;yay -S zoom
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;でインストール（officialじゃなくてaurだよ）。&lt;&#x2F;p&gt;
&lt;p&gt;しかしこのzoom、理由は不明だが依存パッケージにibusがあり、おそらくこいつが原因でfcitxが正常に動かなくなってしまった。多分何かしらのコンフリクトが発生している。状態としては、起動するけれど変換してくれない、というもの。&lt;&#x2F;p&gt;
&lt;p&gt;明らかにzoomインストール後の不具合だったので、何とか依存パッケージごと削除してもとに戻そうとするも、どこかのファイルに変更が加えられてしまったのか、うまくいかない。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;koremade&quot;&gt;これまで&lt;&#x2F;h3&gt;
&lt;p&gt;fcitxの起動はこれまで、&lt;code&gt;.xinitrc&lt;&#x2F;code&gt;に&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS=@im=fcitx
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;と記述した上で、i3のスタート時起動 &lt;code&gt;exec --no-startup-id fcitx&lt;&#x2F;code&gt; を行っていた。&lt;br &#x2F;&gt;
のだが、どうやら一連のexportは通常&lt;code&gt;.xprofile&lt;&#x2F;code&gt;に記述するほうが正しいみたい。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;.xprofile&lt;&#x2F;code&gt;への記述で、fcitx自体は無事動くようになった（なぜかは不明）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhui-jia-nowen-ti&quot;&gt;追加の問題&lt;&#x2F;h3&gt;
&lt;p&gt;ただ、こうすると、fcitxが起動している状態でターミナルを立ち上げたとき、日本語のインプットが必ず先に入ってしまう（これまではなぜかターミナルではデフォルト英数だった）。自作ランチャーにも日本語が入るようになり、すごくわずらわしい。いちいち切り替えて入力するのも嫌だし…。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dui-ce&quot;&gt;対策&lt;&#x2F;h3&gt;
&lt;p&gt;exportの記述をすべて&lt;code&gt;.xprofile&lt;&#x2F;code&gt;に移した上で、思いきってスタート時のfcitx起動を削除した。
代わりに、i3の設定で&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;#IME
bindsym $mod+i exec fcitx
bindsym $mod+k exec &amp;quot;killall fcitx&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;として、ショートカットでfcitxの起動／停止を行うようにした。IME自体をデフォルトで無効にして、どうしても必要なときに日本語入力を立ち上げる。こうなると「日本語入力ができる」ほうがむしろ特殊な状態になるので、「今日本語入力だっけ…？」的なわずらわしさがちょっと減り、わりと頭の中はスッキリする。&lt;br &#x2F;&gt;
だいたい起動時に問答無用でfcitxを起動している人が多い印象ですが、むしろ使わないときはkillallしてしまったほうが快適ですね。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zui-hou-ni&quot;&gt;最後に&lt;&#x2F;h3&gt;
&lt;p&gt;zoom(ibus)許すまじ。&lt;&#x2F;p&gt;
&lt;p&gt;(本当は、日本語入力するデバイスと英語／コードを書くデバイスを思いきって分けてしまったほうが楽かもしれない)&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>RustプロジェクトのビルドテストをGithub Actionsで行う（Arch Linuxのタグに要注意）</title>
            <pubDate>Thu, 25 Nov 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/arch-docker-gcc/</link>
            <guid>https://kyoheiu.gitlab.io/post/arch-docker-gcc/</guid>
            <description>&lt;p&gt;タイトルの通りなのだが、若干ハマったので記録しておきます。&lt;&#x2F;p&gt;
&lt;p&gt;Rustのプロジェクトにおいて、自分のローカル環境以外でもうまくインストールできるかのテストを行うためにGitHub Actionsを使っている。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# .github&amp;#x2F;workflows&amp;#x2F;install_test.yml

name: &amp;#x27;install test&amp;#x27;

on:
  push:
    branches-ignore: &amp;#x27;main&amp;#x27;
    paths-ignore:
      - &amp;#x27;*.md&amp;#x27;

env:
  CARGO_TERM_COLOR: always

jobs:
  ubuntu-install:
    runs-on: ubuntu-latest
    steps:
    - uses: actions&amp;#x2F;checkout@v2
    - name: Install
      run: |
        cargo install --path .
  macos-install:
    runs-on: macos-latest
    steps:
    - uses: actions&amp;#x2F;checkout@v2
    - name: Install
      run: |
        cargo install --path .
  archlinux-install:
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
    steps:
    - uses: actions&amp;#x2F;checkout@v2
    - name: Install
      run: |
        pacman -Syu --noconfirm
        pacman -S gcc --noconfirm
        pacman -S rustup --noconfirm
        rustup install stable
        rustup default stable
        cargo install --path .
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;jobsは３つ。Ubuntu上・macOS上・Arch Linux上それぞれでのインストールをテストしている。（&lt;code&gt;cargo install --path .&lt;&#x2F;code&gt;が通ればcrates.ioからのインストールも問題ないという認識）&lt;&#x2F;p&gt;
&lt;p&gt;ご覧の通り、UbuntuとmacOSでは特に追加でライブラリをインストールする必要なくパスしているが、archlinux:latestを使った最後のテストでは、&lt;code&gt;gcc&lt;&#x2F;code&gt;と&lt;code&gt;rustup&lt;&#x2F;code&gt;を先にインストールしている。
&lt;code&gt;rustup&lt;&#x2F;code&gt;がarchlinux:latestに含まれていないのは当たり前のことなのでこれは良い。問題なのは&lt;code&gt;gcc&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;gcc&lt;&#x2F;code&gt;を事前インストールしない場合、テスト中に&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;error: linker `cc` not found
  |
  = note: No such file or directory (os error 2)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;とビルドエラーが出てしまう。 &lt;&#x2F;p&gt;
&lt;p&gt;そもそものarchlinux:latestイメージの中に入ってみると、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# docker run -it archlinux:latest
[root@0fd34e31306a &amp;#x2F;]# pacman -Qi gcc
warning: database file for &amp;#x27;core&amp;#x27; does not exist (use &amp;#x27;-Sy&amp;#x27; to download)
warning: database file for &amp;#x27;extra&amp;#x27; does not exist (use &amp;#x27;-Sy&amp;#x27; to download)
warning: database file for &amp;#x27;community&amp;#x27; does not exist (use &amp;#x27;-Sy&amp;#x27; to download)
error: package &amp;#x27;gcc&amp;#x27; was not found
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;うーん、やっぱり入ってない。&lt;code&gt;gcc&lt;&#x2F;code&gt;が含まれてないなんて、そんなことある？　と思いながら、テストはパスするのでそのままにしていた。&lt;&#x2F;p&gt;
&lt;p&gt;でもやっぱり引っかかる。そこで、よく&lt;a href=&quot;https:&#x2F;&#x2F;hub.docker.com&#x2F;_&#x2F;archlinux&quot;&gt;公式の説明&lt;&#x2F;a&gt;を読んで見ると…&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Besides &lt;code&gt;base&lt;&#x2F;code&gt; we also provide images for the &lt;code&gt;base-devel&lt;&#x2F;code&gt; package group. &lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;tagにちゃんと&lt;code&gt;base-devel&lt;&#x2F;code&gt;がある…！　そして&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;latest&lt;&#x2F;code&gt; tag will always match the latest &lt;code&gt;base&lt;&#x2F;code&gt; tag.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;はい、ありがちな&lt;code&gt;base-devel&lt;&#x2F;code&gt;抜け。&lt;br &#x2F;&gt;
何も考えずlatestを使ってはいけないという教訓を得ました。&lt;&#x2F;p&gt;
&lt;p&gt;というわけで冒頭のymlを次のように変更。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;  archlinux-install:
    runs-on: ubuntu-latest
    container:
      image: archlinux:base-devel
    steps:
    - uses: actions&amp;#x2F;checkout@v2
    - name: Install
      run: |
        pacman -Syu --noconfirm
        pacman -S rustup --noconfirm
        rustup install stable
        rustup default stable
        cargo install --path .
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;データベースの更新はいずれにせよ必要として、&lt;code&gt;gcc&lt;&#x2F;code&gt;の明示的インストールを削除。テストももちろんパス。あースッキリした。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>felix - a tui file manager written in Rust</title>
            <pubDate>Thu, 25 Nov 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/felix-file-manager/</link>
            <guid>https://kyoheiu.gitlab.io/post/felix-file-manager/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;felix&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;img.shields.io&#x2F;crates&#x2F;v&#x2F;felix&quot; alt=&quot;crates.io&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;A tui file manager with vim-like key mapping, written in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;sample.gif&quot; alt=&quot;sample gif&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;While heavliy inspired by the great &lt;code&gt;vifm&lt;&#x2F;code&gt; and trying to implement its pleasant experience in Rust, at the same time this project focuses on the following points:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;simple and fast&lt;&#x2F;li&gt;
&lt;li&gt;easy to configure how to open files&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;status&quot;&gt;Status&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Linux : works well&lt;&#x2F;li&gt;
&lt;li&gt;MacOS : &lt;em&gt;should&lt;&#x2F;em&gt; work, though some unusual errors may occur&lt;&#x2F;li&gt;
&lt;li&gt;Windows: almost unavailable due to file-name encoding error&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;&#x2F;h2&gt;
&lt;p&gt;Before you do the following, make sure &lt;code&gt;gcc&lt;&#x2F;code&gt; is installed.&lt;&#x2F;p&gt;
&lt;p&gt;from crates.io:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;cargo install felix
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;or from GitHub repository:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;kyoheiu&amp;#x2F;felix.git
cd felix
cargo install --path .
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;command&lt;&#x2F;th&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;fx&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Show items in the current directory.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;fx &amp;lt;directory path&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Show items in the path. Both relative and absolute available.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;key-manual&quot;&gt;Key manual&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Key&lt;&#x2F;th&gt;&lt;th&gt;Explanation&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;j &#x2F; Key Up&lt;&#x2F;td&gt;&lt;td&gt;Go up. If the list exceeds max-row, list &amp;quot;scrolls&amp;quot; before the top of the list.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;k &#x2F; Key Down&lt;&#x2F;td&gt;&lt;td&gt;Go down. If the list exceeds max-row, list &amp;quot;scrolls&amp;quot; before the bottom of the list.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;h &#x2F; Key Left&lt;&#x2F;td&gt;&lt;td&gt;Go to parent directory if exists.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;l &#x2F; Key Right &#x2F; Enter&lt;&#x2F;td&gt;&lt;td&gt;Open file or change directory. Commands for execution can be managed in config file.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;gg&lt;&#x2F;td&gt;&lt;td&gt;Go to the top.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;G&lt;&#x2F;td&gt;&lt;td&gt;Go to the bottom.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;dd&lt;&#x2F;td&gt;&lt;td&gt;Delete and yank item (item will go to the trash directory).&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;yy&lt;&#x2F;td&gt;&lt;td&gt;Yank item. If you yanked other item before, its information is replaced by this one.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;p&lt;&#x2F;td&gt;&lt;td&gt;Put yanked item(s) in the current directory. If item with same name exists, copied item will be renamed with the suffix &amp;quot;_copied&amp;quot;.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;V&lt;&#x2F;td&gt;&lt;td&gt;Switch to select mode, where you can move cursor to select items.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;d (select mode)&lt;&#x2F;td&gt;&lt;td&gt;Delete and yank selected items, and return to normal mode.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;y (select mode)&lt;&#x2F;td&gt;&lt;td&gt;Yank selected items, and return to normal mode.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;t&lt;&#x2F;td&gt;&lt;td&gt;Toggle sort order (by name &amp;lt;-&amp;gt; by modified time). This change remains until the program ends (sort order will be restored as configured).&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;:&lt;&#x2F;td&gt;&lt;td&gt;Switch to shell mode (&lt;em&gt;&lt;strong&gt;experimantal&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;). Type command and press Enter to execute it. You can use any command in the displayed directory, but it may fail to execute the command (e.g. &lt;code&gt;cd&lt;&#x2F;code&gt; doesn&#x27;t work for now), and also the display of items may collapse during execution.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;c&lt;&#x2F;td&gt;&lt;td&gt;Switch to rename mode (enter new name and press Enter to rename the item).&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&#x2F;&lt;&#x2F;td&gt;&lt;td&gt;Switch to filter mode (enter keyword and press Enter to go to filtered list).&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Esc&lt;&#x2F;td&gt;&lt;td&gt;Return to normal mode.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;:e&lt;&#x2F;td&gt;&lt;td&gt;Reload the current directory. Useful when something goes wrong in filter mode (e.g. no matches) or shell mode.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;:empty&lt;&#x2F;td&gt;&lt;td&gt;Empty the trash directory. &lt;strong&gt;Please think twice before using this command.&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;:h&lt;&#x2F;td&gt;&lt;td&gt;Show help.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;:q &#x2F; ZZ&lt;&#x2F;td&gt;&lt;td&gt;Exit the program.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Note that items moved to the trash directory are prefixed with Unix time (like &lt;code&gt;1633843993&lt;&#x2F;code&gt;) to avoid name conflict. This prefix will be removed when paste.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;settings&quot;&gt;Settings&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;config file&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;$XDG_CONFIG_HOME&#x2F;felix&#x2F;config.toml&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;trash directory&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;$XDG_CONFIG_HOME&#x2F;felix&#x2F;trash&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Default config file, which is &lt;a href=&quot;config.toml&quot;&gt;here&lt;&#x2F;a&gt;, will be created automatically when you launch the program for the first time.&lt;&#x2F;p&gt;
&lt;p&gt;In config.toml, you can set:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;color of directories, files, and symlinks separatively&lt;&#x2F;li&gt;
&lt;li&gt;default key for sorting item list (&amp;quot;Name&amp;quot; or &amp;quot;Time&amp;quot;)&lt;&#x2F;li&gt;
&lt;li&gt;how to open files&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;command-setting&quot;&gt;Command setting&lt;&#x2F;h3&gt;
&lt;p&gt;If you write&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;default = &amp;quot;nvim&amp;quot;

[exec]
feh = [&amp;quot;jpg&amp;quot;, &amp;quot;jpeg&amp;quot;, &amp;quot;png&amp;quot;, &amp;quot;gif&amp;quot;, &amp;quot;svg&amp;quot;]
zathura = [&amp;quot;pdf&amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;then, .jpg, .jpeg, .png, .gif and .svg files are opened by &lt;code&gt;feh &amp;lt;file-name&amp;gt;&lt;&#x2F;code&gt;, .pdf files by &lt;code&gt;zathura &amp;lt;file-name&amp;gt;&lt;&#x2F;code&gt; and others by &lt;code&gt;nvim &amp;lt;file-name&amp;gt;&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>関数型的に入門するC++</title>
            <pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/getting-started-functional-cpp/</link>
            <guid>https://kyoheiu.gitlab.io/post/getting-started-functional-cpp/</guid>
            <description>&lt;p&gt;C++に興味が出てきて勉強中。参考としているのは&lt;a href=&quot;https:&#x2F;&#x2F;ezoeryou.github.io&#x2F;cpp-intro&#x2F;#%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0&quot;&gt;江添亮の C++入門&lt;&#x2F;a&gt;。わかりやすく、ユーモアもところどころあって楽しい。とりあえずアルゴリズムについて、関数型（というか Haskell）的な視点でまとめておく。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;yi-lan&quot;&gt;一覧&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;ezoeryou.github.io&#x2F;cpp-intro&#x2F;#%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0&quot;&gt;アルゴリズム&lt;&#x2F;a&gt;の章で紹介されている各関数は高階関数として捉えると理解が捗る。とくにこの場合、イテレータから説明が続いているので、&lt;code&gt;Foldable a&lt;&#x2F;code&gt;に対して適用される&lt;code&gt;Data.List&lt;&#x2F;code&gt;収録の関数として変換していくととても覚えやすいと思う。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;for_each -&amp;gt; map || foldr
all_of -&amp;gt; all
any_of -&amp;gt; any
none_of -&amp;gt; !all
find -&amp;gt; elem
find_if -&amp;gt; head . filter f
count -&amp;gt; length . filter (==x)
count_if -&amp;gt; length . filter f
equal -&amp;gt; [a] == [b] || f([a]) == f([b])　 &amp;#x2F;&amp;#x2F;関数をとる場合もある
search -&amp;gt; ???
transform -&amp;gt; map

&amp;#x2F;&amp;#x2F;ラムダ式
[](a x) -&amp;gt; b {...}
\x -&amp;gt; f(x) :: a -&amp;gt; b
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;練習も兼ねて書いてみよう。上が Haskell、下が main 関数で記述した C++（厳密には対応していないので悪しからず）。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;for-each&quot;&gt;for_each&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;map (*2) [1..4]

-----

void f(int x)
{
    x = x * 2;
    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
}

int main()
{
    std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4};
    for_each(std::begin(v), std::end(v), f);
}

&amp;#x2F;&amp;#x2F;ラムダ式
for_each(std::begin(v), std::end(v), [](auto x)
             { std::cout &amp;lt;&amp;lt; x * 2 &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;; });
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;all-of&quot;&gt;all_of&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;all (even) [2,4,6,8]

-----

int main()
{
    std::vector&amp;lt;int&amp;gt; v = {2, 4, 6, 8};
    std::cout &amp;lt;&amp;lt; std::boolalpha;
    std::cout &amp;lt;&amp;lt; all_of(std::begin(v), std::end(v), [](auto value)
                        { return value % 2 == 0; });
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;find&quot;&gt;find&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;3 `elem` [1..4] &amp;#x2F;&amp;#x2F; True
5 `elem` [1..4] &amp;#x2F;&amp;#x2F; False

-----

int main()
{
    std::vector&amp;lt;int&amp;gt; v = {2, 4, 6, 8};
    if (std::end(v) == find(std::begin(v), std::end(v), 4))
    {
        std::cout &amp;lt;&amp;lt; &amp;quot;Not found.\n&amp;quot;;
    }
    else
    {
        std::cout &amp;lt;&amp;lt; &amp;quot;Found.\n&amp;quot;;
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;find(first, last, value)&lt;&#x2F;code&gt;の場合、value が見つからなかったときに返るのは last だが、出力時に要素の&lt;code&gt;0&lt;&#x2F;code&gt;と区別がつかなくなってしまうので、&lt;code&gt;std::end(v)&lt;&#x2F;code&gt;との比較でケースを分けている。パターンマッチングでもっとシンプルにしたいが…？&lt;&#x2F;p&gt;
&lt;h4 id=&quot;count&quot;&gt;count&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;(length . filter (==1)) [1,2,1,1,2,1,3]

-----

int main()
{
    std::vector&amp;lt;int&amp;gt; v = {1, 2, 1, 1, 2, 1, 3};
    std::cout &amp;lt;&amp;lt; count(v.begin(), v.end(), 1);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;search&quot;&gt;search&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;import qualified Data.List as L

search :: Eq a =&amp;gt; [a] -&amp;gt; [a] -&amp;gt; Maybe Int
search xs ys =
  case L.elemIndex (head xs) ys of
    Just n -&amp;gt;
      if take (length xs) (drop n ys) == xs
        then Just n
        else (+) &amp;lt;$&amp;gt; Just (n + 1) &amp;lt;*&amp;gt; search xs (drop (n + 1) ys)
    Nothing -&amp;gt; Nothing

-----

int main()
{
    std::vector&amp;lt;int&amp;gt; v1 = {1, 2, 3, 4, 5, 6};
    std::vector&amp;lt;int&amp;gt; v2 = {2, 3, 4};

    std::cout &amp;lt;&amp;lt; *search(v1.begin(), v1.end(), v2.begin(), v2.end());
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;search(first1,last1,first2,last2)&lt;&#x2F;code&gt;は、[first1,last1)の範囲に[first2,last2)があれば、見つかったサブシークエンスの先頭のイテレータを返す関数。微妙に複雑だ。&lt;br &#x2F;&gt;
これを Haskell で実装してみると…。単に「含むかどうか」を&lt;code&gt;Bool&lt;&#x2F;code&gt;で返すなら&lt;code&gt;isInfixOf&lt;&#x2F;code&gt;があるが、最初の要素となると、先頭がマッチするだけでなく、そのあとの並びがきちんと求めるリストと一致しているかどうかを見た上で、&lt;code&gt;drop&lt;&#x2F;code&gt;した数と足していかないといけない。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;c-mian-bai-i&quot;&gt;C++、面白い&lt;&#x2F;h4&gt;
&lt;p&gt;「C++で関数型プログラミングをする」ために書かれた本もいくつかあるようだ。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.manning.com&#x2F;books&#x2F;functional-programming-in-c-plus-plus&quot;&gt;Manning | Functional Programming in C++&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B07MTBCCV5&quot;&gt;Amazon | Hands-On Functional Programming with C++: An effective guide to writing accelerated functional code using C++17 and C++20 (English Edition) [Kindle edition] by Bolboaca, Alexandru | Hardware | Kindle ストア&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;上の Manning の本を読み始めているが、関数合成的（？）なことができるパイプというものがあるらしく、色々できそうで楽しみです。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>purify Amazon URL - an extention for Firefox</title>
            <pubDate>Fri, 20 Aug 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/purify-amazon-url/</link>
            <guid>https://kyoheiu.gitlab.io/post/purify-amazon-url/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;addons.mozilla.org&#x2F;en-US&#x2F;firefox&#x2F;addon&#x2F;purify-amazon-url&#x2F;&quot;&gt;purify Amazon URL – Get this Extension for 🦊 Firefox (en-US)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;An extention for Firefox that purifies Amazon URL and reloads tab.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;example&quot;&gt;example&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;https:&amp;#x2F;&amp;#x2F;www.amazon.com&amp;#x2F;Learn-You-Haskell-Great-Good-ebook-dp-B004VB3V0K&amp;#x2F;dp&amp;#x2F;B004VB3V0K&amp;#x2F;ref=mt_other?_encoding=UTF8&amp;amp;me=&amp;amp;qid=
-&amp;gt;
https:&amp;#x2F;&amp;#x2F;www.amazon.com&amp;#x2F;dp&amp;#x2F;B004VB3V0K
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;usage&quot;&gt;usage&lt;&#x2F;h3&gt;
&lt;p&gt;Just right-click and choose &amp;quot;purify Amazon URL&amp;quot; to reload Amazon page with purified URL.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>やる気因子の重み付けをする</title>
            <pubDate>Fri, 20 Aug 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/self-motivation/</link>
            <guid>https://kyoheiu.gitlab.io/post/self-motivation/</guid>
            <description>&lt;p&gt;「できる」「すべき」「したい」&#x2F;can, should, wantが揃うとモチベーションが湧いてくる、という話をたまに見聞きするが、それが仕事でも家事でも、その他のなんの活動でもいいのだけれど、何かをやろうとするときにモチベーションが問題になるのは大抵、当の人間がモチベーションを感じて「いない」ときである。この、やる気を感じるときと感じられないときがある、ということについて、少し考えてみたい。&lt;&#x2F;p&gt;
&lt;p&gt;まず、自分自身が手応えを感じていない状況について考えてみるが、&amp;quot;I can do it&amp;quot;, &amp;quot;It should be done&amp;quot;, &amp;quot;It&#x27;s worth it&amp;quot;の３つがすべて揃っているというのは、誰にとってもレアなことのように思う。大抵の場合、どれかはあって、どれかはない。たとえばAという作業について、これまでの自分の経験から、やればできることはわかっている。けれども、やる価値をどうにも感じられない…ということは多い（e.g. 運動）。あるいは、統計的にBをやれば生産性が上がることはわかっているし、生産性が上がることには価値も感じる。けれども自分にはどうしてもできない…ということもあるだろう（e.g. 早寝早起き）。&lt;br &#x2F;&gt;
だからといって、３つ揃っていないと何事もとりかかれない・達成できないということはない。人生はもう少しambiguityに満ちている。ここで考えたいのは、「人によって、何があればやる気を出せるかは異なっている」という事実だ。&lt;&#x2F;p&gt;
&lt;p&gt;たとえば、Cに価値を感じられれば、その瞬間Cをするスキルがなく、Cを支える理論やデータも知らないとしても、とにかくやりたくなり、実際にやってみる、という人がいる(worth)。あるいは、特に積極的な価値を強く感じているわけでもなく、理論も知らないが、できるから、という理由で何かにとりかかる人もいる(can)。とにかく義務だからこれをやるのだ、という人もいるはずだ(should)。&lt;br &#x2F;&gt;
自らのやる気に対してどの因子が最も強く働くかは、相当な個人差があるし、この「やる気因子の重み」というのは、各行動のカテゴリによってもわりと異なるはずだ。たとえば、自分自身の勉強なら何でも、やりたいと思っただけでどんどん手が出せるけれど、こどもに対する教育に関してはむしろやるべきだからやるのだと考えている、といったケースだ。単純に10ポイントを割り振る（数字が大きいほどやる気に直結するとする）として、この場合、勉強においてはたとえばcan-2, should-2, worth-6、こどもの教育はcan-2, should-5, worth-3みたいに表現ができるかもしれない。&lt;br &#x2F;&gt;
だから、まず自分自身のやる気の現状を把握するには、自分がやる気を出したいカテゴリにおいて、今現在どのタイプであるのかを認識することが大切だ。その上で、「このツボを押せば自分はやる気が出る・前に進める」というポイントを着実に押さえていく。&lt;&#x2F;p&gt;
&lt;p&gt;また、この重み付けは、先天的な部分と後天的な部分、両方あるように感じる。周囲の人間のリアクションや助言でやる気が形作られていく（あるいは逆に、やる気を削がれていく）というのはよくある話だ。それが積み重なることで、次第に自分の中の重み付けが変化していき、「自分はここを押されるとやる気が出る」という意識が出てくるのではないか。&lt;br &#x2F;&gt;
重み付けの変化に年齢的なリミットがあるのかどうかはよく分からないが、「大人になってから、それまで感じたことのないタイプのやる気が湧いてくる」というのは個人的にも”ある話”なので、わりといつでも更新できるのではないか（その時々にフィットする、自分に対するナッジを見出だせるのではないか）、という希望を持っている。&lt;&#x2F;p&gt;
&lt;p&gt;こんなふうに、自分の「やる気因子の重み付け」を意識することができれば、他人との付き合い方にも活かせるような気がする。たとえば一緒に働いている人がいまいちやる気を出せていないとき。パートナーが手応えを感じていなさそうなとき。「自分はこんなにやる気があるのに、どうして？」とつい思う。それが積み重なると、相手にそもそもやる気を起こす気がないのではと考えるようになってしまう。けれど、自分が手応えを感じていて、同時に相手が手応えを感じていないということが有り得るのだ、と考えられれば、そんな心理状態からは抜け出すことができる。&lt;br &#x2F;&gt;
単純な話だが、他人とうまくやっていくためには、けっこう大事なポイントじゃないかなと思っている。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>rewind - A CLI tool to downgrade packages using local Pacman cache</title>
            <pubDate>Sun, 08 Aug 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/rewind-downgrade-cli/</link>
            <guid>https://kyoheiu.gitlab.io/post/rewind-downgrade-cli/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kyoheiu&#x2F;rewind&quot;&gt;kyoheiu&#x2F;rewind&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;sample.gif&quot; alt=&quot;gif&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;kyoheiu&amp;#x2F;rewind.git
cd rewind
cabal install
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;rewind [package name you want to downgrade]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;like &lt;code&gt;rewind neovim&lt;&#x2F;code&gt;.
You can use mutliple arguments like &lt;code&gt;rewind neovim emacs&lt;&#x2F;code&gt; as well.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>reme - A simple CLI tool to create slack reminder</title>
            <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/reme-slack-reminder-cli/</link>
            <guid>https://kyoheiu.gitlab.io/post/reme-slack-reminder-cli/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kyoheiu&#x2F;reme&quot;&gt;kyoheiu&#x2F;reme&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;sample.gif&quot; alt=&quot;gif&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;kyoheiu&amp;#x2F;reme.git
cd reme
cabal install
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You need &lt;code&gt;~&#x2F;.config&#x2F;reme.dhall&lt;&#x2F;code&gt; file to store the slack authentication token.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;dhall&quot; class=&quot;language-dhall &quot;&gt;&lt;code class=&quot;language-dhall&quot; data-lang=&quot;dhall&quot;&gt;{ slackToken = &amp;quot;xoxp-xxxxxx...&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you&#x27;d like to change the file path, replace &lt;code&gt;path&lt;&#x2F;code&gt; in Main.hs.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;&#x2F;h3&gt;
&lt;p&gt;To set reminder,&lt;code&gt;reme &amp;quot;[text]&amp;quot; &amp;quot;[time]&amp;quot;&lt;&#x2F;code&gt; will work.&lt;br &#x2F;&gt;
&lt;code&gt;reme &amp;quot;[text]&amp;quot;&lt;&#x2F;code&gt; will ask you the time to send reminder.&lt;br &#x2F;&gt;
&lt;code&gt;reme&lt;&#x2F;code&gt; shows this help.&lt;&#x2F;p&gt;
&lt;p&gt;For example,&lt;br &#x2F;&gt;
&lt;code&gt;reme &amp;quot;foo&amp;quot; &amp;quot;in 1 hour&amp;quot;&lt;&#x2F;code&gt; sets the reminder for &amp;quot;foo&amp;quot; in 1 hour.&lt;br &#x2F;&gt;
&lt;code&gt;reme &amp;quot;foo&amp;quot;&lt;&#x2F;code&gt; asks you the time to send reminder for &amp;quot;foo&amp;quot;.&lt;&#x2F;p&gt;
&lt;p&gt;For the token and argument for the time detail, see &lt;a href=&quot;https:&#x2F;&#x2F;api.slack.com&#x2F;methods&#x2F;reminders.add&quot;&gt;reminders.add method | Slack&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>各パーサーコンビネータにおけるtry&#x2F;eof(endOfInput)の挙動</title>
            <pubDate>Sat, 31 Jul 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/try-and-eof-in-parser-combinators/</link>
            <guid>https://kyoheiu.gitlab.io/post/try-and-eof-in-parser-combinators/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;adventofcode.com&#x2F;2020&#x2F;day&#x2F;19&quot;&gt;Advent of Code 2020のDay 19&lt;&#x2F;a&gt;を解いていて、複数パーサーの選択でしばらくつまずいていたのでメモ。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tl-dr&quot;&gt;TL;DR&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;MegaparsecおよびParsecでは、tryでくるんだパーサー内でeofを使うと正常に動かない場合がある？&lt;&#x2F;li&gt;
&lt;li&gt;Attoparsecではchoice内でも問題なくendOfInputが動く。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;tekisutowozhi-he-xing-norisutonipasusuru&quot;&gt;テキストを直和型のリストにパースする&lt;&#x2F;h3&gt;
&lt;p&gt;Day 19では次のようなテキストを適切にパースすることが求められる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;0: 4 1 5
1: 2 3 | 3 2
2: 4 4 | 5 5
3: 4 5 | 5 4
4: &amp;quot;a&amp;quot;
5: &amp;quot;b&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これを、ひとまず次のような型としてパースしたい。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;data Rule = Zero [Int]
          | Pairs Int [(Int,Int)]
          | Key Int Char
          deriving Show

-- expected result
[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &amp;#x27;a&amp;#x27;,Key 5 &amp;#x27;b&amp;#x27;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;０から始まる行は「特殊ルール」として、Zero [Int]で拾う。&lt;&#x2F;li&gt;
&lt;li&gt;それ以外の行は、
&lt;ul&gt;
&lt;li&gt;数字と&amp;quot;|&amp;quot;のみの行についてはPairsで、&lt;&#x2F;li&gt;
&lt;li&gt;アルファベットが含まれる行はKeyで拾う。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;magaparsec-trydeshi-bai-sitekurenai&quot;&gt;Magaparsec - &lt;code&gt;try&lt;&#x2F;code&gt;で失敗してくれない？&lt;&#x2F;h3&gt;
&lt;p&gt;最初に使ったのはMegaparsec。このソースコードから始めよう。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;import qualified Data.Map.Strict as M
import Text.Megaparsec
import Text.Megaparsec.Char
import qualified Data.Text as T
import Data.Void
import Data.Either (rights)

type Parser = Parsec Void String

readInt x = read x :: Int

data Rule = Zero [Int]
          | Pairs Int [(Int,Int)]
          | Key Int Char
          deriving Show

zero :: Parser Rule
zero = do
  string &amp;quot;0: &amp;quot;
  list &amp;lt;- sepBy1 (many alphaNumChar) (char &amp;#x27; &amp;#x27;)
  return $ Zero (map readInt list)

pair :: Parser (Int,Int)
pair = do
  y &amp;lt;- many digitChar
  char &amp;#x27; &amp;#x27;
  z &amp;lt;- many digitChar
  return (readInt y, readInt z)

pairs :: Parser Rule
pairs = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  string &amp;quot;: &amp;quot;
  p &amp;lt;- sepBy1 pair (string &amp;quot; | &amp;quot;)
  return $ Pairs n p

key :: Parser Rule
key = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  string &amp;quot;: \&amp;quot;&amp;quot;
  c &amp;lt;- letterChar
  char &amp;#x27;\&amp;quot;&amp;#x27;
  return $ Key n c

rules = try zero &amp;lt;|&amp;gt; key &amp;lt;|&amp;gt; pairs

main = readFile &amp;quot;day19e.txt&amp;quot; &amp;gt;&amp;gt;= print . rights . map (parse rules &amp;quot;&amp;quot;) . lines
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;cabal repl&lt;&#x2F;code&gt;で&lt;code&gt;main&lt;&#x2F;code&gt;を実行すると、結果はこうなる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[Zero [4,1,5],Key 4 &amp;#x27;a&amp;#x27;,Key 5 &amp;#x27;b&amp;#x27;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Data.Either&lt;&#x2F;code&gt;の&lt;code&gt;rights&lt;&#x2F;code&gt;で強制的に&lt;code&gt;Right&lt;&#x2F;code&gt;のみを抽出しているので分かりにくいが、２〜４行めはパースに失敗している。ちなみにエラーメッセージはかなり難解。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Right (Zero [4,1,5]),Left (ParseErrorBundle {bundleErrors = TrivialError 1 (Just (Tokens (&amp;#x27;:&amp;#x27; :| &amp;quot; 2&amp;quot;))) (fromList [Tokens (&amp;#x27;:&amp;#x27; :| &amp;quot; \&amp;quot;&amp;quot;),Label (&amp;#x27;a&amp;#x27; :| &amp;quot;lphanumeric character&amp;quot;)]) :| [], bundlePosState = PosState {pstateInput = &amp;quot;1: 2 3 | 3 2&amp;quot;, pstateOffset = 0, pstateSourcePos = SourcePos {sourceName = &amp;quot;&amp;quot;, sourceLine = Pos 1, sourceColumn = Pos 1}, pstateTabWidth = Pos 8, pstateLinePrefix = &amp;quot;&amp;quot;}}),Left (ParseErrorBundle {bundleErrors = TrivialError 1 (Just (Tokens (&amp;#x27;:&amp;#x27; :| &amp;quot; 4&amp;quot;))) (fromList [Tokens (&amp;#x27;:&amp;#x27; :| &amp;quot; \&amp;quot;&amp;quot;),Label (&amp;#x27;a&amp;#x27; :| &amp;quot;lphanumeric character&amp;quot;)]) :| [], bundlePosState = PosState {pstateInput = &amp;quot;2: 4 4 | 5 5&amp;quot;, pstateOffset = 0, pstateSourcePos = SourcePos {sourceName = &amp;quot;&amp;quot;, sourceLine = Pos 1, sourceColumn = Pos 1}, pstateTabWidth = Pos 8, pstateLinePrefix = &amp;quot;&amp;quot;}}),Left (ParseErrorBundle {bundleErrors = TrivialError 1 (Just (Tokens (&amp;#x27;:&amp;#x27; :| &amp;quot; 4&amp;quot;))) (fromList [Tokens (&amp;#x27;:&amp;#x27; :| &amp;quot; \&amp;quot;&amp;quot;),Label (&amp;#x27;a&amp;#x27; :| &amp;quot;lphanumeric character&amp;quot;)]) :| [], bundlePosState = PosState {pstateInput = &amp;quot;3: 4 5 | 5 4&amp;quot;, pstateOffset = 0, pstateSourcePos = SourcePos {sourceName = &amp;quot;&amp;quot;, sourceLine = Pos 1, sourceColumn = Pos 1}, pstateTabWidth = Pos 8, pstateLinePrefix = &amp;quot;&amp;quot;}}),Right (Key 4 &amp;#x27;a&amp;#x27;),Right (Key 5 &amp;#x27;b&amp;#x27;)]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;色々と試行錯誤した結果わかったのは、&lt;code&gt;try&lt;&#x2F;code&gt;でくるんでいるからといって必ず適切なパーサーを選択してくれるわけではない（適切に選択してもらうためには工夫が必要）ということ。&lt;&#x2F;p&gt;
&lt;p&gt;たとえば２行目の&lt;code&gt;1: 2 3 | 3 2&lt;&#x2F;code&gt;のみをパースしてみると、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;*Main&amp;gt; parseTest rules &amp;quot;1: 2 3 | 3 2&amp;quot;
1:2:
  |
1 | 1: 2 3 | 3 2
  |  ^^^
unexpected &amp;quot;: 2&amp;quot;
expecting &amp;quot;: &amp;quot;&amp;quot; or alphanumeric character
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;try&lt;&#x2F;code&gt;でくるんでいるから最終的にはpairsを使ってパースしてくれるはずなのに、そうなっていない。&lt;br &#x2F;&gt;
ちなみに&lt;code&gt;pairs&lt;&#x2F;code&gt;単体でパースすると、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;*Main&amp;gt; parseTest pairs &amp;quot;1: 2 3 | 3 2&amp;quot;
Pairs 1 [(2,3),(3,2)]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;となって正しい結果が出るので、&lt;code&gt;pairs&lt;&#x2F;code&gt;自体にミスがあるわけではなさそうだ。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;rules&lt;&#x2F;code&gt;はまず&lt;code&gt;zero&lt;&#x2F;code&gt;をトライするが、&lt;code&gt;string &amp;quot;0: &amp;quot;&lt;&#x2F;code&gt;にマッチしないので失敗し、backtrackが発生する。&lt;br &#x2F;&gt;
次に&lt;code&gt;key&lt;&#x2F;code&gt;をトライする。そうすると、最初の&lt;code&gt;many alphaNumChar&lt;&#x2F;code&gt;は成功するが、次の&lt;code&gt;string &amp;quot;: \&amp;quot;&amp;quot;&lt;&#x2F;code&gt;は失敗するのでまたbacktrackが発生する…はずなのだがそうならず、パースは失敗に終わる。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tryyi-jiang-noxuan-ze-zhi-noshun-fan-nanoka&quot;&gt;&lt;code&gt;try&lt;&#x2F;code&gt;以降の選択肢の順番なのか？&lt;&#x2F;h3&gt;
&lt;p&gt;最初に、&lt;code&gt;try&lt;&#x2F;code&gt;のくるみ方に問題があるのかもしれないと考えて、&lt;code&gt;try&lt;&#x2F;code&gt;のあとを色々と変えてみた。すると実際、&lt;code&gt;rules = try key &amp;lt;|&amp;gt; zero &amp;lt;|&amp;gt; pairs&lt;&#x2F;code&gt;とした場合は、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &amp;#x27;a&amp;#x27;,Key 5 &amp;#x27;b&amp;#x27;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;となり成功している。&lt;&#x2F;p&gt;
&lt;p&gt;さらに、&lt;code&gt;rules = try key &amp;lt;|&amp;gt; pairs &amp;lt;|&amp;gt; zero&lt;&#x2F;code&gt;の場合。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &amp;#x27;a&amp;#x27;,Key 5 &amp;#x27;b&amp;#x27;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;一見成功しているように見えるが、第１行めが&lt;code&gt;Zero&lt;&#x2F;code&gt;ではなく&lt;code&gt;Pairs&lt;&#x2F;code&gt;でのパースになってしまっているので間違っている。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;zero&lt;&#x2F;code&gt;, &lt;code&gt;pairs&lt;&#x2F;code&gt;, &lt;code&gt;key&lt;&#x2F;code&gt;の順番を入れ替えて試した結果は以下の通り。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;order&lt;&#x2F;th&gt;&lt;th align=&quot;left&quot;&gt;result&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;T&#x2F;F&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;zero key pairs&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;[Zero [4,1,5],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;F&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;zero pairs key&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)]]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;F&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;pairs zero key&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;F&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;pairs key zero&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;F&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;key zero pairs&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;T&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;key pairs zero&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;F&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;このあたりで薄々ストーリーが見えてくる。&lt;code&gt;zero&lt;&#x2F;code&gt;で拾いたいのに&lt;code&gt;pairs&lt;&#x2F;code&gt;になってしまっているのは、&lt;code&gt;0: 4 1 5&lt;&#x2F;code&gt;で言うと&amp;quot;1&amp;quot;までは&lt;code&gt;pairs&lt;&#x2F;code&gt;で拾えてしまえることがまず発端になっている。それだけなら残りを失敗するのでいいじゃないか、となりそうだが、途中でパースが止まっても成功扱いとなり、次の行に進んでしまう。&lt;&#x2F;p&gt;
&lt;p&gt;実際、&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;pairs :: Parser Rule
pairs = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  string &amp;quot;: &amp;quot;
  p &amp;lt;- sepBy pair (string &amp;quot; | &amp;quot;)
  return $ Pairs n p
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;と、&lt;code&gt;sepBy1&lt;&#x2F;code&gt;から&lt;code&gt;sepBy&lt;&#x2F;code&gt;にしてみると、結果は&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Pairs 4 [],Pairs 5 []]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;となって最後の２行が&lt;code&gt;pairs&lt;&#x2F;code&gt;で拾われてしまっていることがわかる。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;megaparsecdenoeofnoju-dong&quot;&gt;Megaparsecでのeofの挙動&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;4: &amp;quot;a&amp;quot;&lt;&#x2F;code&gt;が&lt;code&gt;pairs&lt;&#x2F;code&gt;ではなく&lt;code&gt;key&lt;&#x2F;code&gt;で拾うべき行だということをプログラムに伝えるには、&lt;code&gt;try&lt;&#x2F;code&gt;以降のパーサーの順番をあれこれいじるよりも&lt;code&gt;eof&lt;&#x2F;code&gt;を使えばよいのではないか、と思いつき、以下のようにしてみる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;zero :: Parser Rule
zero = do
  string &amp;quot;0: &amp;quot;
  list &amp;lt;- sepBy1 (many alphaNumChar) (char &amp;#x27; &amp;#x27;)
  eof
  return $ Zero (map readInt list)

pair :: Parser (Int,Int)
pair = do
  y &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  char &amp;#x27; &amp;#x27;
  z &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  return (y,z)

pairs :: Parser Rule
pairs = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  string &amp;quot;: &amp;quot;
  p &amp;lt;- sepBy1 pair (string &amp;quot; | &amp;quot;)
  eof
  return $ Pairs n p

key :: Parser Rule
key = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  string &amp;quot;: \&amp;quot;&amp;quot;
  c &amp;lt;- letterChar
  char &amp;#x27;\&amp;quot;&amp;#x27;
  eof
  return $ Key n c
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;しかし結果は変わらず、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;-- try zero &amp;lt;|&amp;gt; pairs &amp;lt;|&amp;gt; key
[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)]]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;入力の終了にのみマッチするはずの&lt;code&gt;eof&lt;&#x2F;code&gt;が動いていない。&lt;&#x2F;p&gt;
&lt;p&gt;念のため、テストパーサーを書いてみるとこちらはちゃんと機能する。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;test :: Parser String
test = do
  s &amp;lt;- many alphaNumChar
  eof
  return s

---

*Main&amp;gt; parseTest test &amp;quot;aaa&amp;quot;
&amp;quot;aaa&amp;quot;
*Main&amp;gt; parseTest test &amp;quot;aaa111&amp;quot;
&amp;quot;aaa111&amp;quot;
*Main&amp;gt; parseTest test &amp;quot;aaa111+++&amp;quot;
1:7:
  |
1 | aaa111+++
  |       ^
unexpected &amp;#x27;+&amp;#x27;
expecting alphanumeric character or end of input
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;attoparsecdenoju-dong&quot;&gt;Attoparsecでの挙動&lt;&#x2F;h3&gt;
&lt;p&gt;つまり、&lt;code&gt;try&lt;&#x2F;code&gt;でくるんだパーサーにおいて&lt;code&gt;eof&lt;&#x2F;code&gt;がちゃんと動いていないのではないか？ということだ。&lt;br &#x2F;&gt;
どこかのコードが間違っている可能性も十分あるし、ソースコードを読んでいないのでMegaparsecの調査としてはここまでなのだが、本来であれば、&lt;code&gt;try&lt;&#x2F;code&gt;以降のパーサーの順序は極力考慮せず組み立てられるのが理想…だと思うので、これは困る。ちなみに、後に検証してみたところ、Parsecの&lt;code&gt;try&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;eof&lt;&#x2F;code&gt;でも同じ問題が発生する。&lt;&#x2F;p&gt;
&lt;p&gt;そこで、試しにAttoparsecを使ってみるとこちらはうまくいった。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;import Data.Attoparsec.Text
import qualified Data.Text as T
import qualified Data.Text.IO as TIO
import Data.Either (rights)

readInt x = read x :: Int

data Rule = Zero [Int]
          | Pairs Int [(Int,Int)]
          | Key Int Char
          deriving Show

zero :: Parser Rule
zero = do
  string &amp;quot;0: &amp;quot;
  list &amp;lt;- many1 digit `sepBy1` char &amp;#x27; &amp;#x27;
  endOfInput
  return $ Zero (map readInt list)

pair :: Parser (Int,Int)
pair = do
  x &amp;lt;- readInt &amp;lt;$&amp;gt; many1 digit
  space
  y &amp;lt;- readInt &amp;lt;$&amp;gt; many1 digit
  return (x,y)

pairs :: Parser Rule
pairs = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many1 digit
  string &amp;quot;: &amp;quot;
  p &amp;lt;- sepBy1 pair (string &amp;quot; | &amp;quot;)
  endOfInput
  return $ Pairs n p

key :: Parser Rule
key = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many1 digit
  string &amp;quot;: \&amp;quot;&amp;quot;
  c &amp;lt;- letter
  char &amp;#x27;\&amp;quot;&amp;#x27;
  endOfInput
  return $ Key n c

rules = choice [pairs, key, zero]

main = TIO.readFile &amp;quot;day19e.txt&amp;quot; &amp;gt;&amp;gt;= print . rights . map (parseOnly rules) . T.lines

---

*Main&amp;gt; main
[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &amp;#x27;a&amp;#x27;,Key 5 &amp;#x27;b&amp;#x27;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;もちろん、&lt;code&gt;choice&lt;&#x2F;code&gt;以降のリスト内の順序をどのパターンにしても、結果は変わらなかった。&lt;&#x2F;p&gt;
&lt;p&gt;ちなみに各パーサーの&lt;code&gt;endOfInput&lt;&#x2F;code&gt;を外すと、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;-- rules = choice [pairs, key, zero]
[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &amp;quot;a&amp;quot;,Key 5 &amp;quot;b&amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;となって１行目を&lt;code&gt;pairs&lt;&#x2F;code&gt;で拾ってしまっているので、やっぱり&lt;code&gt;endOfInput&lt;&#x2F;code&gt;が機能していることがわかる。&lt;&#x2F;p&gt;
&lt;p&gt;コード自体はほぼ変わらない。主な変更点としては、&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Megaparsec&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Attoparsec&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;try&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;choice&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;eof&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;endOfInput&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;まず１点め、&lt;code&gt;try&lt;&#x2F;code&gt;でなく&lt;code&gt;choice&lt;&#x2F;code&gt;を使うというのは、Attoparsecがデフォルトで失敗時backtrackをする仕様のためで、これは素晴らしい（&lt;code&gt;try&lt;&#x2F;code&gt;も実装されているが、これはParsecとの互換性のためと&lt;a href=&quot;https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;attoparsec-0.14.1&#x2F;docs&#x2F;Data-Attoparsec-ByteString.html#v:try&quot;&gt;明記されている&lt;&#x2F;a&gt;）。&lt;br &#x2F;&gt;
そしてMegaparsecの&lt;code&gt;eof&lt;&#x2F;code&gt;とAttoparsecの&lt;code&gt;endOfInput&lt;&#x2F;code&gt;は、どうやら局所的に違う挙動をするらしい。（MegaparsecとParsecがこの点で同じ動きをしたのは、MegaparsecがParsecのフォークだからかもしれない）&lt;&#x2F;p&gt;
&lt;p&gt;同じようなディテールで頭を悩ませている人がいたら、参考になれば幸いです。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>カズオ・イシグロ『クララとお日さま』</title>
            <pubDate>Wed, 28 Jul 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/klara-and-the-sun/</link>
            <guid>https://kyoheiu.gitlab.io/post/klara-and-the-sun/</guid>
            <description>&lt;p&gt;前作『忘れられた巨人』が2015年ということなので、約６年ぶりの新作。前作はファンタジーの体裁をとったひとつの寓話というように比較的明快に読めたが、今作はちょっと読み方が難しい。&lt;&#x2F;p&gt;
&lt;p&gt;今作は全５章から成り、各章がそれぞれ（おおむね）１つの場所とその周辺を舞台としているので、読んでいる感触としては戯曲に近いようなものを感じた。もしくは人形劇。&lt;&#x2F;p&gt;
&lt;p&gt;時代設定としては近未来のアメリカに似た国。格差がいよいよ固定され、世代を超えて継承されていくそれを乗り越えるには、生後、こどもを遺伝子編集すること＝「処置」が事実上唯一の手段である。また各地に脱法・脱国家的なコミュニティが作られ、世界が次第に不安定化しつつある様子が示唆されている。このあたりの容赦のない未来観はさすがと思わせるものがある。クララから見た視覚的世界の揺動、イメージの重なり、間歇といった描写も、2021年の今となっては多かれ少なかれ映画やアニメなどの演出で既視感がある分、すんなり入っていける。&lt;&#x2F;p&gt;
&lt;p&gt;物語はおおむね、クララが「友達」となるジョジーの病気を軸に展開される。ジョジーは、明言されないもののおそらく母親の決断による処置の結果、命にかかわる病を患うようになる。どこの器官が、というよりも彼女は全体的になんとなく衰弱していく。「友達」のクララはジョジーの回復のため、AIらしからぬ祈りと行動に出る…というのが筋だ。&lt;&#x2F;p&gt;
&lt;p&gt;描かれるものとしては、AIのクララから見た人間たちの葛藤、一見矛盾するようでいても同じ心から湧き上がってくる感情と行動、会話の応酬の中で抑えても抑えられず浮かび上がる激情、苦悩、といったところだろうか。会話のやりとりの描き方は、これはもう巧みの一言で、翻訳もしっかりついていっているように感じ、文句のつけどころはない。人間を描く、というのがこの作品の狙いなら、それはひとまず成功している。&lt;&#x2F;p&gt;
&lt;p&gt;だが、この微妙な読後感はなんだろうか。&lt;br &#x2F;&gt;
非合理的な祈りと行動の結果、奇跡としか言いようがない出来事が起こり、ジョジーは回復し、歳を重ね、家を出る。その後、クララは捨てられ、廃棄場で静かに時を過ごしていく。ここで問題なのは、クララが捨てられたことそれ自体ではなく、クララがすべてを受け入れているように見えることでもなく、クララが捨てられ、それをクララ自身が受容していることが、物語上まったく違和感のない形で描かれている、ということだと思う。これはつまり、ジョジーとクララの間には友情なんてものは存在したことがなく、したがって、友達に対してであればあり得ないこの廃棄という行為が、この物語ではあり得てしまう、ということでもある。&lt;br &#x2F;&gt;
実際、ジョジーの回復は特別感動できるようなものではない。クララの目を通して見る彼女たち人間は気まぐれで自分勝手な生き物であり、その不完全さに「まるで自分のような…」という既視感こそ覚えるものの、ちゃんとした愛着を持つほどの対象としては描かれていない（描こうと試みられてさえいない）ように感じる。クララは自らの役目としてジョジーのために力を尽くす。そこに感情はない。クララを「一個」として認めコミュニケーションをとろうとするキャラクターは何人もいるが、彼らの目的はクララのAIとしての判断を仰ぎ、それを何かに活かすことのように見える。結局のところ、ジョジーの身に起きた奇跡がクララのおかげであろうがなかろうが、クララと人間たちの間にinteractionはなかったのではないか。&lt;&#x2F;p&gt;
&lt;p&gt;そう考えると、他の誰でもなくクララを語り手として採用した理由というのは実は、AIが、その存在が物語に影響を与えないような観察者として最もふさわしいからではないか、という気さえしてくる。人間たちの矛盾だらけでなりふり構わない苦闘を、できるだけ元の形を保ったまま掬って表象すること。主人公の役割は純粋なカメラであり、切り取られる人間の物語は有限だが、カメラの命は永遠だ。読み終わった後のどことない居心地の悪さ、あるいは後ろめたさは、物語を成立させていた永遠をつかの間見せつけられたことによるものなのかもしれない。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Haskell環境再構築</title>
            <pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/restart-haskell/</link>
            <guid>https://kyoheiu.gitlab.io/post/restart-haskell/</guid>
            <description>&lt;p&gt;ここ数ヶ月、ずっとimperative programmingをしていてちょっと疲れてきたのと、今Haskellに戻ったら前よりはもう少し書ける／わかるようになっているかもしれないという期待で、あらためてHaskellに入門してみる。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;huan-jing-gou-zhu&quot;&gt;環境構築&lt;&#x2F;h3&gt;
&lt;p&gt;前にやっていたときは確か存在していなかったような気がするのだが、&lt;code&gt;ghcup&lt;&#x2F;code&gt;という&lt;code&gt;rustup&lt;&#x2F;code&gt;的なツールが登場していたのでさっそく入れてみる。&lt;br &#x2F;&gt;
これはghc, cabal, haskell-language-server(HLS)のインストール・バージョン管理を行ってくれるありがたいツールで、途中２回ほどコマンド入力する場面があるので完全放置では完了まで行かないが、スムーズにインストールが可能。以前はstackを使っていたが、cabalがだいぶフレンドリーになってきているという噂を見かけたのでcabal一本でやってみようかと思っている。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gui-men-haskell-language-server&quot;&gt;鬼門・haskell-language-server&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;hie&lt;&#x2F;code&gt;の頃からHaskellのLSPにはいい思い出がなく、ビルド時間が地獄のように長いとか、頑張って入れても全然動かないとかで、この辺の環境構築周りのもどかしさもあっていったん離れることに決めたのだった。今はというと、ほぼ公式のLSPであるHLSがghcupでツルッと入ってくる。これを使えばいい。&lt;&#x2F;p&gt;
&lt;p&gt;ただ、Arch Linux系のディストロを使っている人は、HLSとVS Codeのインテグレーションでおそらく引っかかるだろう。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haskell&#x2F;haskell-language-server&#x2F;issues&#x2F;236&quot;&gt;VSCode extension not detecting Cabal&#x2F;Stack due to incomplete $PATH in &lt;code&gt;&#x2F;etc&#x2F;profile&lt;&#x2F;code&gt; · Issue #236 · haskell&#x2F;haskell-language-server&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;このissueで指摘されているが、Arch系の場合、&lt;code&gt;.bashrc&lt;&#x2F;code&gt;にghcupのPATHを書いてもVS Codeが認識せず、&lt;code&gt;etc&#x2F;profile&lt;&#x2F;code&gt;に書かないと動かない。&lt;del&gt;そして僕の場合は、&lt;code&gt;etc&#x2F;profile&lt;&#x2F;code&gt;に書いた上で、（ランチャーからではなく）ターミナルから&lt;code&gt;code&lt;&#x2F;code&gt;とコマンドを打って起動しないとHLSが動かなかった。ここまでわかるのに半日費やしてしまった…。&lt;&#x2F;del&gt;&lt;&#x2F;p&gt;
&lt;p&gt;(2021-05-22追記)&lt;code&gt;etc&#x2F;profile&lt;&#x2F;code&gt;への記述が間違っていた模様。以下のようにすればVS Codeでバッチリ動いてくれました。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# etc&amp;#x2F;profile
PATH=~&amp;#x2F;.ghcup&amp;#x2F;bin&amp;#x2F;:$PATH
PATH=~&amp;#x2F;.cabal&amp;#x2F;bin&amp;#x2F;:$PATH
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;ランチャーからの起動が実質できないのは良くないので、これを機にneovimでの編集に移行してみる。&lt;br &#x2F;&gt;
ただしvim&#x2F;neovimであっても、Arch系であれば&lt;code&gt;etc&#x2F;profile&lt;&#x2F;code&gt;にPATHを書かなければならないのは同じ（記入後、要再起動）。その上で、HLS公式のイントロダクションに書いてあるとおり、CocでHLSを設定すれば、動く。&lt;&#x2F;p&gt;
&lt;p&gt;久々にHaskellを書くと、頭も指も全然動かなくて逆に面白い。&lt;br &#x2F;&gt;
以前いじっていたときには存在に気づかなかったパイプライン演算子を使って、Project Eulerの２問め。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;import Data.Function

fib:: Integer -&amp;gt; Integer -&amp;gt; Integer -&amp;gt; Integer
fib a b count
    | count == 1 || count == 0 = b
    | count &amp;gt;= 2 = fib b (a+b) (count-1)
    | otherwise = 0

makeFib = fib 1 1

euler2FibList:: Integer -&amp;gt; Integer
euler2FibList n = takeWhile (\x -&amp;gt; makeFib x &amp;lt; n) [1..] &amp;amp; map makeFib &amp;amp; filter even &amp;amp; sum

main = print $ euler2FibList 4000000
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;makeFib&lt;&#x2F;code&gt;を２回使っているのがかっこよくないですね。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>OSSのREADME.md更新について</title>
            <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/update-readme/</link>
            <guid>https://kyoheiu.gitlab.io/post/update-readme/</guid>
            <description>&lt;p&gt;先日publicリポジトリに移したmarkdownパーサ&lt;code&gt;nmark&lt;&#x2F;code&gt;をちまちま更新しているのだが、更新するたびに以下のような作業が発生していてだんだん面倒になってきた。&lt;&#x2F;p&gt;
&lt;script&gt;window.addEventListener(&quot;message&quot;, function(e) {var i = e.data.split(&quot;:&quot;)[1];var h = e.data.split(&quot;:&quot;)[2];if (e.data.split(&quot;:&quot;)[0] == &quot;swimlanes-io&quot; &amp;&amp; i &amp;&amp; h) {document.getElementById(&quot;__sw-io-&quot; + i).setAttribute(&quot;style&quot;,&quot;height:&quot; + h + &quot;px&quot;);}}, false);&lt;&#x2F;script&gt;&lt;div id=&quot;__sw-io-fZAw&quot;&gt;&lt;iframe style=&quot;border:none; width:100%; height:100%&quot; scrolling=&quot;no&quot; src=&quot;https:&#x2F;&#x2F;cdn.swimlanes.io&#x2F;dist&#x2F;embeded.html#fZA7D8IwDIT3&#x2F;ApvQKTC3gEJiYqJhYq9aWJoROpEeUj039MHUKlDN8v3new7zqkV&#x2F;gXJKRERvE1RE3LO2LTPjjAO+Y8ItsXYaHrOgBRBbMvyssuBEBVECx6lcDF5hBpJNgPJ&#x2F;tjCU5Fua4OgKURhzHSvWsVBQqZyjwZFwFFc4ZvOoX&#x2F;0qWCzPwwC1EkbtVlYvjGldR3g21kf+yjz98s67lMdt+J0vhbsAw==#fZAw&quot;&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;div&gt;
&lt;p&gt;（さっき見つけた&lt;a href=&quot;https:&#x2F;&#x2F;swimlanes.io&#x2F;&quot;&gt;swimlane.io&lt;&#x2F;a&gt;を使ってみたかったのであえて作ってみた）&lt;&#x2F;p&gt;
&lt;p&gt;今思いつく解決策としては、&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;ベンチマーク出力を２つの外部プログラム（静的サイトジェネレータ、hyperfine）に頼っているので、&lt;code&gt;nmark&lt;&#x2F;code&gt;内に実装し、SCFなりでREADME.mdを生成する関数も書いて更新する。&lt;&#x2F;li&gt;
&lt;li&gt;ベンチマークを画像として出力し、リポジトリに含めて&lt;code&gt;git push&lt;&#x2F;code&gt;し、README.md内には画像リンクとして取り込む。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;git push&lt;&#x2F;code&gt;をトリガーとしてベンチマークをとってくれるCIを設定し、出力を取り込んでREADME.mdを更新する（もしくは更新するところまでGitHub Actionsなどで実装する）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;という感じだが、&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nmark&lt;&#x2F;code&gt;内に全部取り込むのは（可能だが）間違っている気がする&lt;&#x2F;li&gt;
&lt;li&gt;数字を画像で出すのは嫌だ&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;で、CIを勉強してみようかなぁと思っている。最終的にはジェネレータを使わないという選択になりそうな気がする。&lt;&#x2F;p&gt;
&lt;p&gt;こんなふうに、機能を追加したりバグを修正したりするたびにREADME.md内の細かい数字をアップデートしないといけない状況というのはあると思うのだけれど、何か効率的なやり方があるんだろうか。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhui-ji&quot;&gt;追記&lt;&#x2F;h3&gt;
&lt;p&gt;シェルスクリプトの代わりにNimscriptを書いて、パフォーマンス比較の詳細を記したmarkdownファイルをREADME.mdとは別に作り、そこに&lt;code&gt;hyperfine&lt;&#x2F;code&gt;の結果をコピーするというやり方にしてみた。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nim&quot; class=&quot;language-nim &quot;&gt;&lt;code class=&quot;language-nim&quot; data-lang=&quot;nim&quot;&gt;mode = ScriptMode.Verbose

const version = &amp;quot;0.1.6&amp;quot;

const text = &amp;quot;&amp;quot;&amp;quot;
# Perfomance comparison detail
...
### nmark@&amp;quot;&amp;quot;&amp;quot; 

cd &amp;quot;..&amp;#x2F;casa&amp;quot;

exec(&amp;quot;nimble install nmark&amp;quot;)
exec(&amp;quot;nim c -d:release casa&amp;quot;)
exec(&amp;quot;hyperfine &amp;#x27;.&amp;#x2F;casa build&amp;#x27; --export-markdown nmark.md&amp;quot;)
let s = text &amp;amp; version &amp;amp; &amp;quot;&amp;quot;&amp;quot;
&amp;gt;&amp;gt;
&amp;quot;&amp;quot;&amp;quot; &amp;amp; readFile(&amp;quot;nmark.md&amp;quot;)

cd &amp;quot;..&amp;#x2F;nmark&amp;quot;

writeFile(&amp;quot;perfcmp.md&amp;quot;, s)

echo &amp;quot;Done.&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;手動でいじるのは定数として入れているバージョン番号のみなのでだいぶ楽にはなった。この番号も、何らかのスクリプトで.nimbleファイルからとってきたいところだが、適当な関数が見つからないためとりあえずここまでにしている。tomlと見なしてパースすればいいような気もする。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>How to use Google Domains with Netlify</title>
            <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/netlify-and-googledmains-en/</link>
            <guid>https://kyoheiu.gitlab.io/post/netlify-and-googledmains-en/</guid>
            <description>&lt;p&gt;I recently jumped into Netlify-hosted from other server. This article is about how to use Google Domains with Netlify (and why GitLab pages with custom domain is &lt;em&gt;bad&lt;&#x2F;em&gt;).&lt;&#x2F;p&gt;
&lt;p&gt;First of all, Options of hosting service I had in mind were:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Firebase&lt;&#x2F;li&gt;
&lt;li&gt;GitLab pages&lt;&#x2F;li&gt;
&lt;li&gt;Netlify&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Firebase seemed good for dynamic site, but this site is powered by Zola (a fantastic static site generator) so, well, I don&#x27;t use it for now.&lt;&#x2F;p&gt;
&lt;p&gt;Next, GitLab pages. OK I use GitLab for my main repository-hosting service, and it&#x27;s been great. So I thought GitLab pages with custom domain was natural and might be easy.&lt;&#x2F;p&gt;
&lt;p&gt;It was not. Using custom domain in GitLab pages is hard. I do not recommend this setup.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;why&quot;&gt;Why?&lt;&#x2F;h3&gt;
&lt;p&gt;Because its document is broken.&lt;&#x2F;p&gt;
&lt;p&gt;In &lt;a href=&quot;https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;user&#x2F;project&#x2F;pages&#x2F;custom_domains_ssl_tls_certification&#x2F;&quot;&gt;official tutorial&lt;&#x2F;a&gt;, they say &amp;quot;set the A record to foo, and TXT record to bar.&amp;quot; But in the settings page of custom domain, I&#x27;m told to set CNAME and TXT. What&#x27;s going on?&lt;&#x2F;p&gt;
&lt;p&gt;Actually I tried both. Neither did work. Though time might solve this (due to TTL? Note that I&#x27;ve waited for 1 day), I felt like, OK this is enough.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;resource-records-for-netlify&quot;&gt;resource records for Netlify&lt;&#x2F;h3&gt;
&lt;p&gt;So, I went to Netlify, which I&#x27;ve used as an example site for my Zola theme. In &lt;code&gt;DNS &amp;gt;&amp;gt; resource records&lt;&#x2F;code&gt; set as following and, voila, it&#x27;s done:&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;name&lt;&#x2F;th&gt;&lt;th align=&quot;left&quot;&gt;type&lt;&#x2F;th&gt;&lt;th align=&quot;left&quot;&gt;TTL&lt;&#x2F;th&gt;&lt;th align=&quot;left&quot;&gt;data&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;@&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;A&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;10m(or whatever you like)&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;75.2.60.5&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;www&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;CNAME&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;same as above&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;YOURSITENAME.netlify.app.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Netlify automatically set the TLS certificate with Let&#x27;s Encrypt a few minutes after check for DNS configuration. This was a good experience, so I highly recommend Netlify over GitLab pages, at least for now.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Netlifyで独自ドメイン（Google Domains）を使う</title>
            <pubDate>Fri, 30 Apr 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/netlify-and-googledmains/</link>
            <guid>https://kyoheiu.gitlab.io/post/netlify-and-googledmains/</guid>
            <description>&lt;p&gt;Google Domainsで管理している独自ドメインを使っているのだが、少し前にロリポップ！のサーバーから引越しをした。その際、いくつかのホスティングサービスの中でどれがいいか少し迷ったので、メモ。&lt;&#x2F;p&gt;
&lt;p&gt;まず、オプションとして以下のものを考えた。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;Firebase&lt;&#x2F;li&gt;
&lt;li&gt;GitLab pages&lt;&#x2F;li&gt;
&lt;li&gt;Netlify&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;Firebaseは良さげだったが、動的サイトのホスティング向けのような気がしたので今回はパス。&lt;&#x2F;p&gt;
&lt;p&gt;次にGitLab pages。僕はGitLabをメイン使いしているので当初はこれ一択かなと思っていたのだが、はっきり言って期待外れだった。&lt;br &#x2F;&gt;
というのは、独自ドメイン適用周りがどうにもこうにもうまくいっていないのだ。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;naze&quot;&gt;なぜ&lt;&#x2F;h3&gt;
&lt;p&gt;そもそも公式のドキュメントが矛盾しているので、何を信用したらいいのかわからないから。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;user&#x2F;project&#x2F;pages&#x2F;custom_domains_ssl_tls_certification&#x2F;&quot;&gt;チュートリアル&lt;&#x2F;a&gt;ではAレコードをこれこれに、TXTレコードをこれこれに設定しろと書いてあるのに、カスタムドメインの設定画面ではCNAMEとTXTの設定を求めてくる。どういうことだ。&lt;br &#x2F;&gt;
実際両方やってみたのだが、どっちもうまくいかず途方に暮れた。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;netlifydenorekodoshe-ding&quot;&gt;Netlifyでのレコード設定&lt;&#x2F;h3&gt;
&lt;p&gt;というわけで、Zolaのテーマサイトのホスティングにも元々使っていたNetlifyをチョイス。
Google Domainsの設定は以下のようにすればOK。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;name&lt;&#x2F;th&gt;&lt;th align=&quot;left&quot;&gt;type&lt;&#x2F;th&gt;&lt;th align=&quot;left&quot;&gt;TTL&lt;&#x2F;th&gt;&lt;th align=&quot;left&quot;&gt;data&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;@&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;A&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;10m(or whatever you like)&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;75.2.60.5&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;www&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;CNAME&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;same as above&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;YOURSITENAME.netlify.app.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;NetlifyはDNS設定が認証された後、自動的にTLS証明書をLet&#x27;s Encryptからとってきてくれる。独自ドメインでのホスティングは今のところNetlifyが圧勝。GitLab頑張れ。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>nmark - a markdown parser written in Nim</title>
            <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/nmark/</link>
            <guid>https://kyoheiu.gitlab.io/post/nmark/</guid>
            <description>&lt;p&gt;Fast markdown parser, based on CommonMark, written in Nim.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kyoheiu&#x2F;nmark&quot;&gt;kyoheiu&#x2F;nmark&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;nim&quot; class=&quot;language-nim &quot;&gt;&lt;code class=&quot;language-nim&quot; data-lang=&quot;nim&quot;&gt;import nmark

let txt = &amp;quot;&amp;quot;&amp;quot;
&amp;gt; Lorem ipsum dolor
sit amet.
&amp;gt; - Qui *quodsi iracundia*
&amp;gt; - aliquando id
&amp;quot;&amp;quot;&amp;quot;

echo txt.markdown
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;...and it&#x27;s done.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# output
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;Lorem ipsum dolor
sit amet.&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Qui &amp;lt;em&amp;gt;quodsi iracundia&amp;lt;&amp;#x2F;em&amp;gt;&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;aliquando id&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can use tables in &lt;code&gt;nmark&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;| abc | defghi |
:-: | -----------:
bar | baz
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;is converted to:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;
&amp;lt;thead&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;th align=&amp;quot;center&amp;quot;&amp;gt;abc&amp;lt;&amp;#x2F;th&amp;gt;
&amp;lt;th align=&amp;quot;right&amp;quot;&amp;gt;defghi&amp;lt;&amp;#x2F;th&amp;gt;
&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;&amp;#x2F;thead&amp;gt;
&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;bar&amp;lt;&amp;#x2F;td&amp;gt;
&amp;lt;td align=&amp;quot;right&amp;quot;&amp;gt;baz&amp;lt;&amp;#x2F;td&amp;gt;
&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;&amp;#x2F;tbody&amp;gt;
&amp;lt;&amp;#x2F;table&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(Tables need to be separated from other blocks by empty line.)&lt;&#x2F;p&gt;
&lt;h3 id=&quot;performance-comparison&quot;&gt;Performance comparison&lt;&#x2F;h3&gt;
&lt;p&gt;One of the reason I&#x27;m working on this parser is that other markdown parser librarys written in Nim seemed relatively slow. Here is a comparison between &lt;code&gt;nim-markdown&lt;&#x2F;code&gt;, which I think is the standard Nim markdown parser, and &lt;code&gt;nmark&lt;&#x2F;code&gt;, through a static site generator(which, btw, I made) and &lt;code&gt;hyperfine&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;.&#x2F;casa build&lt;&#x2F;code&gt; generates 100 same htmls containing a lot of markdown delimiter. For detail please check my &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kyoheiu&#x2F;Casa&quot;&gt;repo&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;nim-markdown-0-8-5&quot;&gt;nim-markdown@0.8.5 &amp;gt;&amp;gt;&lt;&#x2F;h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Command&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Mean [ms]&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Min [ms]&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Max [ms]&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Relative&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;.&#x2F;casa build&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;296.1 ± 12.2&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;287.6&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;322.4&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;1.00&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h4 id=&quot;nmark-0-1-3&quot;&gt;nmark@0.1.3 &amp;gt;&amp;gt;&lt;&#x2F;h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Command&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Mean [ms]&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Min [ms]&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Max [ms]&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Relative&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;.&#x2F;casa build&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;53.1 ± 7.0&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;51.2&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;91.7&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;1.00&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;caution&quot;&gt;Caution&lt;&#x2F;h3&gt;
&lt;p&gt;This is still work-in-progess project, and does not FULLY pass the &lt;a href=&quot;https:&#x2F;&#x2F;spec.commonmark.org&#x2F;0.29&#x2F;&quot;&gt;spec-test of CommonMark&lt;&#x2F;a&gt;. For example,&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; foo
bar
===
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;... is, by &lt;code&gt;nmark&lt;&#x2F;code&gt;, converted to:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;blockquote&amp;gt;
&amp;lt;h1&amp;gt;foo
bar&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Though I believe &lt;code&gt;nmark&lt;&#x2F;code&gt; is enough for normal usage, I&#x27;m working on improving the accuracy and performance. And issues, pull requests always welcome.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>starshipで絵文字を表示させる（Arch Linux）</title>
            <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/starship-emoji/</link>
            <guid>https://kyoheiu.gitlab.io/post/starship-emoji/</guid>
            <description>&lt;p&gt;先日のArch Linux再インストールに伴い、色々とアプリケーションを入れ直していたのだけれど、&lt;a href=&quot;https:&#x2F;&#x2F;starship.rs&#x2F;&quot;&gt;starship&lt;&#x2F;a&gt;の絵文字表示ができなくなってしまいちょっと手こずったので、メモ。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;bi-yao-napatukezi&quot;&gt;必要なパッケージ&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;starship&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;nerd font(AURの&lt;code&gt;nerd-fonts-source-code-pro&lt;&#x2F;code&gt;を使っているが何でもいいはず)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;noto-emoji&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;noto-fonts&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;noto-fonts-cjk&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;最後の２つのパッケージがないとカバーできないUnicode絵文字が微妙に存在する（たとえば[⇡]）。&lt;&#x2F;p&gt;
&lt;p&gt;starshipの意義については正直なんとも言えないが、デバッグを繰り返しているときに前の実行結果との切れ目がわかりやすい…という効果はある。かもしれない。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>バックアップについて考える</title>
            <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/about-backup/</link>
            <guid>https://kyoheiu.gitlab.io/post/about-backup/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;reinstall-arch&#x2F;&quot;&gt;Arch Linuxを再インストールした話&lt;&#x2F;a&gt;に関連して。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dotfilesnoxi-ifang&quot;&gt;dotfilesの扱い方&lt;&#x2F;h3&gt;
&lt;p&gt;今回感じたのは、最低限i3と、ターミナルエミュレーター &#x2F; vifm &#x2F; nvimを入れて、dotfilesをリモートリポジトリから引っ張ってくれば作業環境は整うわけなので、追加のバックアップ作業はもしかしたら要らないのかも、ということ。これまではtimeshiftで定期的にバックアップをとっていたのだが、結局一度も使わないままだったし…。&lt;br &#x2F;&gt;
逆に上記のパッケージのdotfilesがリモートに存在しない場合、動くことは動くが、細かい設定を整えようとするとかなり面倒くさいことになってしまうので、思っていた以上にdotfilesのバックアップは大事だったとも言える（r&#x2F;unixpornに貼りつけるだけのアレじゃなかった）。&lt;&#x2F;p&gt;
&lt;p&gt;シェルスクリプトでdotfilesの設定ファイルのシンボリックリンクを各所に貼るプログラムを書いている人が多いと思うが、同じようなものをNimでさくっと書いてみたので貼っておきます。&lt;&#x2F;p&gt;
&lt;script src=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;kyoheiu&#x2F;9b5c634d38f26d1b67ad1d34bb29ef76.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;p&gt;&lt;code&gt;os&lt;&#x2F;code&gt;ライブラリの&lt;code&gt;createSymlink&lt;&#x2F;code&gt;は同名のファイルが存在した場合failになるので、ファイルを削除してからシンボリックリンクを作成している。利用する場合は自己責任でお願いします。
nvimのcolorsディレクトリを除いているのはこれ以上コードが入れ子になるのが嫌だったから、程度の理由。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shu-kitupanasikodonoxi-ifang&quot;&gt;書きっぱなしコードの扱い方&lt;&#x2F;h3&gt;
&lt;p&gt;これまで練習用に書いてきたHaskellやらRustやらのコードはクリーンインストールによりすべて消えてしまった。まあ見返すことはほとんどなかったし、作り途中のプロジェクトはGitLabのプライベートリポジトリに上げながらやっているから無事だ。それ以外にも、ちょっと面倒な感じの、たとえばHaskellでスクレイピングするプログラムの骨子などはサイトに上げているので、残りのちまちましたやつ（Project Eulerの解答とか）は別にいいかな…と思いつつ、でもやっぱりちょっとさびしい。&lt;br &#x2F;&gt;
こういう断片的なコードをいちいちGitHub GistsやGitLab Snippetsに上げるか、それとも書き捨てのつもりで気にしないかはけっこう微妙な問題だと思う。見返さなかったとはいえ、振り返ると意外と発見があったり、最近書いていない言語を思い出すのに使ったり、ということもあるだろうし、悩ましい。&lt;br &#x2F;&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;note.com&#x2F;konojunya&#x2F;n&#x2F;n461544d2f881&quot;&gt;Gistsに自動アップロードするCLIを書いている&lt;&#x2F;a&gt;方を見つけて、なるほど、と思ったが、書いた端から上げたい感じもある。VS Codeのエクステンションとか、もうありそうだな…と思ったら&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kenhowardpdx&#x2F;vscode-gist&quot;&gt;あった&lt;&#x2F;a&gt;。自分なりに使いそうなフローで何かCLIを作ってみてもいいかもしれない。&lt;br &#x2F;&gt;
GitLabも&lt;a href=&quot;https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;api&#x2F;snippets.html#get-a-single-snippet&quot;&gt;Snippets APIの紹介がとてもよくまとまっている&lt;&#x2F;a&gt;のでけっこう使いやすそう。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jing-de-saitozieneretanoluo-tosixue&quot;&gt;静的サイトジェネレーターの落とし穴(?)&lt;&#x2F;h3&gt;
&lt;p&gt;それと、Hugo &#x2F; Zolaなどの静的サイトジェネレーターを使っている場合は、サイト上にフロントマター付きの.mdファイルが存在するわけではないので、もしデータが消えてしまった場合はサイト上のテキストをコピーしてきて、あらためて.mdとしてタグ付けをしないといけない（もしくはサイトをスクレイピングして.mdファイルを生成するプログラムを書くか。できなくはないが面倒ではある）。&lt;br &#x2F;&gt;
幸い、数か月前までプライベートリポジトリにサイトごと上げていたので、手作業での.md復旧は数記事で済んだのだが、これがまったくバックアップがない状況だったらけっこう辛かったかもしれない。プライベートリポジトリでもいいので更新時にpushしておくのが大事だとしみじみ思った（もちろん、github.ioなどでサイトをホスティングしている場合は当然バックアップがとれているのでこんなことは考えなくていい）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;owarini&quot;&gt;おわりに&lt;&#x2F;h3&gt;
&lt;p&gt;以上に書いたものはすべてgitのリモートリポジトリの存在が前提になっている。ここに何か落とし穴がまだあるかもしれない。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Arch Linux再インストールで発見したこと</title>
            <pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/reinstall-arch/</link>
            <guid>https://kyoheiu.gitlab.io/post/reinstall-arch/</guid>
            <description>&lt;p&gt;先日自分のミスでパーティションをブレイクしてしまい、Arch Linuxが起動不可の状態に。インストールメディアを準備して&lt;code&gt;arch-chroot&lt;&#x2F;code&gt;すればもしかしたら救出できたのかもしれなかったが、少し時間があったのでこの際、とクリーンインストールをした（ちょうどKDE neonを入れたサブ機を用意したてだったのが本当にラッキーだった）。前回インストールをしたのは１年前だったと思うが、少し様子が変わっていたのでメモ。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;roguwotoreruyouninatuteita&quot;&gt;ログをとれるようになっていた&lt;&#x2F;h4&gt;
&lt;p&gt;もしかするとこれは前からだったかもしれないが、インストール作業のログをとれるようになっている。また、ArchWikiへの誘導も冒頭にあって、ちょっぴり親切な雰囲気が醸し出されていた。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wifi-menugashi-enai&quot;&gt;wifi-menuが使えない&lt;&#x2F;h4&gt;
&lt;p&gt;最新のisoでは&lt;code&gt;wifi-menu&lt;&#x2F;code&gt;が含まれていないのか、開幕&lt;code&gt;wifi-menu&lt;&#x2F;code&gt;でとりあえずネットワーク接続を確保するということができない。&lt;br &#x2F;&gt;
ArchWikiでは&lt;code&gt;iwctl&lt;&#x2F;code&gt;による接続を推奨している。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;iwctl
device list # デバイス名の確認
station &amp;lt;デバイス名&amp;gt; connect &amp;lt;アクセスポイント名&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これでOK。接続したら&lt;code&gt;ctrl+C&lt;&#x2F;code&gt;で抜けることを忘れずに。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;systemd-bootnoshe-ding-womisusitemoqi-kanai&quot;&gt;systemd-bootの設定をミスしても泣かない&lt;&#x2F;h4&gt;
&lt;p&gt;ここで何回かミスってしまったのだが、最初からやり直す必要はない。インストールメディアを挿したまま再起動し、ネットワーク接続を確保した後、マウント。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;mount &amp;#x2F;dev&amp;#x2F;device2 &amp;#x2F;mnt
mount &amp;#x2F;dev&amp;#x2F;device1 &amp;#x2F;mnt&amp;#x2F;boot
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;その後、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;arch-chroot &amp;#x2F;mnt
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これで&lt;code&gt;&#x2F;boot&lt;&#x2F;code&gt;以下の設定ファイルもいじれるようになる。&lt;&#x2F;p&gt;
&lt;p&gt;個人的にミスしやすいポイントとしては、&lt;code&gt;&#x2F;boot&#x2F;loader&#x2F;entries&#x2F;arch.conf&lt;&#x2F;code&gt;内のoptions行。&lt;br &#x2F;&gt;
&lt;code&gt;blkid&lt;&#x2F;code&gt;で調べたPARTUUIDを入れるのだが、間違えてUUIDを入れるとか、違うパーティションのPARTUUIDを入れてしまうといったミスが起こりやすい。ここは落ち着いて写真を撮って進行しましょう。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;systemddeyarikurisuruyounizu-mu&quot;&gt;systemdでやりくりするように組む&lt;&#x2F;h4&gt;
&lt;p&gt;以前は&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;archinstall&#x2F;&quot;&gt;この記事&lt;&#x2F;a&gt;にあるようにブートローダーとしてgrubを選択していたのだけど、このコマンドを正確に打つのめっちゃ大変ですよね。systemd-bootに切り替えたほうがインストールは楽になるはず。&lt;br &#x2F;&gt;
ネットワーク接続についても、複数のパッケージで組もうとするとその分再インストールの手間が増え、手順も複雑になって後々わけがわからなくなるので、極力systemd内で生きていくように選択していったほうがよいように思う。&lt;br &#x2F;&gt;
ネットワーク接続は僕の場合、&lt;code&gt;iwd&lt;&#x2F;code&gt;を入れて&lt;code&gt;iwctl&lt;&#x2F;code&gt;で接続したのち、systemd-networkdとsystemd-resolvedを&lt;code&gt;enable&lt;&#x2F;code&gt;し、&lt;code&gt;dhcpcd&lt;&#x2F;code&gt;も入れてnetworkdの各種設定ファイルを作成、で再起動後も自動接続できた（こう書くとかなり面倒くさそうだが、意外とそうでもない）。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Rust入門ルート</title>
            <pubDate>Sat, 13 Feb 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/beginning-rust/</link>
            <guid>https://kyoheiu.gitlab.io/post/beginning-rust/</guid>
            <description>&lt;p&gt;３、４回の挫折を経てようやく「なんとなくRustわかってきたかな」というところまで来れたので、個人的に効率的と考える入門ルートを紹介してみたい。&lt;&#x2F;p&gt;
&lt;p&gt;結論から書くと、&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;『プログラミング言語Rust入門』を読む&lt;&#x2F;li&gt;
&lt;li&gt;とりあえず書いてみる&lt;&#x2F;li&gt;
&lt;li&gt;実践Rustプログラミング入門』を読む&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;これで実践のじの字まではたどり着ける。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gong-shi-dokiyumentonituite&quot;&gt;公式ドキュメントについて&lt;&#x2F;h3&gt;
&lt;p&gt;もちろん充実しているし、丁寧な書きぶり・カバーぶりなのでいろいろなところでおすすめされている。でも、前知識なしに＆おおまかな全体像を持たず読もうとするとだいたいトレイトあたりで力尽きる。実際にプログラムを組むためにはそのあとの.iter()やクロージャを形式的にでも分かっていないと厳しい。Rustの場合は、公式ドキュメントはその他の資料で迷子になったときに戻ってくる場所として認識しておいたほうがよいと思う。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;1-puroguraminguyan-yu-rustru-men&quot;&gt;1. 『プログラミング言語Rust入門』&lt;&#x2F;h3&gt;
&lt;p&gt;C、C++の知識のない人間がRustを始めるにはまずここからがよいと思う。簡潔な語り口と丁寧な説明で、入門書の名前にふさわしい。基本文法や所有権のおおまかな概念理解をすませておくと、先々の言語仕様にも必要以上にひるまずに進めるはず。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;2-toriaezushu-itemiru&quot;&gt;2. とりあえず書いてみる&lt;&#x2F;h3&gt;
&lt;p&gt;なんとなくいけそうな感じになってきたら、何でもいいから書いてみる。Rustはコンパイラに手取り足取り教えてもらって初めて分かるようになる言語だ。だから言語に最短で慣れるには、エラーを取り除くということをたくさんやる、つまりエラーがいっぱいのコードを書くのがいい。&lt;br &#x2F;&gt;
作りたいものがなかったり、作りたくてもハードルが高すぎる場合は、競技プログラミングの問題を解いてみよう。&lt;br &#x2F;&gt;
AtCoderでもいいが、I&#x2F;Oのことを考えないでとりあえず書いてみたい場合はLeetCodeやProject Eulerがおすすめ。前者は数学以外の問題もたくさんあり、後者はすべて数学の問題になっているという違いはあるけれど、いずれも基本的な配列の操作や制御フローの学習に向いている。特にLeetCodeは以下の点でおすすめ。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;ヒントが充実しているし、ユーザー数が多く、ディスカッションもたくさん行われているので、つまずきにくい&lt;&#x2F;li&gt;
&lt;li&gt;わかりやすい難度表示があるのでトライのハードルが低い&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;3-shi-jian-rustpuroguraminguru-men&quot;&gt;3. 『実践Rustプログラミング入門』&lt;&#x2F;h3&gt;
&lt;p&gt;雰囲気で書けるようになってきたらこれを読んで写経してみる。ふわっとした知識だったところが整理され、理解が深まる感じがする。用語の説明不足も、ここまできたら許容範囲に収まっているはず。&lt;br &#x2F;&gt;
逆に言うと、雰囲気ででも書けないと、序盤からわからない用語が出てきてつらい気持ちになるはずなので、これで入門するのはおすすめできない。タイトルの入門は「実践的なプログラミングへの入門」であって「文法や基礎知識への入門」ではない。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rustlings&quot;&gt;rustlings&lt;&#x2F;h3&gt;
&lt;p&gt;公式で提供されているRustコードのデバッグ問題集。正直駆け出しにはかなり難度が高いが、『実践Rustプログラミング入門』まで読めたら数問を除いてパスできるようになっているはず。また、雰囲気が分かってきたトピックの穴を洗い出すためにも使える。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ta-yan-yu-tonobi-jiao-ji-shi&quot;&gt;他言語との比較記事&lt;&#x2F;h3&gt;
&lt;p&gt;HaskellとRustの比較記事をいくつか読んだが、Haskellの知識があれば万事うまくいくわけでは全然ないので、足場にしすぎないことが大事。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zatukurisitadui-ying-guan-xi&quot;&gt;ざっくりした対応関係&lt;&#x2F;h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;&#x2F;th&gt;&lt;th&gt;Rust&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Maybeモナド&lt;&#x2F;td&gt;&lt;td&gt;Option型&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Eitherモナド&lt;&#x2F;td&gt;&lt;td&gt;Result型&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;data&lt;&#x2F;td&gt;&lt;td&gt;struct enum&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;case&lt;&#x2F;td&gt;&lt;td&gt;match&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
</description>
        </item>
        <item>
            <title>Chromium losing Sync support on March 15</title>
            <pubDate>Fri, 05 Feb 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/chromium-losing-sync/</link>
            <guid>https://kyoheiu.gitlab.io/post/chromium-losing-sync/</guid>
            <description>&lt;h3 id=&quot;jing-wei&quot;&gt;経緯&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;blog.chromium.org&#x2F;2021&#x2F;01&#x2F;limiting-private-api-availability-in.html&quot;&gt;Chromium Blog: Limiting Private API availability in Chromium&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;During a recent audit, we discovered that some third-party Chromium based browsers were able to integrate Google features, such as Chrome sync and Click to Call, that are only intended for Google’s use. This meant that a small fraction of users could sign into their Google Account and store their personal Chrome sync data, such as bookmarks, not just with Google Chrome, but also with some third-party Chromium based browsers. We are limiting access to our private Chrome APIs starting on March 15, 2021.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Google提供のChromiumパッケージ以外のChromium、そしてChromiumベースのブラウザにおいて、ブックマークデータのsyncなど、「Googleによる利用のみが想定されていたAPI」の利用がみられることが「分かった」ので、このAPIの利用を21年3月15日より制限することにした、というのがGoogle側の話である。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;archlinux.org&#x2F;news&#x2F;chromium-losing-sync-support-in-early-march&#x2F;&quot;&gt;Arch Linux - News: Chromium losing Sync support in early March&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Google has announced that they are going to block everything but Chrome from accessing certain Google features (like Chrome sync) starting on March 15. This decision by Google is going to affect Arch&#x27;s chromium package a bit earlier, on March 2, when Chromium 89 gets released.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;これを受けて、各ディストリビューションのメンテナも対応を迫られている。Arch Linux版はGoogleによる制限の前に先んじてAPI利用を停止する模様。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;googlenofang-zhen-zhuan-huan&quot;&gt;Googleの方針転換&lt;&#x2F;h3&gt;
&lt;p&gt;しかし、このGoogle側の言い分には事実でない情報が含まれているようだ。
以下のブログの記事を読んでみる。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;hackaday.com&#x2F;2021&#x2F;01&#x2F;26&#x2F;whats-the-deal-with-chromium-on-linux-google-at-odds-with-package-maintainers&#x2F;&quot;&gt;What’s The Deal With Chromium On Linux? Google At Odds With Package Maintainers | Hackaday&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;As developer Eric Hameleers explains in a lengthy blog post, he was supplied with a dedicated API key for his Slackware Chromium builds by the Google Chrome Team in 2013. He was granted “official permission to include Google API keys in your packages”, and was told that the usage quota for that particular key would be increased “in an effort to adequately support your users”, as normally the key he was assigned would only be for personal development use. Evangelos Foutras, the maintainer for the Arch Linux Chromium package, has indicated he received a similar email at around the same time.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;groups.google.com&#x2F;a&#x2F;chromium.org&#x2F;g&#x2F;chromium-packagers&#x2F;c&#x2F;SG6jnsP4pWM&#x2F;m&#x2F;Kr0KlsL8CQAJ?pli=1&quot;&gt;Re: [Action Required] Update on Google API usage in Chromium&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;Arch LinuxのChromiumパッケージのメンテナ・Evangelos Foutras氏の上記書き込みによると、このAPIは実は、2013年ごろにGoogleのChrome開発チームから「公式に再配布が認められていないものを、配布用に提供する」とのメッセージとともに送られたものだという。とすると、少なくともこのAPIの利用が各ディストリビューションのパッケージにおいて始まったタイミングでは、Google側はAPIがサードパーティーによって利用されていることは認識していたし、むしろそれを促進していたということになる。今回の方針転換が、API制限以上の何を示唆しているのかは、それぞれに感じるところがあるだろう。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;sekiyuriteiwen-ti&quot;&gt;セキュリティ問題&lt;&#x2F;h3&gt;
&lt;p&gt;これを受けてのコミュニティの主な反応としては当然、「各ディストリビューションのChromiumパッケージにおいてsyncが行えなくなること」、そして「Googleが提供しているプロプライエタリなChrome、そしてChromiumと比して価値が低落すること」を否定的に受け止め、他ブラウザへ移行するという声が多い。
しかしどうも話は単に「便利機能の制限」にとどまらないようだ。Foutras氏によると、このAPI制限によりセーフブラウンジング機能もdisabledにされる可能性があるとのこと。Safe Browsing Testing Linksでテストすると、&lt;a href=&quot;https:&#x2F;&#x2F;groups.google.com&#x2F;a&#x2F;chromium.org&#x2F;g&#x2F;chromium-packagers&#x2F;c&#x2F;SG6jnsP4pWM&#x2F;m&#x2F;OOxl9wKLAAAJ&quot;&gt;セーフブラウジング機能による警告が動かなかった&lt;&#x2F;a&gt;という。これは利便性がどうこうという話以前の、深刻なトラブルにつながりかねない変更だ。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mentenanofan-ying&quot;&gt;メンテナの反応&lt;&#x2F;h3&gt;
&lt;p&gt;この件については、上記のパッケージメンテナ諸氏による議論のほか、SlackwareのChromiumパッケージのメンテナ・Eric Hameleers氏のブログ記事も大変読み応えがある（&lt;a href=&quot;https:&#x2F;&#x2F;alien.slackbook.org&#x2F;blog&#x2F;google-muzzles-all-chromium-browsers-on-15-march-2021&#x2F;&quot;&gt;Google muzzles all Chromium browsers on 15 March 2021 | Alien Pastures&lt;&#x2F;a&gt;）。普段パッケージを好き勝手に使わせてもらっている身としては、これらの発言の奥にある感情を想像せずにはいられない。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Nimで静的サイトジェネレーターを実装する</title>
            <pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/nim-ssg/</link>
            <guid>https://kyoheiu.gitlab.io/post/nim-ssg/</guid>
            <description>&lt;p&gt;Rust製の静的サイトジェネレーターZolaでスクラッチからテーマを自作したことで、静的サイトジェネレーターそのものに興味が出てきた（以下、「ジェネレーター」と略す箇所が多々あります）。&lt;br &#x2F;&gt;
そこで調べてみて初めて知ったのだが、実は世の中には無数といっていい数の静的サイトジェネレーターがある。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jamstack.org&#x2F;generators&#x2F;&quot;&gt;Static Site Generators - Top Open Source SSGs | Jamstack&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;このページでは、GitHubのスターが多い順に322ものジェネレーターをリストアップしている。Next.js、Hugoに始まり、見たこともないジェネレーターも上のほうにけっこうあったりする。&lt;br &#x2F;&gt;
中には、同じ言語・同じテンプレートエンジンで作られているものもある。たとえば[Pytyon, jinja2]の組み合わせはちょっと数えただけでも10以上ある。それぞれ実装している機能が異なるのだろうし、使い勝手も違うのだろうと思うが、それにしても静的サイトジェネレーターの機能というのはコアの部分はシンプルなはずなので、「ジェネレーターがたくさん作られている」というこの現象は面白い。&lt;br &#x2F;&gt;
なぜなのか、少し考えてみたけれど、まず触っていて気持ちがいいというのは大きいと思う。バッとビルドすれば自分のホームが完成する。こうなるだろうと思ったところから外れることはほとんどない。それでいて、成果物は自分好みのページになっている。これは楽しい。&lt;br &#x2F;&gt;
そして仕組みも、いじっているうちにだんだんわかってくる。テンプレートがあって、マークダウンのファイルがあって、組み合わせて…と、なんだか自分で作れそうな気持ちが湧いてくる。そんな風にして、すでに存在しているジェネレーターと機能は被っている（あるいは場合によっては劣っている）としても、みんなジェネレーターを作ってみたくなるんじゃないだろうか。&lt;&#x2F;p&gt;
&lt;p&gt;僕も実装してみたところ、ざっくりしたプリミティブなジェネレーターが出来たので、紹介してみたい。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;gitlab.com&#x2F;kyoheiu&#x2F;casa&quot;&gt;Kyohei Uto &#x2F; Casa · GitLab&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;今回は、ただジェネレーターを実装するだけでなく、若い言語Nimを触りながら何かを作ってみる、という狙いもあった。&lt;br &#x2F;&gt;
ちなみにNim製の静的サイトジェネレーターはすでに存在しているし、機能も今のところそちらのほうがずっと多い。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nazenimnanoka&quot;&gt;なぜNimなのか&lt;&#x2F;h3&gt;
&lt;p&gt;ジェネレーターを作るとして、言語の縛りはない。というかむしろ、自分の好きな言語／テンプレートエンジンでジェネレーターを実装する、というところが楽しいはずだ。&lt;br &#x2F;&gt;
最初に検討したのはHaskell。Pandocがあるということ、自分がある程度慣れた言語であるということ、Haskell製のジェネレーターHakyllは公式のテーマリストが長らく更新されていないこと、が理由だったのだが、これは厳しかった。最近触る機会がなかったというのもあるけれど、やっぱりHaskellは難しい。Haskellは好きだけど、今回はできればあまり血と涙と時間を費やしたくなかったので、他の言語を検討することに。&lt;&#x2F;p&gt;
&lt;p&gt;一方でなるべく新しい言語に触れたいという気持ちがあって最近ドキュメントを読んでいたのがJuliaとNimだったが、どちらかというとNimのほうが実行まわりで個人的に相性がよさそうだな…というくらいの感じで、Nimでジェネレーターを作ることに決めた。後述するがNimには言語付属のテンプレートエンジンがあり、これが実にサイトジェネレーター向けの仕様だった。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gou-cheng&quot;&gt;構成&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;.
├── casa
├── casa.nim
├── config.json
├── content
│   ├── 1
│   │   ├── 1.json
│   │   └── 1.md
│   ...
├── css
├── public
└── templates
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;全体のフローは非常にシンプルで、contentフォルダに対してforループをまわし、markdownファイルをパースしつつjsonで書いた各記事の設定ファイルを読み込んで、記事ページ、ランディングページおよびタクソノミーのテンプレートに必要な変数を渡す、という流れになる。&lt;&#x2F;p&gt;
&lt;p&gt;テンプレートについては、Nim付属のSource Code Filtersと呼ばれるテンプレートエンジンを使った。たとえば各記事ページのテンプレートを用意したい場合は、こうなる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;#? stdtmpl(subsChar = &amp;#x27;$&amp;#x27;, metaChar = &amp;#x27;#&amp;#x27;)
#proc generatePageHtml(siteTitle, siteUrl, pageContent, pageDate, pageTitle: string, pageCategories, pageTags: seq): string =
#  result = &amp;quot;&amp;quot;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;
      $pageTitle | $siteTitle
    &amp;lt;&amp;#x2F;title&amp;gt;

  &amp;lt;link rel=&amp;quot;shortcut icon&amp;quot; type=&amp;quot;image&amp;#x2F;png&amp;quot; href=&amp;quot;$siteUrl&amp;#x2F;static&amp;#x2F;image&amp;#x2F;icon.png&amp;quot;&amp;gt;
  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt;
  &amp;lt;link id=&amp;quot;style&amp;quot; rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text&amp;#x2F;css&amp;quot; href=&amp;quot;..&amp;#x2F;..&amp;#x2F;main.css&amp;quot;&amp;gt;
&amp;lt;&amp;#x2F;head&amp;gt;

&amp;lt;h2&amp;gt;
  $pageTitle
&amp;lt;&amp;#x2F;h2&amp;gt;

&amp;lt;div class=&amp;quot;date&amp;quot;&amp;gt;
  $pageDate
&amp;lt;&amp;#x2F;div&amp;gt;

#for category in items(pageCategories) :
  &amp;lt;a href=&amp;quot;$siteUrl&amp;#x2F;categories&amp;#x2F;$category&amp;quot;&amp;gt;&amp;#x2F;$category&amp;lt;&amp;#x2F;a&amp;gt;
#end for

#for tag in items(pageTags) :
  &amp;lt;a href=&amp;quot;$siteUrl&amp;#x2F;tags&amp;#x2F;$tag&amp;quot;&amp;gt;#$tag&amp;lt;&amp;#x2F;a&amp;gt;
#end for

&amp;lt;p&amp;gt;
  $pageContent
&amp;lt;&amp;#x2F;p&amp;gt;

&amp;lt;div class=&amp;quot;footer&amp;quot;&amp;gt;
  &amp;lt;a href=&amp;quot;$siteUrl&amp;quot;&amp;gt;$siteTitle&amp;lt;&amp;#x2F;a&amp;gt; | built in Nim
&amp;lt;&amp;#x2F;div&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;SCFのテンプレート内では、#を文頭につければNimのコードを動かせる。このMetaCharは自由に変更可能なので、#をテンプレート内の文頭で使いたいときは、たとえば+なり@なりを設定すればいい。ただし１行目の#?だけは変更不可なので注意して!!&lt;br &#x2F;&gt;
これにpage_base.nimfと名前をつけ（拡張子は自由だがコンベンションとして.nimfが推奨されている）、.nimファイル内でincludeした上で、テンプレート内の関数を呼び出す。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;import markdown, ...

include &amp;quot;templates&amp;#x2F;page_base.nimf&amp;quot;
...

let pageHtml   = generatePageHtml(siteTitle, siteUrl, pageContent,...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これでHTMLファイルとして生成できる。今の設定で生成できるpublicディレクトリの内容は以下の通り。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;.
├── categories # サンプルとして色名をカテゴリに
│   ├── blue
│   ...
│   └── yellow
├── content # 1から100までのサンプル記事
│   ├── 1
│   ...
│   └── 100
├── index.html
├── main.css
└── tags　# サンプルとして色名をタグに
    ├── blue
    ...
    └── yellow
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;ただしjinja2やTera Templateにおけるextendsのような拡張機能はまだ実装されていないので、各テンプレート毎に一から実装する必要がある、というのは難点といえば難点。headerやfooterをいじるとき、ちょっと面倒かも。&lt;br &#x2F;&gt;
また、設定ファイルをいじったとき、ビルドし直さないと反映されない。&lt;br &#x2F;&gt;
さらに、静的サイトジェネレーターというのはしばしば、サイト全体の設定ファイルに自前の変数を追加し、各テンプレートで使用する…ということをやるわけだが、このSCFを使う場合は、そもそもNimのコードから書き直して実装しなければならない。ここまでくると、お世辞にも手軽なテンプレートエンジンとは言えなさそう。その意味でも、HugoやZolaの拡張性の高さ・自由度は本当にすごいと思う。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pahuomansu&quot;&gt;パフォーマンス&lt;&#x2F;h3&gt;
&lt;p&gt;現在自分が使っているRust製ジェネレーターのZola、そして以前使っていたHugoと、自作ジェネレーターCasaのパフォーマンスを比較してみる。サンプルとして作成した100記事からなるサイトを生成するのにかかった時間は以下の通り。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Casa（リリースビルド）&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Casa(通常ビルド)&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Zola&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Hugo&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;0.220s&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;0.600s&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;0.094s&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;0.101s&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;ちなみに、ジェネレーターの草分け的存在・Jekyllは、 &lt;a href=&quot;https:&#x2F;&#x2F;forestry.io&#x2F;blog&#x2F;hugo-vs-jekyll-benchmark&#x2F;&quot;&gt;Hugo vs Jekyll: Benchmarked | Forestry.io&lt;&#x2F;a&gt; こちらの記事によると100記事で3〜4s程度。&lt;&#x2F;p&gt;
&lt;p&gt;ただし、サンプルに用いたファイルはわずかなmarkdownパースしか必要としない。複雑なmarkdownファイルを使うと、Zola&#x2F;Hugoへのビハインドはもっと大きくなる。&lt;&#x2F;p&gt;
&lt;p&gt;ちなみに最初はさらに遅かったので、設定ファイルの形式を変更した。元々はZolaにならってmarkdownのテキストデータと各記事のフロントマター（toml形式）を１つのファイルに同居させ、あとでsplitしてそれぞれを読み込む…ということをしていたのだが、このsplit周りのコードがかなり汚くて微妙だったのと、パフォーマンス的にこの辺で時間を食ってそう、という感じがあったので、割り切って本文のmarkdownファイルとjsonファイルは分けて作る形に切り替えた。これでビルド時間を半減。&lt;&#x2F;p&gt;
&lt;p&gt;markdownパーサはnim-markdownを使用。パフォーマンスのボトルネックがこのパーサなのでどうにかできるといいのだが、現状、Nimのパッケージライブラリにあるmarkdownパーサが実質的にはnim-markdownしかない。とりあえず高速化はここまで。&lt;br &#x2F;&gt;
とはいえ、当然markdownファイルのパース以外にも色々処理をしているわけなので、全体としてNimが確かに速いということは実感できた。正直ここまでとは思っていなかった。まだコードの内容も未熟だから、きっともっと速くできる。&lt;br &#x2F;&gt;
（ついでに言うと、やっぱりZolaはHugoよりもちょっとだけ速そうな気配）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nimza-gan&quot;&gt;Nim雑感&lt;&#x2F;h3&gt;
&lt;p&gt;以前小さなスクリプトを書いたときに「素直な言語」という手応えを得たが、今回ジェネレーターを実装したことで、ただ単に素直なだけではない、「実直でパワフルな言語」という認識に変わった。コードの書き心地がとてもシンプルで、書いたことがそのまま反映されるし、しかも速い。forループをぶん回しても涼しい顔をしている。ライブラリのさらなる充実に期待（どこかでmarkdownパーサを書いてみたい…）。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Parsing CSV file in Nim</title>
            <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/nim-csv-en/</link>
            <guid>https://kyoheiu.gitlab.io/post/nim-csv-en/</guid>
            <description>&lt;p&gt;As an exercise, I wrote a small program in Nim, the programming language that I&#x27;m learning these days.
Here, we use &lt;code&gt;parsecsv&lt;&#x2F;code&gt; library in standard lib.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nim&quot; class=&quot;language-nim &quot;&gt;&lt;code class=&quot;language-nim&quot; data-lang=&quot;nim&quot;&gt;import parsecsv

var p: CsvParser
p.open(&amp;quot;sample1.csv&amp;quot;)
p.readHeaderRow()
while p.readRow():
  echo &amp;quot;The average of &amp;quot;, p.row[0], &amp;quot; in &amp;quot;, 
    p.headers[2], &amp;quot; is &amp;quot;, p.row[1]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;readHeaderRow&lt;&#x2F;code&gt; is a function that gets the first row of csv and makes table (in order to access to elements of the first row, use &lt;code&gt;header[i]&lt;&#x2F;code&gt;.)
&lt;code&gt;readRow&lt;&#x2F;code&gt; sees whether we have next line or not, so we use this function in while expression to work on the entire csv.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;$ nim c -r csvparse.nim
[...]
The average of May in  &amp;quot;2005&amp;quot; is   0.1
The average of Jun in  &amp;quot;2005&amp;quot; is   0.5
The average of Jul in  &amp;quot;2005&amp;quot; is   0.7
The average of Aug in  &amp;quot;2005&amp;quot; is   2.3
The average of Sep in  &amp;quot;2005&amp;quot; is   3.5
The average of Oct in  &amp;quot;2005&amp;quot; is   2.0
The average of Nov in  &amp;quot;2005&amp;quot; is   0.5
The average of Dec in  &amp;quot;2005&amp;quot; is   0.0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;BTW, first exec time was 0.750s, second 0.013s, due to cache.&lt;&#x2F;p&gt;
&lt;p&gt;Nim shines when we want to build a small but need-to-be-efficient program in daily use, though of course it can be used for more complex applications.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>NimでCSVファイルをパースする</title>
            <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/nim-csv/</link>
            <guid>https://kyoheiu.gitlab.io/post/nim-csv/</guid>
            <description>&lt;p&gt;最近勉強中の言語Nimで、ちょっとした作業用にプログラムを書いてみた。
NimはPython風の文法で簡潔かつコンパクトに高速なプログラムを書ける言語。C &#x2F; C++ &#x2F; Objective-Cのコードにトランスパイルすることができ、Cのライブラリも使用することが可能。&lt;&#x2F;p&gt;
&lt;p&gt;今回触ったのはStandard Libaryのparsecsv。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;import parsecsv

var p: CsvParser
p.open(&amp;quot;sample1.csv&amp;quot;)
p.readHeaderRow()
while p.readRow():
  echo &amp;quot;The average of &amp;quot;, p.row[0], &amp;quot; in &amp;quot;, 
       p.headers[2], &amp;quot; is &amp;quot;, p.row[1]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;readHeaderRowはcsvの最初の行を読み込んでテーブルを作る関数。最初の行の要素にアクセスしたいときはheaders[i]を使う。
readRowは次の行があるかどうか判定してBoolを返してくれるので、whileの条件に使えばcsv全体に手続きを順に適用できる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[kyohei@myarch csvsample]$ nim c -r csvparse.nim
Hint: used config file &amp;#x27;&amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;.choosenim&amp;#x2F;toolchains&amp;#x2F;nim-1.4.2&amp;#x2F;config&amp;#x2F;nim.cfg&amp;#x27; [Conf]
Hint: used config file &amp;#x27;&amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;.choosenim&amp;#x2F;toolchains&amp;#x2F;nim-1.4.2&amp;#x2F;config&amp;#x2F;config.nims&amp;#x27; [Conf]
..............CC: stdlib_assertions.nim
CC: stdlib_io.nim
CC: stdlib_system.nim
CC: stdlib_streams.nim
CC: stdlib_lexbase.nim
CC: stdlib_parsecsv.nim
CC: csvparse.nim
Hint:  [Link]
Hint: 35986 lines; 0.750s; 48.977MiB peakmem; Debug build; proj: &amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;nim&amp;#x2F;csvsample&amp;#x2F;csvparse.nim; out: &amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;nim&amp;#x2F;csvsample&amp;#x2F;csvparse [SuccessX]
Hint: &amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;nim&amp;#x2F;csvsample&amp;#x2F;csvparse  [Exec]
The average of May in  &amp;quot;2005&amp;quot; is   0.1
The average of Jun in  &amp;quot;2005&amp;quot; is   0.5
The average of Jul in  &amp;quot;2005&amp;quot; is   0.7
The average of Aug in  &amp;quot;2005&amp;quot; is   2.3
The average of Sep in  &amp;quot;2005&amp;quot; is   3.5
The average of Oct in  &amp;quot;2005&amp;quot; is   2.0
The average of Nov in  &amp;quot;2005&amp;quot; is   0.5
The average of Dec in  &amp;quot;2005&amp;quot; is   0.0

[kyohei@myarch csvsample]$ nim c -r csvparse.nim
Hint: used config file &amp;#x27;&amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;.choosenim&amp;#x2F;toolchains&amp;#x2F;nim-1.4.2&amp;#x2F;config&amp;#x2F;nim.cfg&amp;#x27; [Conf]
Hint: used config file &amp;#x27;&amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;.choosenim&amp;#x2F;toolchains&amp;#x2F;nim-1.4.2&amp;#x2F;config&amp;#x2F;config.nims&amp;#x27; [Conf]
Hint: 7847 lines; 0.013s; 6.98MiB peakmem; Debug build; proj: &amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;nim&amp;#x2F;csvsample&amp;#x2F;csvparse.nim; out: &amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;nim&amp;#x2F;csvsample&amp;#x2F;csvparse [SuccessX]
Hint: &amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;nim&amp;#x2F;csvsample&amp;#x2F;csvparse  [Exec]
The average of May in  &amp;quot;2005&amp;quot; is   0.1
The average of Jun in  &amp;quot;2005&amp;quot; is   0.5
The average of Jul in  &amp;quot;2005&amp;quot; is   0.7
The average of Aug in  &amp;quot;2005&amp;quot; is   2.3
The average of Sep in  &amp;quot;2005&amp;quot; is   3.5
The average of Oct in  &amp;quot;2005&amp;quot; is   2.0
The average of Nov in  &amp;quot;2005&amp;quot; is   0.5
The average of Dec in  &amp;quot;2005&amp;quot; is   0.0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;１回めの実行は0.750sかかっているが、２回めは0.013sと短縮されている。&lt;&#x2F;p&gt;
&lt;p&gt;個人的なNimの使用感としては、わずらわしいこと抜きにさくっとシンプルなプログラムを書きたいときにとても良い感じ（もちろんもっと複雑なプログラムも書けるだろうけれど）。「今時の簡潔言語」の中では一番しっくりきてます。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>JuliaによるWebスクレイピング（簡易版）</title>
            <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/juliascraping/</link>
            <guid>https://kyoheiu.gitlab.io/post/juliascraping/</guid>
            <description>&lt;p&gt;Juliaで特定のWebページの更新日のみを取得するスクリプト。試し書きに近いのであしからず。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;using HTTP

url = &amp;quot;http:&amp;#x2F;&amp;#x2F;example.com&amp;quot;

function main()
   head = HTTP.head(url)
   lastmod = head.headers[6]
   println(lastmod)
end

@time main()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;julia&amp;gt; include(&amp;quot;scraping.jl&amp;quot;)
&amp;quot;Last-Modified&amp;quot; =&amp;gt; &amp;quot;Thu, 10 Dec 2020 00:53:40 GMT&amp;quot;
  2.787799 seconds (9.54 M allocations: 479.701 MiB, 6.53% gc time)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;関数定義部分はもうちょっとチェインっぽい感じでかっこよく書ける気もする。
使用するライブラリはHTTP.jlのみ。head.headersはarrayを返すので、[6]でarray中の要素を指定している（Juliaは1からカウント）。実際、head.headersと番号を指定せずにおくと&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;julia&quot; class=&quot;language-julia &quot;&gt;&lt;code class=&quot;language-julia&quot; data-lang=&quot;julia&quot;&gt;julia&amp;gt; head.headers
8-element Array{Pair{SubString{String},SubString{String}},1}:
           &amp;quot;Date&amp;quot; =&amp;gt; &amp;quot;Thu, 14 Jan 2021 20:35:31 GMT&amp;quot;
   &amp;quot;Content-Type&amp;quot; =&amp;gt; &amp;quot;text&amp;#x2F;html&amp;quot;
 &amp;quot;Content-Length&amp;quot; =&amp;gt; &amp;quot;9480&amp;quot;
     &amp;quot;Connection&amp;quot; =&amp;gt; &amp;quot;keep-alive&amp;quot;
         &amp;quot;Server&amp;quot; =&amp;gt; &amp;quot;Apache&amp;quot;
  &amp;quot;Last-Modified&amp;quot; =&amp;gt; &amp;quot;Thu, 10 Dec 2020 00:53:40 GMT&amp;quot;
  &amp;quot;Accept-Ranges&amp;quot; =&amp;gt; &amp;quot;none&amp;quot;
           &amp;quot;Vary&amp;quot; =&amp;gt; &amp;quot;Range,Accept-Encoding&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;となる。&lt;&#x2F;p&gt;
&lt;p&gt;取得したHTMLをさらにパースしてbodyやh1など特定のタグの内容を抽出したい場合はGumbo.jlを用いる。&lt;&#x2F;p&gt;
&lt;p&gt;恐ろしく簡潔だが、ちょっと時間がかかりすぎのような気もする。ただ他言語と比較して、ということをやるまでの気力はないので、ここまでにしておきます。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jlhuairunoshi-xing&quot;&gt;.jlファイルの実行&lt;&#x2F;h4&gt;
&lt;p&gt;ちょっと困ったのが.jlファイルの実行について。REPLモードでincludeして関数を叩く分には何の問題もないのだが、どちらかというとREPLモードに入らず直接ターミナルで実行ファイルを叩く形のほうが好みなので、方法がないか探した。
公式にはターミナルで.jlファイルのあるディレクトリにcdし、julia hoge.jlで実行可能だが、この際、.jlファイルはmoduleとしてではなく、上記のように&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;必要な関数定義&lt;&#x2F;li&gt;
&lt;li&gt;実行したいスクリプト&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;のみを記述する。ちなみにこの場合、REPLモードでも、上記のようにinclude(&amp;quot;hoge.jl&amp;quot;)のみで実行することはできる。
逆にmodule化してしまうと、julia hoge.jlでもinclude(&amp;quot;hoge.jl&amp;quot;)でもスクリプトが実行されることはない（REPLモードの場合は、スクリプト部分がシンタックスエラーと判定されてしまう）。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>静的サイトジェネレーターZolaへ移行する</title>
            <pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/zola-ssg/</link>
            <guid>https://kyoheiu.gitlab.io/post/zola-ssg/</guid>
            <description>&lt;h3 id=&quot;gai-yao&quot;&gt;概要&lt;&#x2F;h3&gt;
&lt;p&gt;以前はGo製のSSG(Static Site Generator)Hugoを使っていたのだけれど、色々考えた結果、Rust製SSGのZolaに乗り換えることに。そしていじっているうちに自分で納得いくまでやりたくなってしまい、テーマも作成してみました、という話です。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yi-xing-li-you&quot;&gt;移行理由&lt;&#x2F;h3&gt;
&lt;p&gt;HugoではAcademicという（おそらく）メジャーなthemeを使っていて、特に支障があったわけでもなかったのだけれど、気になるといえば気になっていたのが、「細かいところが気になったとき、すらすらと自分で書き直せるほどの理解を得ないまま使っている感じ」。ただしこれについては、デザインを自分で本格的にいじっていないために手になじんでいないだけかもしれない。&lt;&#x2F;p&gt;
&lt;p&gt;直接的な動機になったのは、各記事のカテゴリやタグを記事一覧でちゃんと表示してくれる、かつデザイン的に好みのthemeが見つからなかったことだったが、結果的には、Zolaに移行してテーマも自作したことで、とてもスッキリした。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zolanituitenoge-ren-de-pros-cons&quot;&gt;Zolaについての個人的pros&#x2F;cons&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;pros&quot;&gt;pros&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;zola buildが通ればだいたい大丈夫という安心感&lt;&#x2F;li&gt;
&lt;li&gt;しかも早い。Hugoよりも体感的にはちょっとだけ早い気がする。&lt;&#x2F;li&gt;
&lt;li&gt;buildエラー時のメッセージが丁寧かつ有用
&lt;ul&gt;
&lt;li&gt;Hugoでは何も考えずthemeを使っていたのでそもそもあまりエラーが出なかった印象だが、一から独自変数ありの.htmlを組んでいく中でこれはとても有難かった。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;zola checkがけっこう使える
&lt;ul&gt;
&lt;li&gt;内部及び外部リンクをチェックしてくれるコマンドで、リンクミス・リンク切れを教えてくれる。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;cons&quot;&gt;cons&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;手間がかかる
&lt;ul&gt;
&lt;li&gt;zola init時に勝手に各ページのサンプルを生成してくれればいいのにな…と、自作themeを作りながら何回か感じた。git cloneでthemeを入れた後、全体の構造を理解した上で.htmlをいじらないといけない局面があり、SSGに詳しくない人がいきなり手を出すのはややつらい気がする。最初のSSGとしてはHugoのほうがよさそう。&lt;&#x2F;li&gt;
&lt;li&gt;そして.htmlやconfig.tomlをいじっていく際、Tera Templateという独特のテンプレートエンジンを使う必要があり、学習コストが高いとまでは言わないけれど、お目当ての機能にたどり着くのにけっこう時間はかかるというのが実感。&lt;&#x2F;li&gt;
&lt;li&gt;慣れるとそこそこ扱いやすいこのTera Template、Rust用のエンジンということなので、Rustを普段書いている人にとっては学習しておくと一石二鳥…かどうかはよくわかりません。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;themeがまだまだ少なそう
&lt;ul&gt;
&lt;li&gt;公式で紹介されているのは2021年初頭時点で29。一方さすがのHugoは公式に載っているものだけでも300近くあるようなので、ここの差は人によっては大きいと思う。ただし、結局自分好みのサイトにしようとするなら、自分でいじらないといけない（いじることのできる）範囲が広いので、自力で全部書くのであれば関係ない。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;公式ドキュメントが若干わかりにくい
&lt;ul&gt;
&lt;li&gt;トータルで見ると必要なことは全部書いてあるのだが、知りたいことがどこに書いてあるのか直感的に掴みづらい。たとえば、使用できるシンタックスハイライトのテーマ一覧がSyntax HighlightingというページではなくConfigurationにある、など。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;hugo new post&#x2F;new.mdのような記事作成コマンドがない
&lt;ul&gt;
&lt;li&gt;人によっては若干不親切と感じられるかもしれない。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;総合して考えると個人的にはZolaのほうが馬が合う感じで好み。いちから自分の手でちまちま構築する（必要がある）雰囲気がArchと似ていて、「これについては自分が一番よく知っているし、何かあったら自分でなんとかできるはず」という感覚を得られる。これが個人的にはけっこう大事なポイントなので。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;getting-started&quot;&gt;Getting Started&lt;&#x2F;h3&gt;
&lt;p&gt;以下は、themeを使用しない場合の導入方法です。&lt;&#x2F;p&gt;
&lt;p&gt;基本的な仕組みは、公式のドキュメントのGetting Startedに。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;$ tree
.
├── config.toml
├── content
├── sass
├── static
├── templates
└── themes
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;さらにtemplatesの中身は以下。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[templates]$ tree
.
├── base.html
├── categories
│   ├── list.html
│   └── single.html
├── index.html
├── post.html
├── post-page.html
└── tags
    ├── list.html
    └── single.html
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;templatesに入っているこれらすべてのファイルと、親ディレクトリのconfig.tomlが必須要素。（タグ等の分類を使わなければtags及びcategoriesディレクトリは不要）。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;quan-ti-gou-zao&quot;&gt;全体構造&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;base.html すべてのページのテンプレート。head、header、footerなどはここに書く。&lt;&#x2F;li&gt;
&lt;li&gt;index.html いわゆるトップページの内容。&lt;&#x2F;li&gt;
&lt;li&gt;post.html, post-page.html それぞれ、記事一覧と各記事ページのテンプレートになる。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre&gt;&lt;code&gt;( base.html &amp;gt; index.html     ) + main.scss = example.com&amp;#x2F;index.html
( base.html &amp;gt; post.html      ) + main.scss = example.com&amp;#x2F;post
( base.html &amp;gt; post-page.html ) + main.scss + content&amp;#x2F;post&amp;#x2F;hoge.md   = example.com&amp;#x2F;post&amp;#x2F;hoge
( base.html &amp;gt; post-page.html ) + main.scss + content&amp;#x2F;hoge&amp;#x2F;index.md  = example.com&amp;#x2F;hoge
content&amp;#x2F;post&amp;#x2F;_index.md = content&amp;#x2F;post以下の記事群についてのメタデータ
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;このように、雛形の.htmlをベースにして（記事の場合は.mdファイルの各変数が代入され）そこに.scssから生成されるCSSファイルが適応されて最終的なhtmlが出力される、という流れになっている。この流れを可能にしているのがTera Template流の変数の仕組み。&lt;&#x2F;p&gt;
&lt;p&gt;content&#x2F;hoge&#x2F;index.mdとcontent&#x2F;hoge&#x2F;_index.mdの違いは、前者はexample.com&#x2F;hogeへアクセスしたときに表示されるページとしてレンダリングされるが、後者はcontent&#x2F;hoge以下の記事群についてのメタデータを記したファイルであるということ。&lt;&#x2F;p&gt;
&lt;p&gt;たとえばexample.com&#x2F;aboutに直接aboutページを載せたいときは、content&#x2F;about&#x2F;index.mdにその内容を書く。逆に、記事一覧など、content&#x2F;hoge以下の記事群に対応する変数はcontent&#x2F;hoge&#x2F;_index.mdに記載しておく。（この説明はちょっと怪しいけど…）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tips&quot;&gt;tips&lt;&#x2F;h3&gt;
&lt;p&gt;以上が分かればあとは自分好みに仕上げていくだけだが、個人的に詰まったところ・記録しておきたいところを書いておく。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hugo-academic-karanoyi-xing&quot;&gt;Hugo(Academic)からの移行&lt;&#x2F;h4&gt;
&lt;p&gt;Academicの.mdテンプレートはフロントマター（タイトルや投稿日などの記事のメタデータ）の区切りが+++でなく---になっているので、逐一変換する必要がある。記事数が多い場合は何らかのスクリプトを組まないと厳しい。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;sintatukusuhairaito&quot;&gt;シンタックスハイライト&lt;&#x2F;h4&gt;
&lt;p&gt;config.tomlに好みのテーマを書き、各.mdのコードブロック先頭に言語を明示することで適用される。対応しているテーマがまだ少ないので、こだわりのある人は先に公式をチェックしておきましょう。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;nei-bu-rinku&quot;&gt;内部リンク&lt;&#x2F;h4&gt;
&lt;p&gt;独特の内部リンク文法を使用しており、たとえば記事内で&#x2F;post&#x2F;hoge.mdにリンクを貼りたいときは@&#x2F;post&#x2F;hoge.mdとなる。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;taxonomies&quot;&gt;taxonomies&lt;&#x2F;h4&gt;
&lt;p&gt;Zolaにおけるタグやカテゴリなどのtaxonomiesは各記事のフロントマターに明示するだけではダメで、templatesにTAXONOMIES&#x2F;list.html, TAXONOMIES&#x2F;single.htmlという２種類のテンプレートを作る必要がある。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;scss&quot;&gt;scss&lt;&#x2F;h4&gt;
&lt;p&gt;cssのメタ言語だが、学習コストはかなり低いので触っておいて損はないと思う。といっても自分はscss独自の機能はほぼ使用していないけれど…。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;index-htmlnizhi-jie-ji-shi-yi-lan-wobiao-shi-suru&quot;&gt;index.htmlに直接記事一覧を表示する&lt;&#x2F;h4&gt;
&lt;p&gt;set_section関数を使用してpage.htmlを拾った上で、for構文を用いて表示する。&lt;&#x2F;p&gt;
&lt;p&gt;全記事でなく一部のみを表示したい場合はループカウントすることになるが、Tera Templateはloop.indexという特殊変数を用いてカウントするので注意。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;config-extra-variable&quot;&gt;config.extra.variable&lt;&#x2F;h4&gt;
&lt;p&gt;config.tomlの[extra]（自作の設定）でなるべく変数定義することでコードがクリーンになる気がする。ただし、.scss内で自作変数を使うことはできないっぽい。.scssでなく直接.cssを書いて置いておくのであれば使えそう。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;shu-shi&quot;&gt;数式&lt;&#x2F;h4&gt;
&lt;p&gt;数式の表示はMathJaxを使用した。関連する部分のコードを貼っておくので参考までに。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;html&quot; class=&quot;language-html &quot;&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;  {% if page.extra.math %}
  &amp;lt;script&amp;gt;
    MathJax = {
      tex: {
        inlineMath: [[&amp;#x27;$&amp;#x27;, &amp;#x27;$&amp;#x27;], [&amp;#x27;\\(&amp;#x27;, &amp;#x27;\\)&amp;#x27;]]
      }
    };
  &amp;lt;&amp;#x2F;script&amp;gt;
  &amp;lt;script type=&amp;quot;text&amp;#x2F;javascript&amp;quot; id=&amp;quot;MathJax-script&amp;quot; async
    src=&amp;quot;https:&amp;#x2F;&amp;#x2F;cdn.jsdelivr.net&amp;#x2F;npm&amp;#x2F;mathjax@3&amp;#x2F;es5&amp;#x2F;tex-chtml.js&amp;quot;&amp;gt;
  &amp;lt;&amp;#x2F;script&amp;gt;
  {% endif %}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;matomeruto&quot;&gt;まとめると&lt;&#x2F;h3&gt;
&lt;p&gt;わかってくると楽しい、そういうジェネレーターです。興味がある方はぜひ。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;theme&quot;&gt;theme&lt;&#x2F;h3&gt;
&lt;p&gt;自分で構築さえできれば、それそのものをテーマとして配布することができる。手順も簡単で、通常のサイトディレクトリにtheme.tomlを追加するだけ。&lt;&#x2F;p&gt;
&lt;p&gt;自分のサイトをテーマ化して独立させたものをGitLabに載せています。&lt;br &#x2F;&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;gitlab.com&#x2F;kyoheiu&#x2F;emily_zola_theme&quot;&gt;Kyohei Uto &#x2F; emily_zola_theme · GitLab&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Bret Easton Ellis &#x27;American Psycho&#x27;</title>
            <pubDate>Tue, 29 Dec 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/americanpsycho/</link>
            <guid>https://kyoheiu.gitlab.io/post/americanpsycho/</guid>
            <description>&lt;h3 id=&quot;xiao-shuo-ban&quot;&gt;小説版&lt;&#x2F;h3&gt;
&lt;p&gt;2020年のまだ寒くない時期は朝に読書の時間をある程度とることができ、ちまちま読んでいたがこれは素晴らしい作品だった。&lt;br &#x2F;&gt;
舞台はまだドナルド・トランプが「不動産王」として羨望と崇拝の対象だった頃のNY。冒頭から、ファッション、CDプレイヤーやビデオデッキ、美容グッズ、エステ、日焼けサロン、人気で予約のとれないレストラン、会員制ジムなど、身を飾り立てるアイテムや場所、ステータス・シンボルについて、ひたすら主人公Batemanは独りごち続ける。&lt;br &#x2F;&gt;
序盤を少し過ぎたあたりから、Batemanの「日常」の一部である殺人の描写が次第に増え、直接的なグロテスクさ（と、あらゆる意味での境界侵犯）を加速させていく。この連続殺人に代表されるBatemanのサイコパシーは作品のメインテーマのように読めるし、実際中盤以降は殺人の詳細なスケッチが大部を占めてはいるのだが、読みきった人ならわかるように、殺人と非共感性はこの作品の一部に過ぎない。というよりむしろ、殺人もグロテスク描写も、どちらかといえばBatemanにとり「身を飾るもの」なのであり、ファッションや最先端テクノロジー家電の列挙の延長線上に並べられるものと考えたほうがよい。実際彼は、被害者の体の一部を飾り、保存しているのだから。&lt;br &#x2F;&gt;
これらの行いを全体として批判的に解釈するのは容易いし、ひるがえって我々はどうかと論じることも多分できる。あるいは作中Batemanが手を染める殺人（多くはほとんど衝動的であり、同時にミソジニックでもある）を切り取って「悪」と糾弾することも、一応読者は許されている。&lt;br &#x2F;&gt;
しかしそれでも大きな疑問は残る。それは、終わりなく語り続け、並べ続けるBateman&#x2F;Ellisに対する「なぜここまで？」である。このクエスチョンへの返答として、Ellisは正当にも、何も書かない。ただ並べていく。並べていったものが次第に崩れ、溢れ、倒れていき、それでも並べていく。そしてもしかしたら、その中心には、何もない。だから読後に残るのは、嫌悪感や後味の悪さではない（中盤、グロテスク描写が極まるあたりはともかくとして）。むしろ、並べ続けなければならない彼の生、そして並べても並べても埋まらない、中心のvoidに何を感じるか、ということなのだ。あえて言葉でまとめれば、「おもしろうてやがてかなしき」とでも呼ぶべき感覚が、個人的には一番近いように思われる。&lt;br &#x2F;&gt;
さびしい小説だ。こんなに言葉を尽くして、何もないのだった。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ying-hua-ban&quot;&gt;映画版&lt;&#x2F;h3&gt;
&lt;p&gt;クリスチャン・ベールの怪演にファンも多いであろう映画版は2000年製作だが、装いや小道具などはあくまで原作に忠実に、80年代後半を再現している。大筋はだいたい原作通りと言っていい。今だったらこの原作に対して、ピーキーな才能を揃えて怪作を撮ろう、といった気運になる可能性もあるが、この映画版はその意味では控えめというか、何を求められているのか／何が可能か、についてきわめて自覚的だった。つまり、too muchから生まれる笑い、そして冷えた虚無感。これをどう描写するか、という点に集中している。&lt;br &#x2F;&gt;
徹底的に原作に忠実であろうとするならば、きっとトータルの時間は２時間ではおさまらず、アンゲロプロス作品並のボリュームが必要であっただろう。しかしそれは興行的にはまったく現実的ではないので、代わりにこの映画版は個々のエピソードのtoo much感をなるべく濃くし、印象を深く残すことに専念しているのだと思う。&lt;br &#x2F;&gt;
ビジネスカードのシーンや、私立探偵との会話のくだりなど、原作では際立った存在感があるわけでもない挿話が映画ではクローズアップされていることからもそれは明らかだし、秘書（クロエ・セヴィニー）がBatemanの手帳の中を覗き見てしまうシーンについても、あえて原作に存在しないエピソードを入れる賭けには十分勝っている。興行作品として可能な範囲でいかに忠実に原作を映像にしていくか、という古く難しい問題に、うまくアタックできている。&lt;br &#x2F;&gt;
ただし映像化に伴う一種の原理的な難しさがあったことも否定できない。一番それが感じられたのは朝のルーティーンを切り取った冒頭部分で、自分の部屋でBatemanが儀式めいた行為を重ねていくこのくだりは名シーンと言ってよいと思うが、それでも、そこで自らの心理状態を呟くBatemanを観て「一体彼は誰に話しているのか」と思わずにはいられないのだった。モノローグは独り言でなければならないし、対象がいないからこその原作の膨大な独りごちだったわけなのだが、それがナレーションと化した瞬間、Batemanが自分以外の他者を意識していることになり、受ける印象は180°変わってきてしまう。一応の解決策としては心中のつぶやきをナレーションとして乗せるのではなく、口に出して独り言として処理させる、という方法が考えられると思うが、冒頭に入れるシーンとしては逆に過剰かもしれない。ここはナレーションはなくてよかったように思う。&lt;br &#x2F;&gt;
もちろん、映像でこそのきらめきもいくつもあった。エンディングの処理はその最たるものだが、終盤のPaul Allen宅が変わり果ててしまった後のシーンも緊張感があってよかった。人格／キャラクターときわめて近い地点に各人の「家」があり、その家の「変貌」、あるいは裏切りがBatemanにとり決して軽くない意味を持っていたということが、これを見るとよくわかる。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Steamサーバー接続時トラブルを解決する（Arch Linux）</title>
            <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/steam-server-error/</link>
            <guid>https://kyoheiu.gitlab.io/post/steam-server-error/</guid>
            <description>&lt;h3 id=&quot;huan-jing&quot;&gt;環境&lt;&#x2F;h3&gt;
&lt;p&gt;OS: Arch Linux x86_64&lt;br &#x2F;&gt;
Kernel: 5.9.14-arch1-1&lt;br &#x2F;&gt;
Steamは&lt;code&gt;pacman&lt;&#x2F;code&gt;のパッケージを使用。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-ti&quot;&gt;問題&lt;&#x2F;h3&gt;
&lt;p&gt;前提として、「ブラウザなどのネットワーク接続は異常なし」。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;ある日突然、Steamで購入したはずのゲームをダウンロードできなくなる。（ダウンロードアイコンをクリックしてもダウンロードが始まらない／一瞬で停止する）&lt;&#x2F;li&gt;
&lt;li&gt;上記を解決するべくSteamを再インストールしてみたところ、今度はログインができなくなる。エラーメッセージは &lt;strong&gt;&amp;quot;Steam is having trouble connecting to the Steam servers&amp;quot;&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;yuan-yin&quot;&gt;原因&lt;&#x2F;h3&gt;
&lt;p&gt;僕の場合は、少し前にネットワークへの接続方法を&lt;code&gt;NetworkManager&lt;&#x2F;code&gt;から&lt;code&gt;systemd-networkd&lt;&#x2F;code&gt;に切り替えた際、DHCP接続の設定が抜けていたことが原因だった模様。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dui-ce&quot;&gt;対策&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;systemd-networkd&lt;&#x2F;code&gt;でWi-FiにDHCP接続する場合は、&lt;&#x2F;p&gt;
&lt;h4 id=&quot;1&quot;&gt;(1)&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;interface.network&lt;&#x2F;code&gt;に&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[Match]
Name=interface
[Network]
DHCP=yes
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;と書いておき、&lt;strong&gt;同時に&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;2&quot;&gt;(2)&lt;&#x2F;h4&gt;
&lt;p&gt;別途&lt;code&gt;dhcpcd&lt;&#x2F;code&gt;をインストールして&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# systemctl start dhcpcd.service
# systemctl enable dhcpcd.service
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;しておかなければならない。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;NetworkManager&lt;&#x2F;code&gt;を使っていた元々の設定では、このあたりはクリアーできていたようなのだが、&lt;code&gt;networkd&lt;&#x2F;code&gt;へ切り替えたタイミングでDHCPまわりが抜けた結果起こった問題と思われる。&lt;&#x2F;p&gt;
&lt;p&gt;しかし(2)が抜けた状態でも、ブラウザやターミナルでのインターネット接続は問題なく行えていたので、&lt;code&gt;dhcpcd&lt;&#x2F;code&gt;不在によるトラブルだということを突き止めるまで時間がかかってしまった。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;cf&quot;&gt;cf&lt;&#x2F;h3&gt;
&lt;p&gt;https:&#x2F;&#x2F;github.com&#x2F;ValveSoftware&#x2F;steam-for-linux&#x2F;issues&#x2F;2085
https:&#x2F;&#x2F;github.com&#x2F;ValveSoftware&#x2F;steam-for-linux&#x2F;issues&#x2F;4855&lt;&#x2F;p&gt;
&lt;p&gt;関連していそうなissue。「Steam以外はふつうにネット接続できている」というのがミソ。&lt;code&gt;networkd&lt;&#x2F;code&gt;以外を使っていても、同症状の場合は一度DHCP接続を確認してみるとよいかもしれない。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Google Assistantに話しかけた内容をメールで自分に送信する</title>
            <pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/memo-on-googlehome/</link>
            <guid>https://kyoheiu.gitlab.io/post/memo-on-googlehome/</guid>
            <description>&lt;p&gt;Google Assistantに話しかけると、スプレッドシートに入力され、さらに内容がメールで自分に送られてくる、という仕組みを作ったのでメモ。要するに音声メモ。&lt;&#x2F;p&gt;
&lt;p&gt;流れは以下の通り。&lt;br &#x2F;&gt;
Google Assistant -&amp;gt; [IFTTT] -&amp;gt; スプレッドシート -&amp;gt; [GAS] -&amp;gt; Gmail送信&lt;&#x2F;p&gt;
&lt;p&gt;最初はIFTTTでSlackへの直接投稿を狙っていたのだが、自宅のGoogle homeでは機能しなかった。スマートフォンのAssistantでは問題なかったので、homeの仕様かもしれないが、似た症例を見つけられず、結果的に送信部分はGAS、という今の形をとることに。IFTTTとGASに分ければ、Gmailでなく他の手段に切り替えたいときも比較的イージーに変更できそう、という点もメリット。&lt;&#x2F;p&gt;
&lt;p&gt;まず、IFTTT経由でのスプレッドシートへの入力について。&lt;br &#x2F;&gt;
THISは以下の通り。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;a.png&quot; alt=&quot;IFTTT_THIS&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;THATはこちら。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;b.png&quot; alt=&quot;IFTTT_THAT&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;日付の&lt;code&gt;CreatedAt&lt;&#x2F;code&gt;、text ingredientが代入される&lt;code&gt;TextField&lt;&#x2F;code&gt;に加えて、定形であるunsentを入力しておく。&lt;br &#x2F;&gt;
スプレットシートはこのようになる。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;c.png&quot; alt=&quot;IFTTT_THIS&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;このスプレッドシートからスクリプトエディタを起動。&lt;br &#x2F;&gt;
コードはこちら。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;htc&quot; class=&quot;language-htc &quot;&gt;&lt;code class=&quot;language-htc&quot; data-lang=&quot;htc&quot;&gt;var recipient = &amp;#x27;mailaddress&amp;#x27;;
var subject = &amp;#x27;memo from Google Assistant&amp;#x27;;
var sheet = SpreadsheetApp.getActiveSheet();
var last_row = sheet.getLastRow();

function main() {
  for(var i = 2; i &amp;lt;= last_row; i++){
    let isSent = sheet.getRange(i, 3);
    if(isSent.getValue() == &amp;#x27;unsent&amp;#x27;){
      var body = sheet.getRange(i, 2).getValue();
      GmailApp.sendEmail(recipient, subject, body);
      isSent.setValue(&amp;#x27;sent&amp;#x27;);
    }
  }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;GAS、というかJavaScriptを触ったことがほとんどないので変なところがありそうだが、今のところ動いている。&lt;&#x2F;p&gt;
&lt;p&gt;家事をしているときに忘れていた用事や入れておいたほうがいいtodoを思いつきがちなので、すぐにGoogle nest等に話しかけることでメモがとれるのはかなり使い勝手がいい。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Arch Linuxインストールメモ(2020)</title>
            <pubDate>Sun, 20 Sep 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/archinstall/</link>
            <guid>https://kyoheiu.gitlab.io/post/archinstall/</guid>
            <description>&lt;h1 id=&quot;2021-03-21-konomemohagu-ku-xian-xing-baziyondehashi-emasen-ji-lu-tositecan-siteimasu-archwikiwodu-mimasiyou&quot;&gt;(2021-03-21) このメモは古く、現行バージョンでは使えません。記録として残しています。ArchWikiを読みましょう。&lt;&#x2F;h1&gt;
&lt;p&gt;Arch Linuxインストールの覚書。将来の自分へのメモとして。&lt;&#x2F;p&gt;
&lt;p&gt;liveインストールの時点でどの程度パッケージを入れておくかは自由だが、インストール自体が初めての場合は&lt;code&gt;pacstrap&lt;&#x2F;code&gt;段階では基本パッケージ、エディタ、ネットワーク関係（これも選択肢は複数ある）くらいにとどめておき、後でX以下を入れていくほうが理解が進むのでいいと思う。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;insutoruhou-toraburunowei-ran-fang-zhi-ce&quot;&gt;インストール後トラブルの未然防止策&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;ネットワークに接続できない -&amp;gt; インストール時にネットワーク周りのパッケージを導入しておく。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;pacman&lt;&#x2F;code&gt;が見つからない -&amp;gt; インストール時に&lt;code&gt;base-devel&lt;&#x2F;code&gt;を入れておく。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;hazimeni&quot;&gt;はじめに&lt;&#x2F;h3&gt;
&lt;p&gt;UEFIモードでliveUSBを起動すること&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mazuwifijie-sok&quot;&gt;まずwifi接続&lt;&#x2F;h3&gt;
&lt;p&gt;wifi-menu&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pateisiyon&quot;&gt;パーティション&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;risutowoque-ren&quot;&gt;リストを確認&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;fdisk -l&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pateisiyonbureiku&quot;&gt;パーティションブレイク&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;sgdisk --zap-all &#x2F;dev&#x2F;nvme0n1&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pateisiyonfen-ge-kai-shi&quot;&gt;パーティション分割開始&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;gdisk &amp;#x2F;dev&amp;#x2F;nvme0n1
Command (? for help): o
This option deletes all partitions and creates a new protective MBR.
Proceed? (Y&amp;#x2F;N): y

Command (? for help): n
Partition number (1-128, default 1): default
First sector (34-xxxxxxxxx, default = xxxx) or {+-}size{KMGTP}: default
Last sector (xxxx-xxxxxxxxx, default = xxxxxxxxx) or {+-}size{KMGTP}: +500M
Hex code or GUID (L to show codes, Enter = 8300): ef00

Command (? for help): n
Partition number (2-128, default 2): default
First sector (34-xxxxxxxxx, default = xxxxxx) or {+-}size{KMGTP}: default
Last sector (xxxxxx-xxxxxxxxx, default = xxxxxxxxx) or {+-}size{KMGTP}: default
Hex code or GUID (L to show codes, Enter = 8300): default

Command (? for help): w

Do you want to proceed? (Y&amp;#x2F;N): y
OK: writing new GUID partition table (GPT) to &amp;#x2F;dev&amp;#x2F;nvme0n1
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;huomatuto&quot;&gt;フォーマット&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;mkfs.fat -F32 &amp;#x2F;dev&amp;#x2F;nvme0n1p1
mkfs.ext4 &amp;#x2F;dev&amp;#x2F;nvme0n1p2
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;maunto&quot;&gt;マウント&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;mount &amp;#x2F;dev&amp;#x2F;nvme0n1p2 &amp;#x2F;mnt
mkdir &amp;#x2F;mnt&amp;#x2F;boot
mount &amp;#x2F;dev&amp;#x2F;nvme0n1p1 &amp;#x2F;mnt&amp;#x2F;boot
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;mirarisutonobian-ji&quot;&gt;ミラーリストの編集&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;vi &#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-ji-he-wase&quot;&gt;時計合わせ&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;timedatectl set-ntp true&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;patukeziinsutorukai-shi&quot;&gt;パッケージインストール開始&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;ji-ben-patukezi&quot;&gt;基本パッケージ&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt base linux linux-firmware base-devel man-deb man-pages&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;netutowakuguan-xi&quot;&gt;ネットワーク関係&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt networkmanager nm-connection-editor network-manager-applet&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;tekisutoedeita&quot;&gt;テキストエディタ&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt nano vi nvim&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;desukutotupuhuan-jing-x&quot;&gt;デスクトップ環境（X）&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt  xorg-server xorg-apps xorg-xinit&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;desukutotupuhuan-jing-wm&quot;&gt;デスクトップ環境（WM）&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt i3&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;i3guan-lian&quot;&gt;i3関連&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt vifm feh picom rxvt-unicode rofi parcellite&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ri-ben-yu-zhou-ri&quot;&gt;日本語周り&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt fcitx fcitx-mozc fcitx-im fcitx-configtool&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;sonota&quot;&gt;その他&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt chromium xf86-video-intel lightdm lightdm-gtk-greeter&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fstabzuo-cheng&quot;&gt;Fstab作成&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;genfstab -U &#x2F;mnt &amp;gt;&amp;gt; &#x2F;mnt&#x2F;etc&#x2F;fstab&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chroot&quot;&gt;chroot&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;arch-chroot &#x2F;mnt&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;taimuzon&quot;&gt;タイムゾーン&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Tokyo &#x2F;etc&#x2F;localtime&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;adjtimesheng-cheng&quot;&gt;adjtime生成&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;hwclock --systohc&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;lang&quot;&gt;LANG&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;vi &amp;#x2F;etc&amp;#x2F;locale.gen
	en_US.UTF-8 UTF-8
	ja_JP.UTF-8 UTF-8

locale-gen
echo LANG=en_US.UTF-8 &amp;gt; &amp;#x2F;etc&amp;#x2F;locale.conf
export LANG=en_US.UTF-8
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;hosutonemu&quot;&gt;ホストネーム&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;echo hostname &amp;gt; &amp;#x2F;etc&amp;#x2F;hostname
vi &amp;#x2F;etc&amp;#x2F;hosts
127.0.0.1	localhost
::1		localhost
127.0.1.1	hostname.localdomain	hostname
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;rootpasuwado&quot;&gt;rootパスワード&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;passwd&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ripozitoriatupudeto&quot;&gt;リポジトリアップデート&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;pacman -Syy&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;maikurokodoatupudeto-insutoru&quot;&gt;マイクロコードアップデート　インストール&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;pacman -S intel-ucode&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;boot-loader&quot;&gt;boot-loader&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;pacman -S grub efibootmgr
mkdir &amp;#x2F;boot&amp;#x2F;efi
mount &amp;#x2F;dev&amp;#x2F;nvme0n1p1 &amp;#x2F;boot&amp;#x2F;efi
grub-install --target=x86_64-efi --bootloader-id=GRUB --efi-directory=&amp;#x2F;boot&amp;#x2F;efi
grub-mkconfig -o &amp;#x2F;boot&amp;#x2F;grub&amp;#x2F;grub.cfg
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zhong-liao-zai-qi-dong&quot;&gt;終了・再起動&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;exit
umount -R &amp;#x2F;mnt
shutdown now
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
        </item>
        <item>
            <title>systemdを使ってプログラムを定期実行する</title>
            <pubDate>Tue, 25 Aug 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/systemd-service/</link>
            <guid>https://kyoheiu.gitlab.io/post/systemd-service/</guid>
            <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;haskellscraping01&#x2F;&quot;&gt;HaskellによるWebスクレイピング&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;posttoslack&#x2F;&quot;&gt;HaskellでSlackに投稿する&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;systemdを使ってプログラムを定期実行する（この記事）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;linux上でプログラムを定期実行する手段は主に&lt;code&gt;cron&lt;&#x2F;code&gt;(とそのフォーク）と&lt;code&gt;systemd&lt;&#x2F;code&gt;を使うものの２種類あるが、今回は&lt;code&gt;systemd&lt;&#x2F;code&gt;を使ってみた。&lt;code&gt;cron&lt;&#x2F;code&gt;のフォークである&lt;code&gt;cronie&lt;&#x2F;code&gt;も試してみたのだが、&lt;code&gt;&#x2F;etc&#x2F;&lt;&#x2F;code&gt;以下にさしあたり必要でないディレクトリが作られたり、設定ファイルが個人的に扱いづらかったりであまり肌に合わなかった。&lt;br &#x2F;&gt;
&lt;code&gt;systemd&lt;&#x2F;code&gt;を使うメリットとしては、他のserviceと同様&lt;code&gt;systemd&lt;&#x2F;code&gt;管理下で一元的に扱え、動作状況などの&lt;code&gt;journal&lt;&#x2F;code&gt;も一覧で確認できること、依存関係を非常に簡単に設定できるので今回のようなネットワーク通信を前提とする実行ファイルの場合は特に取り回しが楽であること、あたりかと思う。デメリットは、ある程度込み入った定期実行設定をしたければ、.serviceとは別に.timerが必要であること。&lt;&#x2F;p&gt;
&lt;p&gt;実際の.serviceの内容は以下のようになる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;[Unit]
Description=scraping
Requires=network-online.target
After=network-online.target

[Service]
Type=simple
WorkingDirectory=&amp;#x2F;home&amp;#x2F;user&amp;#x2F;xxxx
ExecStart=&amp;#x2F;home&amp;#x2F;user&amp;#x2F;.local&amp;#x2F;bin&amp;#x2F;xxxx-exe

[Install]
WantedBy=multi-user.target
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;.service作成後、&lt;code&gt;# systemctl enable&lt;&#x2F;code&gt;で起動時実行をオンにしておけばOK。&lt;br &#x2F;&gt;
ネットワークがつながった後でないとスクレイピングに失敗するため、&lt;code&gt;[Unit]&lt;&#x2F;code&gt;の&lt;code&gt;Requires&lt;&#x2F;code&gt;と&lt;code&gt;After&lt;&#x2F;code&gt;は必須。逆に言うとここさえ押さえれば、システム起動 -&amp;gt; ネットワーク確立 -&amp;gt; 実行という流れを作れるので、実際にはこの依存関係の設定で実行時間をある程度コントロールできるとも言える。一日一回とりにいけば十分なので、今回は.timerは作成しなかった。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>HaskellでSlackに投稿する</title>
            <pubDate>Mon, 24 Aug 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/posttoslack/</link>
            <guid>https://kyoheiu.gitlab.io/post/posttoslack/</guid>
            <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;haskellscraping01&#x2F;&quot;&gt;HaskellによるWebスクレイピング&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;HaskellでSlackに投稿する（この記事）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;systemd-service&#x2F;&quot;&gt;systemdを使ってプログラムを定期実行する&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;scalpelで更新情報を抽出した後、保存されているテキストデータと異なっていた場合は、その旨をSlackへ通知を入れたい。
そのための関数は&lt;code&gt;Main.hs&lt;&#x2F;code&gt;とは別に&lt;code&gt;Lib.hs&lt;&#x2F;code&gt;へ保存する。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Lib.hs&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;{-# LANGUAGE OverloadedStrings #-}

module Lib where

import Network.Curl as NC

webhookurl :: URLString
webhookurl = &amp;quot;https:&amp;#x2F;&amp;#x2F;hooks.slack.com&amp;#x2F;services&amp;#x2F;xxxx&amp;#x2F;xxxxxxxxxxxxxxxxx&amp;quot;

message :: [String]
message = [&amp;quot;payload={\&amp;quot;text\&amp;quot;: \&amp;quot;UPDATE: Check http:&amp;#x2F;&amp;#x2F;example.com&amp;#x2F;\&amp;quot; }&amp;quot;]

sendUDMessage = curlPost webhookurl message
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;最初は&lt;code&gt;slack-api&lt;&#x2F;code&gt;あたりを使おうかと色々探っていたのだが、単にSlack内のチャンネルに投稿するだけであれば、Incoming Webhooksを使って投稿するのが一番手っ取り早い。&lt;&#x2F;p&gt;
&lt;p&gt;cf: &lt;a href=&quot;https:&#x2F;&#x2F;api.slack.com&#x2F;messaging&#x2F;webhooks&quot;&gt;Sending messages using Incoming Webhooks | Slack&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;コード内でWebhooksのURLが丸裸になるのが微妙だが、セキュリティ面を厳密に考慮する必要のない私的ミニプロジェクトなのでよしとする。&lt;br &#x2F;&gt;
Webhooksを叩くには、たとえばlinuxのターミナルからであれば&lt;code&gt;curl post&lt;&#x2F;code&gt;でいける。これをHaskellで実現するには、&lt;code&gt;Network.Curl&lt;&#x2F;code&gt;ライブラリの&lt;code&gt;curlPost&lt;&#x2F;code&gt;で十分。&lt;br &#x2F;&gt;
&lt;code&gt;message&lt;&#x2F;code&gt;の形式はSlackの仕様に合わせる必要があるが、投稿内容自体は件のWebサイトへのリンクがあれば事足りるので、全体として非常にシンプルにモジュールを作れた。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>HaskellによるWebスクレイピング</title>
            <pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/haskellscraping01/</link>
            <guid>https://kyoheiu.gitlab.io/post/haskellscraping01/</guid>
            <description>&lt;p&gt;RSSを吐かず、実際に訪れないと更新されたかどうか確認できないWebサイトの情報を追うために、ささやかだがスクレイピング・プロジェクトを作った。
流れとしてはこういう感じになる。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Haskell(&lt;code&gt;scalpel&lt;&#x2F;code&gt;)により、更新情報の通知エリアのみを抜き出す&lt;&#x2F;li&gt;
&lt;li&gt;抜き出してきた情報をローカルの&lt;code&gt;update.txt&lt;&#x2F;code&gt;の中身と比較し、同一であれば何もしない、異なっていればそれを&lt;code&gt;update.txt&lt;&#x2F;code&gt;に上書きした上でSlackのチャンネルへ通知（投稿）&lt;&#x2F;li&gt;
&lt;li&gt;このプログラムを、linux起動時にネットワークを確保した上で走るように&lt;code&gt;systemd&lt;&#x2F;code&gt;を使って.serviceを作成&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;この記事では(1)と(2)の&lt;code&gt;update.txt&lt;&#x2F;code&gt;の上書きまでをまとめる。続く部分は以下の記事に。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;HaskellによるWebスクレイピング（この記事）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;posttoslack&#x2F;&quot;&gt;HaskellでSlackに投稿する&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;systemd-service&#x2F;&quot;&gt;systemdを使ってプログラムを定期実行する&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;code&gt;Main.hs&lt;&#x2F;code&gt;は以下の通り。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;{-#LANGUAGE OverloadedStrings#-}

module Main where

import qualified Data.ByteString.Char8 as B
import Text.HTML.Scalpel
import Data.Maybe
import Lib

url :: URL
url = &amp;quot;http:&amp;#x2F;&amp;#x2F;example.com&amp;quot;

filePath :: FilePath
filePath = &amp;quot;update.txt&amp;quot;

data NewsText
    = NewsText { time :: B.ByteString
               , contents :: B.ByteString } deriving (Show,Read,Eq)

main = do
    new &amp;lt;- scrapeURL url information
    old &amp;lt;- B.readFile filePath
    let new2 = B.pack $ show $ fromJust new
    if new2 == old then print &amp;quot;no update.&amp;quot;
                   else do
                       Lib.sendUDMessage
                       B.writeFile filePath new2
    where
            information :: Scraper B.ByteString [NewsText]
            information = chroots (&amp;quot;div&amp;quot; @: [hasClass &amp;quot;information&amp;quot;]) newsTexts

            newsTexts :: Scraper B.ByteString NewsText
            newsTexts = do
                time &amp;lt;- text $ &amp;quot;dt&amp;quot;
                contents &amp;lt;- text $ &amp;quot;dd&amp;quot;
                return $ NewsText time contents
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;HaskellにおけるWebスクレイピング用のライブラリは他にいくつかあるようだけれど、&lt;code&gt;scalpel&lt;&#x2F;code&gt;は豊富な機能を持ち、たいていのことは可能という印象を受ける。今回の作業においてはオーバーキル気味かもしれないが、一回いじっておくとわりとすんなり他のケースに対しても応用できる、素直なライブラリのように感じた。&lt;br &#x2F;&gt;
&lt;code&gt;scalpel&lt;&#x2F;code&gt;を使う部分は初心者にも大して難しくなかった。&lt;code&gt;div&lt;&#x2F;code&gt;の&lt;code&gt;class&lt;&#x2F;code&gt;でまず絞り、さらにそこからタグで絞って抜き出す、という感じだ。きちんとやるならもっとエラーケースについて考えないといけないはずだが今回はパス。&lt;code&gt;scrapeURL&lt;&#x2F;code&gt;は&lt;code&gt;StringLike str =&amp;gt; URL -&amp;gt; Scraper str a -&amp;gt; IO (Maybe a)&lt;&#x2F;code&gt;となっているので、仮に該当するタグが消失していても&lt;code&gt;Nothing&lt;&#x2F;code&gt;が返ってくる。シンプルだが&lt;code&gt;Maybe&lt;&#x2F;code&gt;の威力を感じる部分。&lt;br &#x2F;&gt;
結局未解決なのは、抜き出してくるテキストに日本語が含まれている場合、&lt;code&gt;Data.Text&lt;&#x2F;code&gt;系を採用しても正確に日本語を拾えない点。これはこちらの文字列の拾い方が悪いのか、対象のWebサイトの仕様なのかよくわからない（要調査）。今回の狙いは更新の有無のみをテキストの「イコールorノットイコール」で判別し、通知する、というものなので、文字化けは許容範囲と判断した。&lt;br &#x2F;&gt;
その上で、&lt;code&gt;Data.Bytestring.Char8&lt;&#x2F;code&gt;を採用しているのは、&lt;code&gt;String&lt;&#x2F;code&gt;はパフォーマンス上一応避けておきたいというのと、過去のテキストと現在のテキストそれぞれを読み込む際のすり合わせのしやすさから。&lt;code&gt;now&lt;&#x2F;code&gt;と&lt;code&gt;old&lt;&#x2F;code&gt;の型が違っていると、内容が同じでも違うものと判断してしまうので、型をちゃんと見なくてはいけない。Visual Studio Codeのエクステンション&lt;code&gt;Haskell&lt;&#x2F;code&gt;に最近&lt;code&gt;haskell-ide-engine&lt;&#x2F;code&gt;が統合されたので、型チェックにはとても有用だった。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>ハン・ガン『回復する人間』</title>
            <pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/kaihuku/</link>
            <guid>https://kyoheiu.gitlab.io/post/kaihuku/</guid>
            <description>&lt;p&gt;2016年にアジア人初のブッカー賞を受賞（『菜食主義者』）した、という折り紙付きの韓国人作家。日本では近年の韓国文学ブームよりもやや先行して紹介されていたような印象があるが、いかんせん韓国人の名前表記に慣れていないのでこれといった前知識もないまま読了。非常に完成度が高く、それは原文と翻訳それぞれのレベルの高さから来ているものと推測する。&lt;&#x2F;p&gt;
&lt;p&gt;300p弱に７つの短・中編を収録。タイトルにもつながるイシュー「傷（と回復）」がどの作品にも通底しており、それぞれの登場人物に傷、そしてそこからの変化を見出すのは難しくない。といって、エンタメ的な自明さがあるかというと、異和感を覚えさせるような並列や突然の転換などもあちこちにちりばめられており、ははぁこれは文学だなという感想がまず出てくる。かつての勤め先の先輩を喪った女性、疎遠だった姉の死を受け止めきれない妹、もういない初恋の男性との時間を思って綴る手紙。それぞれは読み解いていけばかなりの程度分かりやすい関係性になっているが、少しずつ全体像が見えてくるような語りの構造と、美しいモノの描写によって、この小説集には独特の味わいが出ている。痛みと熱と少しの安らぎが喉におりてくるような、複雑な味わいの茶を大切に飲み下していくような。そうした、身体的に感じるとすら言えそうな、重い（けれど鈍重では全くない）文体で描かれた、絵画のような小説集だ。&lt;br &#x2F;&gt;
中でも白眉なのは邦題「火とかげ」とされた最後の中編で、これはトラウマの経験とそこから生じた重大な役割変化を、自分なりにどう生きていくか、という精神医療的なストーリーとしても読めるかもしれない。生から弾き出された主人公は、写真として具現化された過去を手さぐりで引き寄せながら、自分の中に感情と光と未来をもう一度、いちから作り直していく。他の短編にも少し出てきたが、過去と現在をいわばパッチしてつなぎ合わせ、元のものとは全く別の、けれどその人にとっては意味を持つ「二次元的な時間」として生を生き直すという考え方は、テッド・チャンの『あなたの人生の物語』の時間概念を思い出させる。過去は過去ではなく、現在という写真の隣に並ぶもう一枚の写真である。…そう思ったとき、それは喪われたものであると同時に、そこにあるものになる。この考え方に救われる人がどれだけいるだろうか。&lt;&#x2F;p&gt;
&lt;p&gt;韓国文学を読んでみようと思った経緯について記しておくと、直接的には『小説版 韓国・フェミニズム・日本』を読んだことがきっかけなのだが、このアンソロジーの出来がよかったから、というわけではない。少なくとも韓国人作家の作品は、結果的にはどれも面白く読めたが、どうも読みにくかったのだった（ちなみにハン・ガンの短編もこのアンソロジーに収録されているが、ほぼ人名の出てこない彼女の作品は、その意味でまず大変読みやすかったし、『回復する人間』を読んだ後だととりわけそのイシューの&amp;quot;らしさ&amp;quot;のようなものを味わえる）。まずこの読みにくさに少し驚いた。&lt;br &#x2F;&gt;
なぜ読みにくいのか考えてみたのだが、一つには、登場人物の性別が、名前からだけでは判断できない―ということが大きいように思う。英語でも日本語でもフランス語でも、大まかにキャラクターの性別というのは名前から判断できるものだが、韓国人を名前だけで男か女か判断するのは今の僕には不可能だ（そもそも名前で男女の区別をつけるような社会なのかということさえ分からない）。しかしこのアンソロジーに収録されている韓国人作家の作品はすべて、どのような切り口であれ「女性」をめぐるものだから、キャラクターの性別は読み進めていくのにほぼ不可欠な要素になってくる。山崎ナオコーラが別の雑誌に掲載されたエッセイで「性別のない小説を書きたい」と述べていたが、性別があるということが問題の前提なのであり、それを消す、あるいはなかったことにするのは、フェミニズムの文脈で言えば問題の解決にはならない（もしこの問題を何かの形で扱いたいと思うのであれば）。&lt;br &#x2F;&gt;
…ともかくそういうわけで、読み進んでいくのに（母語に翻訳されたものであるにもかかわらず）大変苦労したアンソロジーだったが、これはもしかすると翻訳の問題かもしれなかった。あるいは、韓国語から日本語への翻訳において発生する何かであるという可能性もあった。韓国語に少し興味が出てきた。それで、他の韓国文学を読んでみようと思ったのだが、そこで日本語で読むべきか、英語で読んだほうがよいのか、かなり迷った。結果的には、このハン・ガンの小説集はきわめて高いレベルの翻訳がされていた（少なくとも、読んでいてそうであろうと感じた）ので、日本語で読めてよかったのだが。&lt;&#x2F;p&gt;
&lt;p&gt;ちなみにこの話はもちろん、「読みにくい」ものに価値がないということではない。むしろその逆だ。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>ケーリーの定理の証明</title>
            <pubDate>Wed, 08 Jul 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/theoremcayley/</link>
            <guid>https://kyoheiu.gitlab.io/post/theoremcayley/</guid>
            <description>&lt;p&gt;Steve Awodey, &lt;em&gt;Category Theory&lt;&#x2F;em&gt;で圏論を少しずつ学習中。いきなりつまずいた表題の定理の証明についてまとめておく。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Theorem(Cayley). Every group G is isomorphic to a group of permutations.&lt;br &#x2F;&gt;
(p.13)&lt;br &#x2F;&gt;
群$G$は置換群の部分群と同型。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;単語の定義から。&lt;br &#x2F;&gt;
$X$を群とするとき、全単射写像$f: X \rightarrow X$を$X$の置換という。$X$の置換全体からなる群を$X$の置換群という。&lt;br &#x2F;&gt;
置換群とは、$cod(f)$を指すのではないことに注意。つまり定理の出発点になる群$G$とはレイヤーの異なるところに位置する群としてイメージすることで、定理の意味を把握しやすくなると思う。&lt;&#x2F;p&gt;
&lt;p&gt;定理の証明は以下の順序で行う。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;全単射写像$\bar{g}: G \rightarrow G$を定義する。&lt;&#x2F;li&gt;
&lt;li&gt;$i: G \rightarrow \bar{G}$が同型写像であること、つまり$G \cong \bar{G}$を示す。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;1-bar-g-g-rightarrow-g&quot;&gt;(1) $\bar{g}: G \rightarrow G$&lt;&#x2F;h3&gt;
&lt;p&gt;ある$g \in G$について、すべての$h \in G$に対し&lt;&#x2F;p&gt;
&lt;p&gt;$$\bar{g}(h) = g \cdot h$$&lt;&#x2F;p&gt;
&lt;p&gt;となる写像$\bar{g}$があるとする。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;dan-she-xing&quot;&gt;単射性&lt;&#x2F;h4&gt;
&lt;p&gt;$\bar{g}(a) = \bar{g}(b)$であれば、&lt;&#x2F;p&gt;
&lt;p&gt;$$g \cdot a = g \cdot b$$&lt;br &#x2F;&gt;
$$g^{-1} \cdot g \cdot a = g^{-1} \cdot g \cdot b$$&lt;&#x2F;p&gt;
&lt;p&gt;したがって$a = b$となる。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;quan-she-xing&quot;&gt;全射性&lt;&#x2F;h4&gt;
&lt;p&gt;$y \in G$について、$G$のある元$x$が存在して$\bar{g}(x) = y$となることを示す。&lt;br &#x2F;&gt;
$G$は群なので、&lt;&#x2F;p&gt;
&lt;p&gt;$$y = e \cdot y = g \cdot g^{-1} \cdot y = g \cdot (g^{-1} \cdot y)$$&lt;&#x2F;p&gt;
&lt;p&gt;したがって、$x = g^{-1} \cdot y$とおくと、$\bar{g}(x) = y$とおけ、$\bar{g}$は全単射。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;2-i-g-rightarrow-bar-g-to-j-bar-g-rightarrow-g&quot;&gt;(2) $i: G \rightarrow \bar{G}$と$j: \bar{G} \rightarrow G$&lt;&#x2F;h3&gt;
&lt;p&gt;各元$g \in G$について、$G$の置換への写像（つまり関数を呼び出す関数）$i$を&lt;&#x2F;p&gt;
&lt;p&gt;$$i: G \rightarrow \bar{G}$$&lt;br &#x2F;&gt;
$$i(g) = \bar{g}$$&lt;&#x2F;p&gt;
&lt;p&gt;とする。&lt;&#x2F;p&gt;
&lt;p&gt;また、各元$\bar{g} \in \bar{G}$について、ある元$x \in G$への写像$j$を&lt;&#x2F;p&gt;
&lt;p&gt;$$j: \bar{G} \rightarrow G$$&lt;br &#x2F;&gt;
$$j(\bar{g}) = \bar{g}(x)$$&lt;&#x2F;p&gt;
&lt;p&gt;とする。&lt;&#x2F;p&gt;
&lt;p&gt;ここで、iが同型写像であることを示すためには、$j$が群$X$の置換$\bar{g}$からその置換$\bar{g}$のもととなった$g \in G$への写像となるような$x$をとる必要がある。&lt;&#x2F;p&gt;
&lt;p&gt;$$\bar{g}(x) = g = g \cdot u$$&lt;&#x2F;p&gt;
&lt;p&gt;したがって求めるべき$x$は$x = u$となり、$j(\bar{g}) = \bar{g}(u)$と書ける。&lt;&#x2F;p&gt;
&lt;p&gt;実際、このとき&lt;&#x2F;p&gt;
&lt;p&gt;$$(i \circ j)(g) = j \circ (i(g)) = j(\bar{g}) = \bar{g}(u) = g \cdot u = g$$&lt;&#x2F;p&gt;
&lt;p&gt;また、&lt;&#x2F;p&gt;
&lt;p&gt;$$(j \circ i)(\bar{g}) = i(j(\bar{g})) = i(\bar{g}(u)) = i(g \cdot u) = i(g) = \bar{g}$$&lt;&#x2F;p&gt;
&lt;p&gt;より、$i$は同型写像。$\square$&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>リストモナドの非決定性／可能性について</title>
            <pubDate>Sun, 24 May 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/listmonad/</link>
            <guid>https://kyoheiu.gitlab.io/post/listmonad/</guid>
            <description>&lt;p&gt;勉強中、リストモナドの挙動が興味深かったので、ざっくり調べてみた結果をとりあえずまとめてみる。&lt;&#x2F;p&gt;
&lt;p&gt;リストは次のように実装される。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;Data List = Empty | cons a (List a)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;そして、&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;Prelude&amp;gt; zipWith (+) [1,2,3] [4,5,6]
[5,7,9]

Prelude&amp;gt; concatMap (\x -&amp;gt; [x, x^2]) [1,2,3]
[1,1,2,4,3,9]

Prelude&amp;gt; [1,2,3] ++ [4,5,6]
[1,2,3,4,5,6]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;まずはその中に入っているものはとにかく入っているのだという前提で学んでいく。&lt;br &#x2F;&gt;
こうしたリストの使い勝手の良さはHaskellのよいところの１つだと思うが、さらに面白いのは、実は&lt;code&gt;Fanctor, Applicative, Monad&lt;&#x2F;code&gt;各クラスのインスタンスであるという点。つまり、（&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B07SFCMP66&#x2F;&quot;&gt;入門Haskellプログラミング&lt;&#x2F;a&gt;の表現をまず借りると）上記したような「コンテナとしてのリスト」という側面と別に、「コンテクストとしてのリスト」が存在している。&lt;&#x2F;p&gt;
&lt;p&gt;「コンテクストとしてのリスト」、つまりモナドリストは、たとえば次のような使い方をされる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;Prelude&amp;gt; (+) &amp;lt;$&amp;gt; [1,2,3] &amp;lt;*&amp;gt; [4,5,6]
[5,6,7,6,7,8,7,8,9]

Prelude&amp;gt; (++) &amp;lt;$&amp;gt; [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;] &amp;lt;*&amp;gt; [&amp;quot;cat&amp;quot;,&amp;quot;dog&amp;quot;] 
[&amp;quot;white cat&amp;quot;,&amp;quot;white dog&amp;quot;,&amp;quot;black cat&amp;quot;,&amp;quot;black dog&amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Will Kurtによると、モナドとしてのリストを理解するには「非決定論的な計算」という考え方をするのが最善だという。&lt;code&gt;&amp;lt;*&amp;gt;&lt;&#x2F;code&gt;でつながれたそれぞれのリストは「そのうちのどれであるかが決定されていない」ものであり、計算結果はありうる結果すべてを表現している…。&lt;br &#x2F;&gt;
プログラミングの世界で非決定論的、なんていう言葉を目にするとは思っていなかっただけに、これには驚かされた。&lt;&#x2F;p&gt;
&lt;p&gt;コンテクストという言葉は、おそらく厳密に言えば圏論をしっかり理解しないと腑に落ちないワードだと思う（圏論を理解していないので断言もできない）のだが、Haskellでのモナドを頭に入れるだけであれば次のように考えるとよさそうだ。&lt;&#x2F;p&gt;
&lt;p&gt;コンテナとコンテクスト、という二種類のデータのあり方は、pure function 純粋関数とunpure function 非純粋関数にそれぞれ対応している。&lt;br &#x2F;&gt;
関数が純粋であるとはこの場合、side effectを持たず、その関数にある引数を与えたとき、必ず同じ返り値が出てくる、という意味だ。これは、関数の役割が、ただその関数の定義と引数のみから完全に表現できる、ということでもある。&lt;br &#x2F;&gt;
それは数学の純粋性にどこか似ている。定義、命題、そういったクリアーなモジュールとして在るのが純粋関数、そういう風に考える。&lt;br &#x2F;&gt;
では非純粋とはなにかといえば、「それ自体」以外の役割、something elseを持つかもしれないもの、ということになる。関数と引数が持つデータ以外に何かを引き連れていたり、何かを生んだり、何かを表示したり…といった、つまりside effectを持つかもしれないものが非純粋関数だ。これを扱うために&lt;code&gt;Fanctor, Applicative, Monad&lt;&#x2F;code&gt;という考え方がある。&lt;&#x2F;p&gt;
&lt;p&gt;次に、純粋なものとしてのリストと、非純粋なものとしてのリスト、それぞれをコンテナ／コンテクストとして呼ぶ「意味」は何か、ということを考える。どちらも、ある種の比喩を含む表現だと思う。この比喩が面白いと思うのだが、まずコンテナのほうは「箱」だ。しかもフタが空いていて、何かを追加したり取り出したりするのは自由だが、とにかく中にはこれこれが入っているということが「確定している」。だから計算結果にはゆらぎがない（ように見える）。&lt;br &#x2F;&gt;
一方、コンテクストとは、「何かを理解するために役立つ、状況や事象、情報」のことである。つまり、その何かというのは、コンテクスト(=something else)なしでは完全には意味をとれない。意味が決定されていない。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;Prelude&amp;gt; (++) &amp;lt;$&amp;gt; [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;] &amp;lt;*&amp;gt; [&amp;quot;cat&amp;quot;,&amp;quot;dog&amp;quot;] 
[&amp;quot;white cat&amp;quot;,&amp;quot;white dog&amp;quot;,&amp;quot;black cat&amp;quot;,&amp;quot;black dog&amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上の式は、白か黒かが決定されておらず、犬か猫かも決定されていない、というように読むこともできる。結果は、すべてのあり得る可能性を拾い尽くしたものになる。&lt;&#x2F;p&gt;
&lt;p&gt;もちろんこれは、あえて文学的に表現すれば…ということで、実際にはこの式は&lt;code&gt;do&lt;&#x2F;code&gt;構文を用いると次のようになる。&lt;br &#x2F;&gt;
（参考: &lt;a href=&quot;https:&#x2F;&#x2F;kazu-yamamoto.hatenablog.jp&#x2F;entry&#x2F;20090313&#x2F;1236935179&quot;&gt;リストモナドの動作原理を考える - あどけない話&lt;&#x2F;a&gt;）&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;sample = do
    x &amp;lt;- [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;]
    y &amp;lt;- [&amp;quot;cat&amp;quot;,&amp;quot;dog&amp;quot;]
    return (x ++ y)

*Main&amp;gt; sample
[&amp;quot;white cat&amp;quot;,&amp;quot;white dog&amp;quot;,&amp;quot;black cat&amp;quot;,&amp;quot;black dog&amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上の&lt;code&gt;sample&lt;&#x2F;code&gt;関数を脱糖するとこうなる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;sample = [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;] &amp;gt;&amp;gt;= \x -&amp;gt; [&amp;quot;cat&amp;quot;,&amp;quot;dog&amp;quot;] &amp;gt;&amp;gt;= \y -&amp;gt; return (x ++ y)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;リストモナドにおいて、&lt;code&gt;return&lt;&#x2F;code&gt;と&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;はそれぞれ&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;return x = [x]
l &amp;gt;&amp;gt;= f = concatMap f l
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;このように定義されているから、&lt;code&gt;sample&lt;&#x2F;code&gt;関数はさらに&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;sample = concatMap (\x -&amp;gt; [&amp;quot;cat&amp;quot;,&amp;quot;dog&amp;quot;] &amp;gt;&amp;gt;= \y -&amp;gt; [x ++ y]) [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;]
       = concatMap (\x -&amp;gt; concatMap (\y -&amp;gt; [x ++ y]) [&amp;quot;cat&amp;quot;,&amp;quot;dog&amp;quot;]) [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;と変形できる。&lt;br &#x2F;&gt;
これを内側、外側の順に計算すると、&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;sample = concatMap (\x -&amp;gt; [x ++ &amp;quot;cat&amp;quot;, x ++ &amp;quot;dog&amp;quot;]) [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;]
       = [&amp;quot;white cat&amp;quot;,&amp;quot;white dog&amp;quot;,&amp;quot;black cat&amp;quot;,&amp;quot;black dog&amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;リストモナドの計算に非決定性／すべてのありうる可能性…といったsomething elseが現れる根拠は、この式変換でいうと&lt;code&gt;concatMap&lt;&#x2F;code&gt;の存在だろう。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;:t concatMap
concatMap :: Foldable t =&amp;gt; (a -&amp;gt; [b]) -&amp;gt; t a -&amp;gt; [b]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;ところで、&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;の型は&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;:t (&amp;gt;&amp;gt;=)
(&amp;gt;&amp;gt;=) :: Monad m =&amp;gt; m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;こうなっている。&lt;br &#x2F;&gt;
&lt;code&gt;concatMap&lt;&#x2F;code&gt;とは引数の順番が違うが、&lt;code&gt;flip&lt;&#x2F;code&gt;を使ってもよいと考えると&lt;code&gt;concatMap&lt;&#x2F;code&gt;のほうはこうなる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;:t flip concatMap
flip concatMap :: Foldable t =&amp;gt; t a -&amp;gt; (a -&amp;gt; [b]) -&amp;gt; [b]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これを&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;と見比べてみると、&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;の&lt;code&gt;m a&#x2F;m b&lt;&#x2F;code&gt;がconcatMapでは&lt;code&gt;t a&#x2F;[b]&lt;&#x2F;code&gt;になっているだけで、構造としては同じだ。「モナドな何かについて、モナドでない何かをとってモナドな何かを返す関数を適用することで、モナドな何かを返す」…これが&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;だとすれば、「&lt;code&gt;Foldable&lt;&#x2F;code&gt;な何かについて、リストでない何かをとってリストを返す関数を適用することで、リストを返す」ものが&lt;code&gt;concatMap&lt;&#x2F;code&gt;だというわけだ。一般論としての&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;と&lt;code&gt;concatMap&lt;&#x2F;code&gt;の関連性（正確ではないかもしれないが、抽象／具体の関係と呼んでみる）が、こう表現すると明らかになってくる。つまり、要素をリストに入れ、リストを返すという「リスト化」が、&lt;code&gt;&amp;lt;*&amp;gt;&lt;&#x2F;code&gt;でつながれたそれぞれの引数について不足なく行われる結果、可能性全体を表現するかのようなリストが生成される、というふうに考えることができる。&lt;&#x2F;p&gt;
&lt;p&gt;ここで文学的な解釈にあえて戻ってみると、結局、非決定性／可能性とは全体性なのだ、ということができるような気がする。こぼさずすべてを取り尽くすことが非決定性／可能性を生む。逆に言えば、その一部をとらないーすくわず、捨て去るたび毎に、それは凝固し、決定的になっていく。同時に、可能性がなくなり、固定されていく。こんな風に言い換えることもできるかもしれない。決まっていないことは可能性であり、決めることはゆらぎがなくなっていくことだと。当たり前といえば当たり前なのだが、あまりにも豊かすぎる表現のように感じられる。モナドという概念は、やっぱり面白い。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>千葉雅也『デッドライン』</title>
            <pubDate>Sat, 16 May 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/deadline/</link>
            <guid>https://kyoheiu.gitlab.io/post/deadline/</guid>
            <description>&lt;p&gt;主人公が師事することになる徳永先生というキャラクターについて、この人は自分が大学でわずかに教わったことのあるあの人に似ているなぁ…と思っていたら、どうも本当にその人をモデルにして書いたらしいことが参考文献からわかった。僕がとった授業では戦前日本における儒教について書かれたテキストを扱っていたが、内容はあまり覚えていない。これはこの国の現代史にとって何かただならぬ重要な伏線なんじゃないか、という漠然とした面白みのようなものは感じられたけれど。&lt;&#x2F;p&gt;
&lt;p&gt;主人公は師に自然と近づいていき、師のもとで思考と格闘し続ける。全編にわたり、「知／哲学」というものへの信頼が、主人公の中にはある。たまにすべてを相対化するような発言もする主人公だが、にもかかわらず哲学には強めに価値をおいている。研究そのものの価値には異議申し立てをしない。2020年のこの国のアカデミックな場に漂っているかもしれない種類の徒労感や絶望感は、2001年の彼自身の中にはほぼ存在しない。それはとりあえず時代と、彼の才能のおかげかもしれないが、他の登場人物にもやはり陰はほとんどない。彼らは恐れや不安、装い、そういったパーソナルな「秘密」を隠すことなく、自分に言い聞かせるかのように読み手に打ち明けてくれる。そして透明な水槽の中をぐるぐると回りながら、上を見ている。小説全体が透き通っていて（それは美的であるということとはまたちょっと違うが）、恥ずかしがりながらも親密な感じを漂わせていて、まっすぐだ。つまり、ひとことで言えば大変素直な小説なのだ。&lt;br &#x2F;&gt;
逆に言うとひねりはほとんどない。動物になること／女性になること、というポストモダンっぽい修論のテーマは至るところで顔を出す（「動物」というキーワード自体がポストモダン哲学の常連ではある）し、ここで興味を持った読み手に、気になるならこちらへ、と手招きする程度の余白はあるけれど、それ以上でも以下でもない。少し気圧されてしまうほどに、まっすぐで真面目。&lt;&#x2F;p&gt;
&lt;p&gt;この小説と比較するべきものがあるとしたら『三四郎』だと思う。何かに惹かれ、自問し、自意識と欲望の間でもがき、その何かは結局主人公の手をすべり抜けていく。異なるのは、三四郎は「成功」のまわりでぐるぐると回っていたが、『デッドライン』の彼は哲学のまわりをぐるぐる回遊しているという点だけだ。三四郎にとっての成功が、彼にとっての哲学なのだ。それくらい真面目に、素直に書かれているから、新鮮で、面白いと感じる。そういう小説だ。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>フィボナッチ数列（memoization）</title>
            <pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/memofib/</link>
            <guid>https://kyoheiu.gitlab.io/post/memofib/</guid>
            <description>&lt;h2 id=&quot;memoization&quot;&gt;memoization(?)&lt;&#x2F;h2&gt;
&lt;p&gt;次に、memoizationによるフィボナッチ数列関数の作成にトライしてみる。&lt;br &#x2F;&gt;
memoizationとは日本語だとメモ化とも呼ばれるプログラミングの手法で、「一度計算したものを記録しておき、必要なときに取り出すようにする」効率化のこと、らしい。&lt;&#x2F;p&gt;
&lt;p&gt;前回のslowFibが遅い理由は、一度計算してしまえばそのあと再利用できる項を愚直に展開して項数を増やしているからだ。これを解決するのに、memoizationの発想は有用ではないだろうか、というわけ。&lt;br &#x2F;&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Memoization&quot;&gt;wiki.haskell.org&lt;&#x2F;a&gt;を参考に、memoizationを実装してみる。リストに計算結果を記録しておき、都度それを取り出す、というものだ。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;memoFib1 = (map fib [0..] !!)
            where
                fib 0 = 1
                fib 1 = 1
                fib n = memoFib1 (n-1) + memoFib1 (n-2)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;*Main&amp;gt; memoFib1 30
1346269
(0.01 secs, 120,256 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これは確かに速い。&lt;br &#x2F;&gt;
ところが、次のように少しだけ変形をすると、結果は全く異なるものになる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;memoFib2 n = (map fib [0..]) !! n
            where
                fib 0 = 1
                fib 1 = 1
                fib n = memoFib2 (n-1) + memoFib2 (n-2)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;*Main&amp;gt; memoFib2 30
1346269
(1.46 secs, 2,312,682,608 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;実は最初自分なりに実装したのが&lt;code&gt;memoFib2&lt;&#x2F;code&gt;のほうだったので、だいぶ混乱した。なぜこのような違いが出るのか理解ができなければ、他のケースでmemoizationを使っていくことができない。&lt;br &#x2F;&gt;
どうしてもわからなかったので、r&#x2F;Haskellで質問してみたら、あっさり&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;comments&#x2F;a3va9p&#x2F;why_pointfree_makes_difference_to_this_simple&#x2F;&quot;&gt;過去ログの回答&lt;&#x2F;a&gt;をもらえた。感謝。&lt;br &#x2F;&gt;
以下、まずこの回答について。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ramudaji-suan-biao-xian-niyorubian-xing&quot;&gt;ラムダ計算表現による変形（？）&lt;&#x2F;h2&gt;
&lt;p&gt;上記の回答によると、それぞれの&lt;code&gt;memoFibx&lt;&#x2F;code&gt;はラムダ計算表現を用いて次のように変形できる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;memoFib1 = let fibList = map fib [0..] in (fibList !!)
&amp;lt;-&amp;gt; memoFib1 = let fibList = map fib [0..] in \n -&amp;gt; fibList !! n

memoFib2 n = let fibList = map fib [0..] in fibList !! n
&amp;lt;-&amp;gt; memoFib2 n = \n -&amp;gt; let fibList = map fib [0..] in fibList !! n
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;したがって、結局&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;(memoFib1) let fibList = map fib [0..] in \n -&amp;gt; fibList !! n
(memoFib2) \n -&amp;gt; let fibList = map fib [0..] in fibList !! n
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;この２つの式の差はなにか、ということになる。&lt;br &#x2F;&gt;
&lt;code&gt;Fib1&lt;&#x2F;code&gt;では&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;が一度だけ計算されるが、Fib2では[0..n]までその都度計算されてしまう。これが上記回答の趣旨だった。&lt;&#x2F;p&gt;
&lt;p&gt;しかしこれがよく分からない。&lt;code&gt;Fib2&lt;&#x2F;code&gt;でnが２回出てきているあたりが怪しいようにも思うが、そもそも最初の関数定義に&lt;code&gt;fibList&lt;&#x2F;code&gt;が登場していないので、いまいち腑に落ちない感じがある。もちろん、ラムダ計算表現に慣れていないから飲み込みづらいということも否定できない。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;guan-shu-ben-ti-towherejie-noguan-xi-karakao-ezhi-su&quot;&gt;関数本体とwhere節の関係から考え直す&lt;&#x2F;h2&gt;
&lt;p&gt;そこで、最初の&lt;code&gt;memoFib2&lt;&#x2F;code&gt;を、次のように&lt;code&gt;where&lt;&#x2F;code&gt;節を用いて表現し直してみる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;memoFib3 n = fibList !! n
    where
        fibList = map fib [0..] 
        fib 0 = 1
        fib 1 = 1
        fib n = (fibList !! (n-1)) + (fibList !! (n-2))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;*Main&amp;gt; memoFib3 30
1346269
(0.01 secs, 121,112 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;redditの回答にヒントを得て、&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;を１行目から外し、実質の中身をすべて&lt;code&gt;where&lt;&#x2F;code&gt;節内でまとめようとしたものだ。この&lt;code&gt;memoFib3&lt;&#x2F;code&gt;は問題なく計算を行える。&lt;br &#x2F;&gt;
これを、次の関数定義と見比べると、何が問題なのかが見えてくるように思う。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;memoFib4 n = (map fib [0..]) !! n
    where
        fib 0 = 1
        fib 1 = 1
        fib n = (map fib [0..] !! (n-1)) + (map fib [0..] !! (n-2))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;*Main&amp;gt; memoFib4 30
1346269
(1.31 secs, 2,075,739,480 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Fib3では、&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;が一度だけ計算され、&lt;code&gt;fibList&lt;&#x2F;code&gt;に保存される。&lt;code&gt;fib n&lt;&#x2F;code&gt;も&lt;code&gt;memoFib3&lt;&#x2F;code&gt;も、この&lt;code&gt;fibList&lt;&#x2F;code&gt;から値をとってきているので、計算が速くなる。&lt;br &#x2F;&gt;
一方、&lt;code&gt;Fib4&lt;&#x2F;code&gt;は&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;が３回登場している。これはその都度&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;を計算しているということだから、遅い。&lt;&#x2F;p&gt;
&lt;p&gt;これを踏まえて元の定義をもう一度見てみると、話は実は非常に単純で、最初の&lt;code&gt;Fib2&lt;&#x2F;code&gt;では、&lt;code&gt;fib&lt;&#x2F;code&gt;は&lt;code&gt;memoFib2&lt;&#x2F;code&gt;に、そして&lt;code&gt;memoFib2&lt;&#x2F;code&gt;は&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;に結びついている。したがって&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;が最低限以上の回数計算されている。一方、&lt;code&gt;memoFib1&lt;&#x2F;code&gt;がポイントフリーで表現されているということは、&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;は最終的に必要になった段階でようやく評価される、ということを実質的に意味している。このポイントフリーと遅延評価の関係を意識できていないと、大変混乱する羽目になる、というわけだった。&lt;br &#x2F;&gt;
適当に人のコードを写経すると理解不足なところが出てくる、という教訓。&lt;&#x2F;p&gt;
&lt;p&gt;ところでmemoizationに話を戻すと、この場合、&lt;code&gt;fibList = map fib [0..]&lt;&#x2F;code&gt; がその役割を担っている。&lt;code&gt;slowfib&lt;&#x2F;code&gt;からスタートしてみると、&lt;code&gt;map f xs&lt;&#x2F;code&gt;で計算結果を記録していくmemoizationのやり方はとても自然に感じられる。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>フィボナッチ数列（Haskellタプリング法）</title>
            <pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/tuplingfib/</link>
            <guid>https://kyoheiu.gitlab.io/post/tuplingfib/</guid>
            <description>&lt;h2 id=&quot;naive-fib&quot;&gt;naive fib&lt;&#x2F;h2&gt;
&lt;p&gt;まずnaiveな定義から。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;slowFib 0 = 1
slowFib 1 = 1
slowFib n = slowFib (n-1) + slowFib (n-2)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;*Main&amp;gt; slowFib 30
1346269
(1.54 secs, 929,853,032 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;n=30くらいまではなんとか耐えられるが、びっくりするくらい遅い。&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B004VB3V0K&#x2F;&quot;&gt;Learn You a Haskell for Great Good&lt;&#x2F;a&gt;に特に注釈無しで記載されているので、学習中の人は一度は試してみたことがあると思う。Haskellってもしかして遅いのかな？ と学習者を不安にさせる遅さだ。&lt;br &#x2F;&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;4048930532&#x2F;&quot;&gt;Haskellによる関数プログラミングの思考法&lt;&#x2F;a&gt;によると、この関数の計算量はO(Φ^n)（Φ=(1+√5)&#x2F;2, 黄金律）なので、指数オーダーで計算量が増えていくことになるが、黄金律と言われてもあまりピンとこないのでもう少しこねてみる。&lt;br &#x2F;&gt;
計算を分解してみると、たぶん次のようになるはずだ。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;slowFib n
= slowFib (n-1) + slowFib (n-2)
= (slowFib (n-2) + slowFib (n-3)) + (slowFib (n-3) + slowFib (n-4))
= (slowFib (n-3) + slowFib (n-4)) + (slowFib (n-4) + slowFib (n-5)) + (slowFib (n-4) + slowFib (n-5)) + (slowFib (n-5) + slowFib (n-6))
...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;２行めでは２項だったのが３行めでは４項、４行めで８項になっているので、ここまでは項数は^2で増えていく。もちろんすべての項が一律に倍の項数になるわけではなく、前の項から順番に、いずれ&lt;code&gt;slowFib 1(0)&lt;&#x2F;code&gt;に達するので、それ以上は項数は増えない。そして全体でみると、２より少し小さいくらいの数字（＝黄金律）の指数オーダーで項数が増えていく。…ということだと思う。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tapuringufa&quot;&gt;タプリング法&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B07SFCMP66&#x2F;&quot;&gt;入門Haskellプログラミング&lt;&#x2F;a&gt;にあったヒントをもとに実装したもの。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;fasterFib 1 (a,b) = a
fasterFib n (a,b) = fasterFib (n-1) (a+b,a)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;*Main&amp;gt; fasterFib 30 (1,1)
1346269
(0.01 secs, 117,312 bytes)

*Main&amp;gt; fasterFib 50 (1,1)
20365011074
(0.01 secs, 127,296 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;第一引数はカウンタで、これが1になるまで1つずつ減らしていく。減らしていく過程で第二引数のペアが足され、次のペアを生成する。これは（たぶん）タプリング法と呼ばれる手法なのだが、なぜこれが速いのか、自分で実装しておきながら理屈がいまいちピンとこなかったので、分解してみる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;fasterFib 30 (1,1)
= fasterFib 29 (2,1)
= fasterFib 28 (3,2)
= fasterFib 27 (5,3)
...
= fasterFib 1 (1346269,832040)
= 1346269
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;項数がどの行も同じ１つで済んでいるということが、こういうふうに書いてみれば明らかだ。
&lt;a href=&quot;http:&#x2F;&#x2F;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;4048930532&#x2F;&quot; title=&quot;Haskellによる関数プログラミングの思考法&quot;&gt;Haskellによる関数プログラミングの思考法&lt;&#x2F;a&gt;は少し違う形で実装していて、&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;--fib2 n = (fib n, fib (n+1))と考えて
fib2 0 = (0,1)
fib2 n = (b,a+b)
	where
		(a,b) = fib 2 (n-1)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;としている。著者によると、「タプリング法では引数を追加して関数を一般化するのではなく、結果を追加して関数を一般化する」(p.161)。&lt;br &#x2F;&gt;
&lt;code&gt;fasterFib&lt;&#x2F;code&gt;は引数（左辺）のほうに追加しているが、実質的には&lt;code&gt;fib n = fib (n-1) + fib (n-2)&lt;&#x2F;code&gt;という計算の結果を引数として追加しているので、変形タプリング法と呼べる、かもしれない。&lt;code&gt;fib2&lt;&#x2F;code&gt;のほうは逆に、式の右辺にペアの形で追加している。タプル（ペア）の形で計算の結果をまとめて関数内で用いる、というのがタプリング法の肝であるようだ。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Haskellの素因数分解</title>
            <pubDate>Sat, 02 May 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/primefactors/</link>
            <guid>https://kyoheiu.gitlab.io/post/primefactors/</guid>
            <description>&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;headPrimeFactor :: Integer -&amp;gt; Integer
headPrimeFactor n = if fstprime == []
                    then n
                    else head fstprime
                        where
                            fstprime = filter primes [2..sqrt&amp;#x27;]
                            primes x = n `mod` x == 0
                            sqrt&amp;#x27; = floor $ sqrt $ fromIntegral n

primeFactorsList :: Integer -&amp;gt; [Integer]
primeFactorsList 1 = []
primeFactorsList n = (headPrimeFactor n) : primeFactorsList (n `div` (headPrimeFactor n))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;memo&quot;&gt;メモ&lt;&#x2F;h2&gt;
&lt;p&gt;たとえば&lt;code&gt;primeFactorsList 24 = [2, 2, 2, 3]&lt;&#x2F;code&gt;となるような関数&lt;code&gt;primeFactorsList&lt;&#x2F;code&gt;を作りたい。&lt;br &#x2F;&gt;
このリストがどう定義できるかを考えると、まず先頭の2というのは、24を[2..]で順番に割っていったときの最初の約数とおくことができる。さらにその次の2は、最初の約数である2で24を割った12について、[2..]で順番に割っていったときの最初の約数である。&lt;br &#x2F;&gt;
つまり、リストの&lt;code&gt;head&lt;&#x2F;code&gt;をとっていき、それを再帰でコンスしていくというのが、Haskellによる素因数分解の素朴な解法となるはずだ。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;headPrimeFactor&lt;&#x2F;code&gt;は&lt;code&gt;primeFactorsList&lt;&#x2F;code&gt;の補助関数で、nの平方根の整数部分までの整数のうち、nの約数となるものを&lt;code&gt;filter primes&lt;&#x2F;code&gt;で抽出し、その先頭の数字を返すもの。ただし、nが素数の場合はリストが空になるので、よく考えず&lt;code&gt;head&lt;&#x2F;code&gt;を使うとエラーが出てしまう（というか出た）。これを回避するために、リストが空である場合とそうでない場合で分岐を作らないといけない（&lt;code&gt;maybeHead&lt;&#x2F;code&gt;で&lt;code&gt;Nothing | Just Integer&lt;&#x2F;code&gt;を返すバージョンも書いてみたが、&lt;code&gt;head&lt;&#x2F;code&gt;を使う場合と使わない場合で分けたほうが当然ながらシンプル）。空の場合はnを、そうでない場合は最も小さい約数を返す関数となる。&lt;br &#x2F;&gt;
これを再帰的にコンスしていくのが&lt;code&gt;primeFactorsList&lt;&#x2F;code&gt;で、仕組みとしては上に書いた通り。&lt;&#x2F;p&gt;
&lt;p&gt;適当な整数を素因数分解してみると、次のようになる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;*Main&amp;gt; primeFactorsList 2039801
[23,131,677]
(0.01 secs, 170,624 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;*Main&amp;gt; primeFactorsList 2380479237540923
[29,82085490949687]
(3.48 secs, 2,754,399,560 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;ひとつの整数の素因数分解として速いか遅いか、まだよくわからないけれど…。 
もう少し工夫したやり方があるような気もするなぁ。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Haskellで種類の数を数える（重複の削除）</title>
            <pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/dataset/</link>
            <guid>https://kyoheiu.gitlab.io/post/dataset/</guid>
            <description>&lt;p&gt;複数の要素を扱うための基礎的なライブラリをいろいろテストしてみる題材として、こちらの問題を使用させてもらう。&lt;&#x2F;p&gt;
&lt;p&gt;At Coder abc164 C - gacha &lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;atcoder.jp&#x2F;contests&#x2F;abc164&#x2F;tasks&#x2F;abc164_c&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;実行時間制限: 2 sec &#x2F; メモリ制限: 1024 MB
配点 : 300点
問題文
くじ引きをN回行い、i回目には種類が文字列Siで表される景品を手に入れました。
何種類の景品を手に入れましたか？&lt;&#x2F;p&gt;
&lt;p&gt;制約
1 &amp;lt;= N &amp;lt;= 2*(10^5)
Siは英小文字のみからなり、長さは1以上10以下&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;たとえば入力が&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;3
apple
orange
apple
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;の場合は、appleとorangeの２種類を入手することになるので、正解の出力は2となる。&lt;&#x2F;p&gt;
&lt;p&gt;結局のところ、「種類の数」をどう定義するか（Haskellではどう定義できるか）を考えるわけだが、&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;ひとつひとつの要素が、すでにあるリストに含まれていないかを、再帰関数でチェックしていった結果生成されるリストのlength&lt;&#x2F;li&gt;
&lt;li&gt;要素のかたまりを、同じ要素のかたまりに分けたときの、そのかたまりの数&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;たとえばこういったふうにおくことができると思う。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zai-gui-guan-shu-dejie-ku&quot;&gt;再帰関数で解く&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;risutowoyong-itazai-gui-guan-shu&quot;&gt;リストを用いた再帰関数&lt;&#x2F;h3&gt;
&lt;p&gt;まずリストで再帰関数を作ったバージョン。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;--TLE
import Control.Monad

delDupe :: [String] -&amp;gt; [String] -&amp;gt; [String]
delDupe [] _ = []
delDupe (x:xs) lst
    | x `notElem` lst = x : delDupe xs (x : lst)
    | otherwise       = delDupe xs lst

main = do
    n &amp;lt;- readLn
    s &amp;lt;- replicateM n getLine
    print $ length $ delDupe s []
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;delDupe&lt;&#x2F;code&gt;は、与えられるリストを&lt;code&gt;(x:xs)&lt;&#x2F;code&gt;とし、重複がなければ&lt;code&gt;x&lt;&#x2F;code&gt;を第二引数の&lt;code&gt;lst&lt;&#x2F;code&gt;に加えつつ、&lt;code&gt;x&lt;&#x2F;code&gt;を含むリストを返す再帰関数。
しかしこれでは遅く、18の入力のうち７つがTLEとなってしまう。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nubnozheng-ti&quot;&gt;nubの正体&lt;&#x2F;h3&gt;
&lt;p&gt;あとで気づいたのだが、Preludeにはリストの重複を削除する関数&lt;code&gt;nub&lt;&#x2F;code&gt;が標準でついているので、次のように書けることは書ける。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;import Control.Monad

main = do
    n &amp;lt;- readLn
    s &amp;lt;- replicateM n getLine
    print $ length $ nub s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;が、これは実は最初の「再帰での重複チェック→新たなリストの生成」と実行時間・メモリ使用量ともに変わらなかった。Preludeの&lt;code&gt;nub&lt;&#x2F;code&gt;の定義はこちら。&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;base-4.12.0.0&#x2F;docs&#x2F;src&#x2F;Data.OldList.html#nub&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;-- | &amp;#x2F;O(n^2)&amp;#x2F;. The &amp;#x27;nub&amp;#x27; function removes duplicate elements from a list.
-- In particular, it keeps only the first occurrence of each element.
-- (The name &amp;#x27;nub&amp;#x27; means \`essence\&amp;#x27;.)
-- It is a special case of &amp;#x27;nubBy&amp;#x27;, which allows the programmer to supply
-- their own equality test.
--
-- &amp;gt;&amp;gt;&amp;gt; nub [1,2,3,4,3,2,1,2,4,3,5]
-- [1,2,3,4,5]
nub                     :: (Eq a) =&amp;gt; [a] -&amp;gt; [a]
nub                     =  nubBy (==)

-- | The &amp;#x27;nubBy&amp;#x27; function behaves just like &amp;#x27;nub&amp;#x27;, except it uses a
-- user-supplied equality predicate instead of the overloaded &amp;#x27;==&amp;#x27;
-- function.
--
-- &amp;gt;&amp;gt;&amp;gt; nubBy (\x y -&amp;gt; mod x 3 == mod y 3) [1,2,4,5,6]
-- [1,2,6]
nubBy                   :: (a -&amp;gt; a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; [a]
#if defined(USE_REPORT_PRELUDE)
nubBy eq []             =  []
nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -&amp;gt; not (eq x y)) xs)
#else
-- stolen from HBC
nubBy eq l              = nubBy&amp;#x27; l []
  where
    nubBy&amp;#x27; [] _         = []
    nubBy&amp;#x27; (y:ys) xs
       | elem_by eq y xs = nubBy&amp;#x27; ys xs
       | otherwise       = y : nubBy&amp;#x27; ys (y:xs)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これは最初に作った再帰関数そのものだから、結果が同じになって当然なのだった。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sortsitemiru&quot;&gt;sortしてみる&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;sortsitegroup-risuto&quot;&gt;sortしてgroup（リスト）&lt;&#x2F;h3&gt;
&lt;p&gt;そこで２つめの、&lt;code&gt;sort&lt;&#x2F;code&gt;して重複をまとめる方法。
まずはリストを用いると、このようになる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;--AC
import Control.Monad
import Data.List as List

main = do
    n &amp;lt;- readLn
    s &amp;lt;- replicateM n getLine
    print $ length . group $ List.sort s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Data.Listの&lt;code&gt;sort&lt;&#x2F;code&gt;関数をかませたリストに、隣接する同要素をリスト内リストにまとめる&lt;code&gt;group&lt;&#x2F;code&gt;関数をさらにかませてリスト内要素の長さをとるという手順。
かなり泥臭いやり方だが、再帰や&lt;code&gt;nub&lt;&#x2F;code&gt;よりも速いというのはちょっとおもしろい。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;data-vectornouniqguan-shu-woyong-iru&quot;&gt;Data.Vectorのuniq関数を用いる&lt;&#x2F;h3&gt;
&lt;p&gt;リスト以外のデータ構造ではどうだろう。&lt;br &#x2F;&gt;
まずData.Vectorから。普通に入門書を読んでいるだけだとまず遭遇しないライブラリだが、海外のQ&amp;amp;AサイトではSequenceとどっちがいいの、といった質問でたまに見かける名前だ。&lt;&#x2F;p&gt;
&lt;p&gt;Data.Vector&lt;br &#x2F;&gt;
https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;vector-0.12.0.1&#x2F;docs&#x2F;Data-Vector.html&lt;&#x2F;p&gt;
&lt;p&gt;これはポリフォーミックなarrayで、リスト操作とarray操作のいいとこどりをしたものである、とHackageでは説明されている。
一通りの標準的な関数は装備されているが、ここで用いたいのは&lt;code&gt;uniq&lt;&#x2F;code&gt;関数。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;uniq :: Eq a =&amp;gt; Vector a -&amp;gt; Vector a
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;隣接した同じ要素を&lt;code&gt;drop&lt;&#x2F;code&gt;できるものだが、「隣接している」ことが条件なのでsortedが前提となる。
そこで&lt;code&gt;sort&lt;&#x2F;code&gt;関数と組み合わせて次のようにする。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;--AC
import Control.Monad
import qualified Data.Vector as V
import qualified Data.List as L

main = do
    n &amp;lt;- readLn
    s &amp;lt;- replicateM n getLine
    print $ length . V.uniq . V.fromList $ L.sort s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これでも一応問題はクリアだが、実はリストによる&lt;code&gt;group . sort&lt;&#x2F;code&gt;のほうが若干早いということも分かった。
感覚的には必要のない重複を&lt;code&gt;drop&lt;&#x2F;code&gt;できる&lt;code&gt;uniq&lt;&#x2F;code&gt;関数のほうがmake senseではあるのだけれど、&lt;code&gt;V.fromList&lt;&#x2F;code&gt;でO(n)かかってしまっているので致し方ないというところだろうか。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;data-setnosizeguan-shu&quot;&gt;Data.Setのsize関数&lt;&#x2F;h2&gt;
&lt;p&gt;もうひとつ、Data.Setを見てみる。その名の通り、集合論をベースにした、同型の要素のSetを扱えるライブラリだ。&lt;&#x2F;p&gt;
&lt;p&gt;Data.Set&lt;br &#x2F;&gt;
https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;containers-0.6.2.1&#x2F;docs&#x2F;Data-Set.html&lt;&#x2F;p&gt;
&lt;p&gt;このライブラリが楽しいのは、&lt;code&gt;Set.fromList&lt;&#x2F;code&gt;でリストからSetを生成する過程で、重複要素が自動的に&lt;code&gt;drop&lt;&#x2F;code&gt;される点。この自動&lt;code&gt;drop&lt;&#x2F;code&gt;がいかにも自然に感じられるところがmake senseだ。&lt;br &#x2F;&gt;
Data.Setを用いたコードは次のようになる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;--AC
import Control.Monad
import qualified Data.Set as Set
 
main = do
    n &amp;lt;- readLn
    s &amp;lt;- replicateM n getLine
    print $ Set.size $ Set.fromList s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Set.size&lt;&#x2F;code&gt;はリストでいう&lt;code&gt;length&lt;&#x2F;code&gt;だが、これはO(1)。&lt;br &#x2F;&gt;
実行結果も、リスト版&lt;code&gt;group . sort&lt;&#x2F;code&gt;と大差がつくわけではないものの、最速。&lt;br &#x2F;&gt;
集合論的な発想を武器にできれば、色々な場面でかなり効率的にデータ処理ができそうな予感がする。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Jamil Jan Kochai &#x27;Playing Metal Gear Solid V: The Phantom Pain&#x27;</title>
            <pubDate>Wed, 15 Jan 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/playingmgsv/</link>
            <guid>https://kyoheiu.gitlab.io/post/playingmgsv/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.newyorker.com&#x2F;magazine&#x2F;2020&#x2F;01&#x2F;06&#x2F;playing-metal-gear-solid-v-the-phantom-pain&quot;&gt;Playing Metal Gear Solid V: The Phantom Pain&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;The New Yorkerの誌面にしてわずか３ページほどの掌編だが、素晴らしく面白かった。タイトルからして最高で、そして期待をさらに上回る読書体験。ゲーマーならずとも必読。&lt;&#x2F;p&gt;
&lt;p&gt;少年の父はアフガニスタン出身で、アフガンでの戦争体験があり、それが現在の心と身体に深刻に影響している。少年がプレイする「メタルギアV」はアフガンその地をディテールまで丁寧に再現した作品。少年は画面の中に、若き父とその亡き弟―生前の写真が家に飾ってある―がいるのを見つける。彼らをここから助け出さなければならない。その強迫的とも言える考え―つまり幻肢痛だろう―にとらわれた少年は、必死にプレイを続けるが…。&lt;&#x2F;p&gt;
&lt;p&gt;これはひとまずは古典的なSFの仕掛け、つまりタイムリープであり、「過去を変えることで現在を変える」というモチベーションで駆動された感情のドラマなのだが、しかし一方で、何もSFの要素などない、と言うこともできる。少年の目の前にあるのは（おそらくPS4と）モニターだけであり、それはどこにでも置かれているデバイスにすぎない。あるいはゲームこそがSFなのかもしれない。SFであり魔法なのかもしれない。私たちはゲームをプレイすることであらゆるところに行ける。何者にだってなれる。「メタルギアV」ほど作り込まれたゲームでなくとも―もちろん小島監督の執念によって生み出されたこのタイトルの精細さがある種のトリップを生むきっかけにはなるのだけれど―8bitのゲームでさえ、私たちをここではないどこかへ連れていってくれることを、私たちはもう知っている。というよりは、この掌編を読んで、そのことを思い出す。&lt;&#x2F;p&gt;
&lt;p&gt;あらゆる要素が現代的であるにもかかわらず、魔法が父と少年を束の間救う。そして、僕の胸に圧倒的なノスタルジーを残していく。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>about this site</title>
            <pubDate>Wed, 01 Jan 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/about/</link>
            <guid>https://kyoheiu.gitlab.io/about/</guid>
            <description>&lt;h3 id=&quot;topics-on-this-site&quot;&gt;Topics on this site&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;coding&lt;&#x2F;li&gt;
&lt;li&gt;literature&lt;&#x2F;li&gt;
&lt;li&gt;math&lt;&#x2F;li&gt;
&lt;li&gt;linux&lt;&#x2F;li&gt;
&lt;li&gt;...and more!&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;who-s-writing&quot;&gt;Who&#x27;s writing&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kyoheiu&quot;&gt;GitHub: kyoheiu&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.ted.com&#x2F;profiles&#x2F;14244197&#x2F;translator&quot;&gt;Kyohei Uto&#x27;s TED Translations&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
</description>
        </item>
        <item>
            <title>Jesse Ball &#x27;The Divers&#x27; Game&#x27;</title>
            <pubDate>Mon, 23 Dec 2019 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/diversgame/</link>
            <guid>https://kyoheiu.gitlab.io/post/diversgame/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B07CWT59DC&#x2F;&quot;&gt;The Divers&#x27; Game: A Novel&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;市民であるpatsと、移民およびその子孫であるquadsとに人々が分けられて生きる社会。patsは皆ガスマスクとガス缶を持っていて、いざというときはquadsをガスで殺しても罪に問われない。quadsはpatsと見分けがつくように、全員片方の手の親指を切り取られ、顔に焼印をおされる。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;The Diver&#x27;s Game&lt;&#x2F;em&gt;は、この架空の社会を舞台にした小説集で、２つの中編&amp;quot;Ogias&#x27; Day&amp;quot;と&amp;quot;Row House&amp;quot;、そして短編&amp;quot;Letter&amp;quot;から成っており、これらは同じ世界の話ではあるが、登場人物は共有していない。それぞれはあらすじにしてしまえば割にシンプルなのだけれど、「レビューを書く」となると途端に難しくなる。これはできるだけ事前情報なしに読むべき本だと思うので、未読の方はできればまず読んでみてほしい。&lt;&#x2F;p&gt;
&lt;p&gt;まず&amp;quot;Ogias&#x27; Day&amp;quot;は、学校の講師に臨時のアシスタントとして「動物園」に連れていってもらう、二人の双子のようによく似た女子学生の話だ。動物園には一人しか入ることを許されないために、途中で物語は分岐するものの、最終的には動物園に入れなかったほうの女子学生の行方が綴られることになる。&lt;br &#x2F;&gt;
&amp;quot;Row House&amp;quot;はquadsの街で数年に一度催される祝祭・The Day of the Infantaの前日および当日を描くもの。前日のパート&#x27;The Day of the Infanta&#x27;では、この年the Infantaに選ばれた小さな女の子の視点から祝祭の準備、リハーサルを描写しつつ、彼女が気づくことのない祝祭の真の姿が明らかにされていく。当日のパート&#x27;The Divers&#x27; Game&#x27;では、quadsの富豪の息子の世話をしていた貧しい家の少年が中心となる。富豪の息子が行方不明になったことで、少年は厳しい事情聴取を受ける。
そして&amp;quot;Letter&amp;quot;は、quadの男をガスで殺したpatの女性が、自殺前にパートナーに向けて書く遺書、という形式をとっている。&lt;&#x2F;p&gt;
&lt;p&gt;ともかく順番に見ていこう。最初の&amp;quot;Ogias&#x27; day&amp;quot;にはこれといった結末はない。それは他の収録作も同じだが、特にこの最初の話に関しては、世界観の導入といった側面が強く、作品全体に対するイントロダクションになっているという見方もできないわけではない。&lt;br &#x2F;&gt;
しかしこの&amp;quot;Ogias&#x27; day&amp;quot;は、収録作のうちで最も暴力の気配が濃厚な話でもある。登場人物が暴力を直接その身に受けるわけではないけれど、その近くには暴力が常に漂っている。２人の女子学生のうちの１人・Letheの視点から始まるこの話は、まず通学途中の電車で歌われるCreed - 信条で読み手の肝を冷やしてくる。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;A citizen&lt;br &#x2F;&gt;
For the life of him&lt;br &#x2F;&gt;
Or her or he or she&lt;br &#x2F;&gt;
That keeps a mask&lt;br &#x2F;&gt;
On the belt or arm&lt;br &#x2F;&gt;
Need never fear the streets.&lt;br &#x2F;&gt;
If trouble comes&lt;br &#x2F;&gt;
Like quad scum—&lt;br &#x2F;&gt;
Your mask put on!&lt;br &#x2F;&gt;
Your mask put on!&lt;br &#x2F;&gt;
The gas shall flow&lt;br &#x2F;&gt;
A cloud to grow&lt;br &#x2F;&gt;
And lay them low&lt;br &#x2F;&gt;
The lowest at our feet.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;これはpatsの市民憲章とも呼べるもので、この世界の基礎部分で、「You」と「They」が区分けされていること、そして暴力が前提とされていることが分かる。暴力によって成立している社会、ディストピアフィクション、予言的な小説。この本は現実の私たちへのある種の警告なのだろうか？&lt;br &#x2F;&gt;
衝撃的な歌から始まるこの最初の物語は、続いてpatsの学生たちが学ぶセンターでの講義へと舞台を移す。講師は、なぜこの社会が今のような形をとるようになったのかを、生徒へというよりは読み手へ言い聞かせるように冷静に語っていく。増え続けていった移民。権利の制限の必要性と、何よりも「見分けをつける」必要性が社会によって合意されていく。ここがある意味ではこの小説において最も直接的に暴力を描いている部分となる。生徒たちはスクリーンで、片方の親指を切り取られるquadsの映像を見せられる。制度として執行される暴力を目の当たりにさせられた生徒たちは、けれど疑問に感じるとか、怒りを覚えるとかいった反応を示さない。むしろ、&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The lights came on, and suddenly everyone could see one another. They had all seen this grisly sight, all felt separated, alone in the face of it, but then with the lights on, they could see one another, familiarly, happily. Although they were not, it was almost as though they rubbed against one another all at once like cats, a happiness born from sameness, and in that spirit they poured out of the lecture hall.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Ballの洞察は鋭い。映画館的な暗闇の中で、個々に分断されてスクリーン上のまぎれもない暴力（しかもそれは「自分たち」による暴力）を見せつけられた生徒たちは、それに反発するどころか一度無力化され、そして暗闇から解放されたことによってむしろ親密に結びついていく。一見やや野暮ったい小説のイントロにしか感じられなかったこの講義のシーンは、ここに至って、暴力を目にすることによって連帯する人間の本能的な特徴をひとつの題材にしているのだとわかる。&lt;br &#x2F;&gt;
本能。僕がこの小説を、時代に即した／時代批評的な作品と読むことに違和感を覚えるのは、結局、この中で描かれるひとつひとつの人間の語り、反応、思考がすべて、人間のもともと持っている本能と大きく関わっていると感じるからだ。それは今の時代に特有のものではない。今の世情に（そこに理屈があろうがなかろうが）批判的な心情を抱いている者はこの小説に批評性を感じるかもしれないが、それは歪んだ鏡というものだろう。&lt;br &#x2F;&gt;
もっともぞっとさせられるのは、もう１人の女子学生・Loisが講師に投げかける質問の内容だ。彼女は、「なぜいつも右手の親指を切り取るのか？」と尋ねる。利き手を特定し、その親指を切り取るほうが効果的なのではないか、と。クレバーな、同時に非共感的なこの視点に、読み手は慄く。講師はこう答える。―今は皆利き手の親指を切り取られているが、当初は運営の混乱があった。そもそも親指を切り取るのは何のためか？　quadsの活動を抑えるためなのか、それともページの端を折るように見分けをつけるためなのか、古来からの法、盗人の指を落とすというしきたりの名残なのか…考えてみよう、と。また別のところで講師は言う。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;As much as we like to think there can be fairness, it is really a foolish idea, one we ought to have done away with long ago. Instead of fairness there is just order and its consequences.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;明らかなのは、彼らにとってはこのシステム、この考え方はすでに所与のものであり、疑う余地がない、ということだ。疑う余地がないものは、それが実際にはいかにグロテスクなものであろうとも、私たちは受け入れる（ということを意識しないまま受け入れている）。こういった有様が現代に特有の傾向であるとか、今の私たちに必要な警告をこの小説は発しているのだ、と言うことは、むしろ一種の傲慢のように感じる。これはむしろ人間という生き物が抱える認知の問題、人間が人間であるうちは決して切除できない、抱え続ける問題なのではないか？　アイヒマンが20世紀から21世紀にかけてしか存在しないと考えるのは一種の「昔はよかった」であり、中世も近代も現代も、常に人間の社会というのはある種の人間にとってはまともな社会ではなかったと考えるほうが、間違いは少ないのではないか？　…私たちはそう問われているのだろうか？&lt;&#x2F;p&gt;
&lt;p&gt;&amp;quot;Ogias&#x27; day&amp;quot;はこの意味できわめてニヒリスティックなパートであり、描写している中身そのものも、ニヒリズムの暴力、暴力のニヒリズムだとも言える。そこには暴力の気配が常に漂っている。patsの学生は、ひとたびquadsの住むエリアに迷い込んでしまえば、自分の肌のすぐ近くにそれが待ち構えていることを感じずにはいない。次の瞬間に暴力がさく裂するかもしれない、そのいわば猶予期間にこそ、暴力は想像され、恐怖が生まれる。そもそもタイトルとなっているOgias&#x27; dayとは、彼女たちが動物園へ行く「今日」の次の日に来たる祝日なのだが、その中身は誰も知らない。借金が帳消しになる徳政令的な日だという者もいれば、あらゆることが許される無法の日だという者もいる。唯一確かなのは、そこに圧倒的な暴力の気配が潜んでいるということだけだ。彼女は（彼女たちは）それに抵抗できない。自分が暴力を受けるかもしれないということさえ、無力感とともに受け入れなくてはならない。なぜならそれは自分たちがしていることそのものであるからだ。&lt;&#x2F;p&gt;
&lt;p&gt;続く&amp;quot;Row House&amp;quot;は、これとはまた異なる暴力の様相を描いている。前半のパートで描かれるThe Day of the Infanta、これはquadsの住むエリアでずっと繰り返されてきた行事のことだが、その実は狂乱と熱狂の果てに犠牲が供される祝祭であり、その犠牲とは幼子であるThe Infantaに他ならないのだから、言ってみれば中世的な祝祭そのものである。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;You’d think we were in the Middle Ages. You’d think no one could read and everyone did what the king says, et cetera et cetera.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;暴力を受ける側の中に暴力が潜んでいる。しかも、最終的に犠牲にされる幼子は（そのことは本人には決して知らされない）、命を奪われる前に暴力の限りを尽くすことが許されている。ありとあらゆる「判決」を自分のしたいように下すことができるし、誰に対してどんな命令をしてもよい。そうした時間の後に幼子は犠牲となる、これはそういう祝日なのだった。ここに至って暴力とは、単に執行する側とされる側との間でリニアに・不可逆に行われるものではなくなる。むしろそれは、社会というひとつの巨大の生物の内部で循環し続けるコミュニケーションの一種であり、執行する者とされる者はめまぐるしく変わり、一定ではない。さらに言えば、これは中世的なものでもない。私たちは「いじめ」を知っているからだ。&lt;br &#x2F;&gt;
そして&amp;quot;Row House&amp;quot;の後半パート、&#x27;The Divers&#x27; Game&#x27;で描かれるのも、端的に言えば「いじめ」の構造に他ならない。失踪した富豪の息子の身に起きたのは、ある種の狂乱と過熱の果ての事故であり、全員が加害者であるような事件だった。少しも時代的ではない、普遍的な暴力がここでは描かれている。言い換えると、暴力は偏在している。&lt;&#x2F;p&gt;
&lt;p&gt;そして最終章&amp;quot;Letter&amp;quot;。語り手であるpatの女性は、散歩をしていたとき、quadの男が自分に不必要なまでに近づいてくるのを見て、ガスを噴射する。相手は息絶える。このこと、そしてこの社会に耐えられないと感じた彼女は自殺することを決め、パートナーへ向けて遺書を綴る。その遺書の内容がこの章ということになる。かなり抽象的な心象風景の描写が続くので、この小説で最も難解なパートと言えるが、乱暴にまとめると、おそらくここに書かれているのは「彼は私であり、彼を殺した私はすでにそのとき死んでいるも同然だ」ということだ。線を引かれ区別されていた２つの集団それぞれに属する２人の個人がわずかに接触するかのように思われた瞬間、可能性としての共通点が生まれ、けれど暴力も不可避的に生まれてしまう。これはロミオとジュリエットの悲劇だ。そして悲劇は人を動かす力を持っている。登場人物は（ようやく？）社会批判めいたものを織り交ぜて語ることを始める。&lt;br &#x2F;&gt;
この悲劇は、美しい。しかし、美しさを増すと同時に、それまでのBallのリズミカルな投げかけを中心とした文体は、力を失って透明化していくように感じられる。&lt;&#x2F;p&gt;
&lt;p&gt;文体は、この小説を考える上で絶対に欠かせない要素なので、本当はもっとその話をしたほうがよかったのかもしれない。&lt;br &#x2F;&gt;
投げかける、問いかける。しかも問いかけの主体はスクリーンの向こうから、登場人物の肩越しに語りかけてくるような曖昧な存在だ。たとえば&amp;quot;Ogias&#x27; Day&amp;quot;の出だしは&#x27;Lethe!&#x27;という呼びかけなのだが、誰が呼んでいるかは判然としないし、そもそもLetheというのが誰なのか、読み手はまだ知らない。けれど読み手からすると、まるで自分が呼びかけられているかのように感じてしまう。ここで試みられているのがアルチュセールのいう「警官の呼びかけ、主体化＝服従化」であることは明らかだ。&amp;quot;Row House&amp;quot;の出だしもまた、次のようなものである。&#x27;Where is that girl? Lessen! Lessen—come out!&#x27; Ballは全編にわたりこのような呼びかけを織り交ぜている。これが、この小説の力の源泉となっているのは確かだ。それは暴力的なまでに、と言ってもいいのかもしれない。暴力とは他者に対する呼びかけだ、ということになる。&lt;br &#x2F;&gt;
しかし最終章では呼びかける者も呼びかけられる者も形ある人間となり、読み手の前に姿を現す。読み手は「主体化」から解放され、テキストは呼びかけから自由になり、いずれも「シンプル」になっていく。それは美しいけれど、最早それ自体に暴力的な力は残っていない。そして小説は終わる。&lt;br &#x2F;&gt;
すべてがフェードアウトして消えていくような最後の「遺書」は、難解なのに水のように儚い。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>山崎ナオコーラ『リボンの男』</title>
            <pubDate>Thu, 12 Dec 2019 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/ribbon/</link>
            <guid>https://kyoheiu.gitlab.io/post/ribbon/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B0847L8HWY&#x2F;&quot;&gt;リボンの男&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;いつか育児がしてみたい、と思い続けていた主人公の小野常雄は今、家事と３歳の息子の育児を担う主夫をしている。妻のみどりは書店の店長。自分の活動について、時給はいくら、マイナスいくら…などと考えながら、彼の日々が過ぎていく。&lt;&#x2F;p&gt;
&lt;p&gt;特にファンというわけでもないのに、山崎ナオコーラの本は買ってしまう。読み応えはいつもあまり変わらない。『美しい距離』だけは珍しくエモーショナルな出来だったが。&lt;&#x2F;p&gt;
&lt;p&gt;社会の中に生きる人間が、社会の外に出るのではなく、社会に属したまま社会を変える方法がないか模索していく、というのがナオコーラの小説の骨子だ。彼／彼女が悩む「問題」がいつも同じというわけではないが、ベースには「区別」への目線がある。性別や年齢、職業など、この社会で人をカテゴライズしている何かについて、ナオコーラは考える。&lt;&#x2F;p&gt;
&lt;p&gt;かと言って、個人主義というわけでもない。ナオコーラのとる戦術はもう少し複雑だ。たとえばこの小説でいえば、主人公の妹子（これはあだ名）が悩んでいるのは「自分の時給」についてだ。川に落ちた百円玉を、こどもと一緒に探した挙げ句見つからない。時給マイナス百円の男。病気かもしれない野生のたぬきのことを動物病院に相談に行く。時給マイナス千五百円の男。冗談めかしているが、気にしていないわけではない。&lt;br &#x2F;&gt;
個人主義者なら、「そんなこと気にするなよ」と言うのかもしれない。そんなのどうでもいいだろ、と。自分の価値を時給になんて換算するな、と。しかしナオコーラの描く人物は悩む。社会のルールを認識した上で無視する、という態度に出ることができない。そのルールに、社会にとらわれたままで、どうにかして胸を張って生きようとする。社会と関わるのをやめようとしない。「息苦しい社会」について考えるタイプの小説であるように思って本を手にとった個人主義者は、ナオコーラの描く人間の考え方に面食らい、反発するかもしれない。かといって、もちろん保守的な読み手が満足するような内容でもない。だからナオコーラは左にも右にも受けが悪い。でも、時間をかけて考えることが好きな人には、あるいはそういうふうに考える人を見ることが好きな人には、特別な作家だろう。&lt;&#x2F;p&gt;
&lt;p&gt;まだ迷いを感じる内容ではある。社会にとっての自分の価値は何なのかと悩む妹子が行き着く答えは、その時々によって変わる。あるときは「お金を払うことに意味があるのだ」と思ってみる。またあるときは「主夫業界に少しでも貢献できれば」と考えてみたりする。前者は熊谷晋一郎の言う「生産性よりも必要性が勝る」に近いものがある。ただしこれは、論理的に正しいかどうかはよくわからない。後者は、ナオコーラが自らのエッセイで語る「売れないのに小説を書き続ける意味」をそのまま反映しているのだが、やはり曖昧で感覚的なものにとどまっている。このふたつが同じものなのか、違うものなのかもよくわからない。ナオコーラ自身の論理が煮詰まっていない。でも、煮詰まっていないまま書かれたものに意味がないとも思わない。&lt;&#x2F;p&gt;
&lt;p&gt;それに、合間合間に描かれる、ほかの子どもの親との雑談や、道行く人との他愛もない（けれどひやりとするところがないわけではない）会話があることを忘れてはいけない。このとき、妹子は自分の価値について考えない。ただ会話のリズムに集中して身を任せる。その状態は不安定ながら心地が良い。この小説のエッセンスはもしかするとここにこそあるのかもしれない、とも思う。人と交わることに集中しているときは、余計なことは考えない。それでいい。そういう話かもしれない。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>ピーター・シンガーの生命倫理を考える</title>
            <pubDate>Fri, 06 Dec 2019 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/intolerance/</link>
            <guid>https://kyoheiu.gitlab.io/post/intolerance/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B07YKCCXX8&#x2F;&quot;&gt;この国の不寛容の果てに:相模原事件と私たちの時代&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;2016年に相模原の知的障害者福祉施設で起きた大量殺人事件には、この国の今の空気がこれ以上ないほど反映されている。これは、そうした「空気」を共通認識として、編著者が６人の識者と対談した本。事件を真正面から受け止めつつ、それでも「よりよい社会」を自分たちが作っていくにはどうしたらよいのか？を、飛躍も決めつけもなくそれぞれが語っていて、おおむね好感触の内容だったのだが、読んでいて気になる箇所が１つあった。４章、杉田俊介と雨宮処凛の対談の章で、杉田がピーター・シンガーについて以下のように言及しているところ。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;杉田 [...] ピーター・シンガーという哲学者は、権利を享受する人格主体の根拠を、自己意識の有無に置くという議論をしています。これはパーソン論といいますが、この理屈でいうと重度の知的障害者や脳死状態の人、胎児といった、通常の意味でのコミュニケーションの不可能な人間には100%の権利を認める必要はない、という議論になります。知的障害者よりも、ある種の動物たちの生命を優先するべきだ、という話にもなっていく。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;シンガーは多くの本を出しているが、僕自身はこれまで『生と死の倫理』『あなたが世界のためにできるたったひとつのこと 〈効果的な利他主義〉のすすめ』&lt;em&gt;Ethics in the Real World: 82 Brief Essays on Things That Matter&lt;&#x2F;em&gt;（たぶん未邦訳）の３冊しか読んでいなかった。しかもこの３冊のうち、トピックに最も関連していそうな『生と死の倫理』を読んだのはもうだいぶ前で、内容はほとんど覚えていない。一方、&lt;em&gt;Ethics in the Real World&lt;&#x2F;em&gt;は一般向けの短い記事をまとめたものだが、生命倫理について述べている章もあり、それを読む限りでは、杉田がシンガーの生命倫理の正確なところを語っているとは素直に思えないところがあった。まあ興味も沸いたことだし、とパーソン論およびシンガーの生命倫理の理屈について英語版をベースに調べてみることにした。そのとりあえずの結果がこのテキストということになる。正直とても面倒な作業だった。そして怖かった。&lt;&#x2F;p&gt;
&lt;p&gt;本題に入る前に言っておきたいのだけれど、このテキストは杉田を批判するために書いたものじゃない。杉田と雨宮の対談は豊富なトピックを含んでいて広がりの可能性を感じさせてくれるものだったし、引用した箇所に杉田が込めていたのは哲学的な理屈への反駁ではなくて、知的障害者の権利をいたずらに奪うようなことはあってはならない、という想いだろう。その感情そのものには共感するところもある。&lt;br &#x2F;&gt;
ただし、このあと述べるように、「論理的に生命倫理を構築していく」という行為は、「感情的にありとあらゆる（人間）生命の絶対的な平等性を主張する」という行為と、ときに衝突する。前者は、つまりこの場合はシンガーの論理構成だが、後者が論理的に齟齬を抱えているのみならず、ある種の人間にとっては害悪にすらなりうる、ということを指摘している。&lt;br &#x2F;&gt;
このことを認めるにせよ認めないにせよ、論理的に自分の頭で考えていくために必要な土台というのは、ここで羅列しようとしている、過去生み出された議論だと思う。だから今回の件で僕が批判的な気持ちを抱いているのは唯一、大月書店の編集部に対してだ。他者を差別主義者であると糾弾する行為には大きな責任が伴う。それによって相手が、誤解による暴力の被害者になってしまう可能性もあるからだ。実際、シンガーその人がそうした暴力を受けた経験を、&lt;em&gt;Practical Ethics&lt;&#x2F;em&gt;の序文で綴っている。だから、この杉田の言葉には註をつけて、この本のこのページでシンガーはこういうことを言っている、だから杉田が言っていることには根拠がある、と示さなくてはならなかった。それはアカデミックな論文でもエッセイでも対談でも（そしてブログであっても）同じ、最低限の義務だと思う。これを怠った編集部の態度は、現実と丁寧に向き合っていく、というこの本の姿勢と矛盾している。その上僕のような、ちょっと興味を持った程度の素人がまず資料探しからスタートしなくてはいけないというデメリットもある。本当に洒落にならないから、ありとあらゆるノンフィクションは可能な限り註をつけるべきだと思う。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;singanopasonlun&quot;&gt;シンガーのパーソン論&lt;&#x2F;h2&gt;
&lt;p&gt;まずパーソン論について。パーソン論とは、1972年にトゥーリーが発表した論文&amp;quot;Abortion and Infanticide&amp;quot;での主張をベースにした生命倫理の１つの学説である。ざっくり言うと、生存権（a right to life）を持っていると見なされる存在をパーソン（person）と呼んだ上で、パーソンであれば自己意識を持っているはずであると主張するものだ。論理の展開をかなり省いているので、詳細を知りたい人は該当論文を読んでみてほしい。&lt;br &#x2F;&gt;
この主張は確かに杉田の言うパーソン論の定義と一致するように見える。もっとも「権利享受の主体」あたりの言い回しが、ちょっと怪しい感じはするが、対談の中で詳細に解説するわけにもいかないからまず妥当な表現だろう。&lt;br &#x2F;&gt;
では、シンガーは実際このようなパーソン論を用いているのだろうか。「シンガーがトゥーリー流のパーソン論を一切用いていない」と証明することはきわめて難しいので、シンガーがパーソン論に言及しているところを拾いながらシンガーの態度を確認していく、という方法を採ってみる。&lt;&#x2F;p&gt;
&lt;p&gt;ここではとりあえず、生命倫理関連でシンガーの主著だと思われるPractical Ethicsを読む。
まず読み落としてはならないのは、この本がベンサム以来の功利主義を基本的な足場として書かれている、という点だ。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The universal aspect of ethics, I suggest, does provide a ground for at least starting with a broadly utilitarian position. If we are going to move beyond utilitarianism, we need to be given good reasons why we should do so.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;その上で、この本で最初に「特別な意味を持った言葉」としてpersonが使われるのは、生命倫理の議論のために「human 人間」という言葉が含む２つの意味を分けて考えようという提案がなされる箇所である。まず１つめの意味は、「ホモ・サピエンスという種のメンバー」という純粋に生物学的な意味の「人間」であり、これを文字通りmember of the species Homo sapiensと呼ぶことにする。そして、&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;There is another use of the term ‘human’, one proposed by Joseph Fletcher, a major figure in the development of bioethics. Fletcher compiled a list of what he called ‘Indicators of Humanhood’ that includes the following: self-awareness, self-control, a sense of the future, a sense of the past, the capacity to relate to others, concern for others, communication and curiosity.[...]&lt;br &#x2F;&gt;
John Locke defines a person as ‘a thinking intelligent being that has reason and reflection and can consider itself as itself, the same thinking thing, in different times and places’.&lt;br &#x2F;&gt;
This definition makes ‘person’ close to what Fletcher meant by ‘human’, except that it selects two crucial characteristics – rationality and self-consciousness – as the core of the concept. Quite possibly, Fletcher would have agreed that these two are central and the others more or less follow from them. In any case, I propose to use ‘person’, in the sense of a rational and self-aware being, to capture those elements of the popular sense of ‘human being’ that are not covered by ‘member of the species Homo sapiens’. (I take ‘self-conscious’ and ‘self-aware’ to mean the same thing.)&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;引用が長くて申し訳ないが、つまり、本書でシンガーが最初に用いるpersonという単語は、トゥーリー的な（パーソン論における）personでは全然なく、種としてのホモ・サピエンスとオーバーラップしつつも定義の異なるa rational and self-aware beingを指す言葉なのである。種としてのホモ・サピエンスとself-aware beingをあえて分けるのはなぜか？　これは、この先に動物の権利、胎児の中絶、安楽死の是非といった議論が待っており、そのための準備が必要だからだ（たとえば中絶の是非を議論するなら、「胎児は人か？」という質問に応えるための準備をしなければならない）。&lt;br &#x2F;&gt;
パーソン論におけるpersonをシンガーが扱うのは、この定義に続く、&#x27;Killing a Person&#x27;という小見出しのついたパートである（この小見出しのpersonがa rational and self-aware beingを指すことは言うまでもない）。ここでシンガーは、理性的な、自己意識を持つ存在を殺すのが間違ったことであるとしたら、その理由は何かを議論している。提出される「理由」は４つ。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;[...] the hedonistic utilitarian concern with others; the preference utilitarian concern with the frustration of the victim&#x27;s desires and plans for the future; the argument that the capacity to conceive of oneself as existing over time is a necessary condition of a right to life; and respect for autonomy.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;１つめと２つめは功利主義的観点からのもの、４つめはカント来のもの。3つめのthe argument- だけがトゥーリーのパーソン論に触れている部分である。ここのところでシンガーが何を言っているかを見てみると、まずシンガーが、a moral rightという概念の有用性に疑問を投げかけているのがわかる。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;I am not convinced that the notion of a moral right is a helpful or meaningful one, except when it is used as a shorthand way of referring to more fundamental moral considerations, such as the view that – for the reasons offered in the preceding section – for all normal circumstances we should we put the idea of killing people who want to go on living completely out our minds.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;より根本的な道徳についての検討に手っ取り早く言及するためならまだしも、それ以外では有用なものとは思えない、と述べているわけだ。生存権 a right to lifeはもちろんthe notion of moral rightに含まれているから、そもそもシンガーはトゥーリー流の「生存権を持つ存在としてのパーソン」論には懐疑的であると言える。ただし、「生存権を持つとか持たないとかいう議論はなじみ深いものだから、生存権を持つpersonと持たないそれ以外の存在、という主張に根拠があるかどうか、検討してみる価値はある」という。&lt;br &#x2F;&gt;
ここからシンガーは72年のトゥーリーの論文を検討・批判した上で、72年版ではなく、83年にトゥーリーが出した同名の著書のほうで展開されている以下の主張を、a rational and self-aware beingを殺すのが間違っている理由の１つとして提出する。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;To have a right to life, one must have, or at least at one time have had, the concept of having a continuing existence.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;実はトゥーリーは72年の論文で、数々のツッコミを受けている（たとえば睡眠中の人間の権利はどうなるのか？といった単純なものから、十分条件の妥当性にいたるまで）。この批判に応える形で、トゥーリー自身が83年に同名の著書を出して修正を加えている。つまり、シンガーが依拠しているのは、72年版ではなく、83年版のトゥーリーのパーソン論である、と言ったほうが正しい。&lt;br &#x2F;&gt;
いったんまとめると、シンガーの言うpersonとは、まずa rational and self-aware beingであり、さらにそれを腑分けしていったときに登場する&amp;quot;可能性&amp;quot;の１つが、83年版トゥーリーのpersonである。前述したように杉田の言うパーソン論は、72年にトゥーリーが提出したパーソン論を指していることは確かなのだが、このパーソン論と、シンガーの言うpersonとは、すれ違って一致しない。また、シンガーが「権利を享受する人格主体の根拠を、自己意識の有無に置くという議論をしてい」るという杉田の指摘も間違っている。むしろ、先にも述べたように、動物や胎児、安楽死を求める人々の権利を考えるベースとして、まず「自己意識を持つ存在」について検討している、というのが正しい。&lt;&#x2F;p&gt;
&lt;p&gt;なぜこのような誤解が生まれてしまったのか、については、以下の論文が詳しい。これは「シンガー　パーソン論」などで検索すればすぐに出てくる。素人の僕からしても、全体の見取り図をイメージするのに大変役に立った。 &lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;http:&#x2F;&#x2F;repo.kyoto-wu.ac.jp&#x2F;dspace&#x2F;bitstream&#x2F;11173&#x2F;401&#x2F;1&#x2F;0130_010_007.pdf&quot;&gt;国内の生命倫理学における「パーソン論」の受容&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;概 要&lt;br &#x2F;&gt;
本稿では、国内の生命倫理学研究者の間ではマイケル・トゥーリーらに代表される「パーソン論」と呼ばれる考え方が正確に理解されておらず、それが国内の生命倫理学の健全な発展を阻害している可能性があることを指摘する。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;読みやすいのですぐに内容をつかめるが、要するに、国内の多くの生命倫理学研究者は「パーソン論」という言葉で以て、トゥーリーやシンガーらが展開している論理的に（哲学的に）構築されたパーソン論と、エンゲルハートに代表されるような「雰囲気パーソン論」をごっちゃにしており、エンゲルハートのほうの「雰囲気パーソン論」がパーソン論そのものであるかのように考えている。この状況というのは、厳密なパーソン論およびそこから展開されるはずの豊かな議論をそもそも排除してしまっているという点でとても残念なことである。これがこの論文の内容である。&lt;br &#x2F;&gt;
具体的な誤訳の指摘などについては検証する時間も余力もないので江口の書いているところをうのみにするしかないが、素直に読むと、国内での「パーソン論」という言葉の使われ方、受容状況というのはかなり歪んでしまっているな、と思わざるを得ない。&lt;br &#x2F;&gt;
そして、江口が指摘している通りに、トゥーリー・シンガーらのパーソン論と、エンゲルハートのパーソン論がいっしょくたに受容され、語られている…というのが本当であれば、杉田俊介の「シンガーのパーソン論」理解が二重の意味でずれていたことにも納得がいく。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;duan-jie-de-namorarusutetasu&quot;&gt;段階的なモラル・ステータス&lt;&#x2F;h2&gt;
&lt;p&gt;ここで本稿冒頭の引用に戻り、上記で検討した箇所に続く「この理屈でいうと重度の知的障害者や脳死状態の人、胎児といった、通常の意味でのコミュニケーションの不可能な人間には100%の権利を認める必要はない、という議論になります。知的障害者よりも、ある種の動物たちの生命を優先するべきだ、という話にもなっていく」という指摘について見ていく。結論から言うと、これも額面通り受け取ることはできない、というのが答えになる。&lt;br &#x2F;&gt;
&lt;em&gt;Cognitive Disability and Its Challenge to Moral Philosophy&lt;&#x2F;em&gt;という論文集に収録されているシンガーの2009年の論文&amp;quot;SPECIESISM AND MORAL STATUS&amp;quot;が、この点について非常にコンパクトにまとまっているので見ていこう。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Abstract: Many people believe that all human life is of equal value. Most of them also believe that all human beings have a moral status superior to that of nonhuman animals. But how are these beliefs to be defended? The mere difference of species cannot in itself determine moral status. The most obvious candidate for regarding human beings as having a higher moral status than animals is the superior cognitive capacity of humans. People with profound mental retardation pose a problem for this set of beliefs, because their cognitive capacities are not superior to those of many animals. I argue that we should drop the belief in the equal value of human life, replacing it with a graduated view that applies to animals as well as to humans.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;この論文は主に、「人間はみな絶対的に平等である」という主張、および「人間は絶対的に動物よりも高等なものである」という主張への反論、という形で展開していく（この議論展開自体はPractical Ethicsでも用いられているが、複数のトピックを時に行き来しながら進むPractical Ethicsに対して、テーマが絞られているのがこの論文の特徴）。シンガーがこれらの主張の根拠だと指摘するのは3つ、(1)宗教的（特にカトリック的）根拠、(2)種主義的根拠、(3)高等な認知能力、である（種主義 speciesim というのは人種主義とパラレルな概念で、種の違いだけを根拠に利害関係を考慮したりしなかったりする一種の差別主義、というニュアンスで使われている）。このうち、(1)と(2)は（やや複雑な議論が展開されるものの）根拠不十分ということで棄却される。そして(3)は、より高等な認知能力 superior cognitive abilityを根拠として人間と動物とを分けるカント以来の考え方だ。シンガーは次のようにまとめている。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;Animals are not self-conscious and are there merely as a means to an end. That end is man.&amp;quot; Kant’s argument for why human beings are ends-in-themselves is that they are autonomous beings, which, in terms of Kantian philosophy, means that they are capable of reasoning.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;しかし、「理性」を根拠に人間と動物を区別する、ということはつまり、そうした理性を持たないかもしれない&amp;quot;profoundly mentally retarded&amp;quot;な人間を、人間というカテゴリから排除する、ということでもある（そして同時に、ある種の高度な認知能力を持つ動物たちは「人間」として扱われるべきだ、ということにもなる）。人間と動物を分けるはずのキーだった「理性」によって、人間が動物になり、動物が人間にもなる。その結果、最重度の知的障害者は相対的に低い道徳的地位に置かれてしまうことになりかねない。杉田が「通常の意味でのコミュニケーションの不可能な人間には100%の権利を認める必要はない、という議論」「知的障害者よりも、ある種の動物たちの生命を優先するべきだ、という話」という言い方で批判しているのはまさにこうした、認知能力を根拠とした権利の付与を指していると言える。&lt;br &#x2F;&gt;
シンガーはとりあえず、これをよしとしない。「人間はみな絶対的に平等である」という主張、および「人間は絶対的に動物よりも高等なものである」という主張がそもそも間違っているのだ、とシンガーは指摘し、ここで3つのオルタナティブを提出する。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;preserve equality by raising the status of animals, granting them the same status we now grant to humans; or&lt;br &#x2F;&gt;
preserve equality by lowering the status of humans to that which we now grant to animals; or&lt;br &#x2F;&gt;
abandon the idea of the equal value of all humans, replacing that with a more graduated view in which moral status depends on some aspects of cognitive ability, and that graduated view is applied both to humans and nonhumans. &lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;「すべての人間の生命は絶対的に平等である」という主張を保持したいなら、1か2しかない。このうち2は誰もが拒否するだろう。そして1については、シンガー自身がある程度共感する考え方ではあるけれども、受け入れられない部分もある、という（これはこれで当然だろう）。では3はどうか。&lt;br &#x2F;&gt;
ここでcognitive abilityという言葉に何を含ませるかで、議論の展開は大きく変わることになる。これをカント流の「理性」と定義すると、議論は戻ってしまう。&lt;br &#x2F;&gt;
しかしシンガーはカントを採用しない。功利主義者の彼が依拠するのはベンサムだ。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;The question is not, ‘Can they reason?’ nor, ‘Can they talk?’ but, ‘Can they suffer?’&amp;quot; That is indeed a crucial question to ask whenever we are talking about beings who are capable of suffering and one that is clearly relevant to how we should treat both humans and nonhuman animals. Can they suffer? Can they enjoy life? If so, they have interests that we should take into account, and we should give those interests equal weight with the interests of all other beings with similar interests.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;功利主義で考えれば、もしある存在が苦しむことがあるなら、その存在は考慮すべき利害関係を持つ、ということになる。動物も人間も、もちろん重度の障害者も。そしてその上で、それぞれの利害が衝突するのであれば、それを解決するためにa graduated view より段階的な道徳的地位についての見方が必要になってくる、と言っているわけだ。考えてみればこれはほとんど当たり前のことだ。杉田が胎児に（しかしどの時期の胎児だろうか）100%の権利があると考えること自体は自由だが、それは中絶については100%許されないと考えることと同義だ。この考え方は全然現実的ではない、ということはほとんどの人が同意すると思う。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;xiang-mo-yuan-noshi-jian-tosinga&quot;&gt;相模原の事件とシンガー&lt;&#x2F;h2&gt;
&lt;p&gt;ここで終わってもよかったのだが、片手落ちな気がしたのでもう少し書いてみる。&lt;br &#x2F;&gt;
調べていて印象的だったのは、ひとつひとつ貼り付けることはしないが、シンガーの展開する議論と、相模原の大量殺人事件とを結びつける、つまり思想に類似性を見ようとする国内外の声が予想外に多かったことだった。これは妥当な指摘なのだろうか？　このことをきちんと論じる力は僕にはないのだけれど、とりあえず考えてみることはできる。&lt;br &#x2F;&gt;
シンガーと相模原の事件の接点があり得るとしたら、それはeuthanasia 安楽死を巡る議論だろう。シンガーはPractical Ethicsの中で、安楽死を３つのパターンに分けている。殺される者自身が望むvoluntary, 殺される者自身が安楽死に合意できる状態であるにも関わらず同意しない状況で行われるinvoluntary, そして殺される者が合意できる状態にないまま行われるnonvoluntaryの３つだ。２つめのinvoluntaryが正当化されることはまずないから、１つめと３つめに比較的長い議論が費やされている。そしてnonvoluntaryについては、正当化されるケースがしばしばある、と結論を出している。&lt;br &#x2F;&gt;
これを踏まえて、シンガーの議論が仮に相模原の事件そのものを正当化するようなことがあり得るとすれば、結局それは次のような道筋でしかないのではないか。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;相模原の事件は「安楽死処置」か否か。&lt;&#x2F;li&gt;
&lt;li&gt;「安楽死処置」だとするならば、それはinvoluntaryなものか、それともnonvoluntaryなものか。&lt;&#x2F;li&gt;
&lt;li&gt;nonvoluntaryなものだとするならば、それは正当化されるか。&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;1に対してYESと答え、2に対してnonvoluntaryであると答え、3に対してYESと答えることで初めて、シンガーと相模原の事件との思想的類似性を認めることができる。しかしシンガーによるeuthanasiaの定義は当然、この事件の殺人行為とはまったく異なるし、シンガーがnonvoluntaryの例として挙げている実際の安楽死事件のケースは、事件の被害者の状況とは似ても似つかないものである。だから普通に考えれば、この事件とシンガーに思想的類似性を見るのは端的に間違っている。&lt;br &#x2F;&gt;
それでもなお結びつけようとする言葉が散見されるのは、一つには、nonvoluntary euthanasiaをすべてではないにせよ許容するシンガーの議論が強いインパクトを持っており、そこにばかり注目が集まりがちで、しかも拒否反応を含め人々から感情的なものを引き出さずにいない、ということがあると思う。&lt;br &#x2F;&gt;
でも本当に理由はそれだけだろうか？&lt;br &#x2F;&gt;
安楽死措置ではありえないものを安楽死措置だとつい思いたくなってしまう心の動き、障害者が苦しみを感じ、考えを持つということをつい忘れてしまうような心の動き。そういうものが、僕らの中に、僕自身の中にないだろうかと、これを書いている最中、何度も不安になった。&lt;&#x2F;p&gt;
&lt;p&gt;僕らは深淵を覗き込んでいるのだろうか？&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Weike Wang &#x27;The Trip&#x27;</title>
            <pubDate>Thu, 28 Nov 2019 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/thetrip/</link>
            <guid>https://kyoheiu.gitlab.io/post/thetrip/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.newyorker.com&#x2F;magazine&#x2F;2019&#x2F;11&#x2F;18&#x2F;the-trip&quot;&gt;The Trip&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;中国で生まれ、幼少期にアメリカへ渡ってきた妻に連れられ、中国へツアー旅行に来た主人公。あらゆる都市をめぐり、あらゆるものを食しながら旅行は続くが…。 &lt;&#x2F;p&gt;
&lt;p&gt;&lt;em&gt;Chemistry&lt;&#x2F;em&gt;、&lt;em&gt;Omakase&lt;&#x2F;em&gt;のWeike Wangによる新作短編。 &lt;&#x2F;p&gt;
&lt;p&gt;食べ物、ツアーのキッチュさ、アメリカの母からの執拗な連絡に文字通りfed upな主人公は、それでも黙々と、与えられた課題をこなすように時間を耐えていく。それに対して、「中国語は幼児レベル」といとこにバラされ、身の置き所がなくなってしまう妻。実際にはそうではないのにABC - America-born Chineseと揶揄される妻は、ABCにも「中国人」にも身を寄せることができない。こうしたカテゴリとカテゴリの間に落ち込んでしまう人間を、作者はこれまで同様実に巧みに描いている。狭間に落ち込んだ妻を気にかける主人公は、彼女を引っ張り上げる術を持たない。トイレにこもり、食べ物やツアーや母からの攻撃に耐える以外のことができない。&lt;br &#x2F;&gt;
そしてラスト。これをどう読むかに、この作品のほとんどすべてがかかっている。といっても別に複雑なものではなく、妻が主人公と一緒にアメリカへ帰国することを静かに拒否し、中国に残って中国語を学び、ツアーガイドを目指すことにする…というものにすぎない。なんだか非現実的で、どこか逃避的な行動のようにも見える。しかし時間をかけて反芻すると、なんともユニークな結論であるようにも思えてくる。 &lt;&#x2F;p&gt;
&lt;p&gt;ツアーガイドとは何か。 &lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Their tour guide was Felix. Like Felix the Cat, Felix said, and he replied, O.K. &lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;何度も繰り返される上記のような空疎なやり取りによって、それはまずキッチュなものとして読者に提示される。しかも、土産物よりもさらにキッチュなものとして。なぜなら、土産物は少なくとも現地の風土や物産を（形だけにせよ）反映させようという意図を含む商品だけれど、この小説の中のツアーガイドは、もはや”中国”とは関係なく、かりそめの同行者としてなんとなく「親し気なポップカルチャー感」のみを観光客に与えようとするからだ。誰の目にもそれが表面的であることは明らかなので、主人公はそれに対して、O.K.とかSureなどと言うのみで、関係を作っていこうという気を起こさない。ツアーガイドは仮想的な観光世界の中の、言ってみればアバターのようなもので、中に何があるかには誰も興味がないし、関係を結ぶ対象にはなりえない。言い換えればふつうの観光客にとっては、ツアーガイドとはせいぜいが「レンズ」であり、その先の観光空間を覗くための必要最低限の機能と親しみのみが求められる透明な存在にすぎない。だから正確に言うと、ツアーガイドはキッチュなものとしてさえ読者の目には入らない。見えない存在として、中国の食と風景の向こうに合図もなく消えていく。&lt;br &#x2F;&gt;
しかし、妻は主人公の知らぬところで、このツアーで出会ったツアーガイド（そして他の観光客）と「SNS上でともだち」になっている。そして自分もツアーガイドになると言う。この時点でやっとツアーガイドそのものを読者（と主人公）は認知するわけなので、なおさら驚きと恐れは強まる。そうした、一種のミステリの伏線として、この透明さが使われている、とも言える。 &lt;&#x2F;p&gt;
&lt;p&gt;そして同時に、透明な存在とは本当に透明なのか、ということも考えなくてはいけなくなる。それは、「～でもなく、～でもない」という二重否定（つまり似非ABC）の中で苦しんでいた妻が最も得たいもの―「～である」ではなく、「～ではない」でさえない、まったき透明さだったかもしれない。しかし一方で、 Felix the Catは Felix the Catとして存在している。つまり虚構の形をとったひとつの現実というやつで、ツアーガイドはある種の人々にとっては現実そのものでもある。妻は透明さの中に消え失せていくようでもあり、また同時に、SNSというこれまた虚構の形をとった現実の中で確かに生きていくようでもある。いずれにしても確かなのは、しばらく中国にいれば彼女の中国語もまあ聞けたものになるだろう、という妻のいとこの言葉がどこか空疎に響くということで、まず主人公にとってそんなことは問題ではないのだが、実は、妻にとってもそんなことは問題ではない。中国人になるということが答えではないし、中国語が喋れるようになるということが解決策でもない。ツアーガイドになるという彼女の選択は、そうした「いくつかのカテゴリと、それ以外」のレイヤーそのものから脱出しようという試みであり、それがある瞬間には消失にも見え、ある瞬間にはこれ以上ない（画面上の）手触りをもった存在にも感じられる。これはそういう、いくつかの二重性、だぶり、ぼやけ、ぼかし…をめぐる話だと思う。こんなものを書いてしまう作者の力量は、過去作を読んでいる者にさえ衝撃的。 &lt;&#x2F;p&gt;
&lt;p&gt;ちなみに、「ワイキー・ウェン」のほうが英語の発音には近い。第一作で新潮社がつけた「ウェイク・ワン」はほぼ誤訳と言ってもいい気がする。人名の訳は難しい。 &lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Nabokov, things and The New Yorker</title>
            <pubDate>Tue, 12 Nov 2019 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/manandthings/</link>
            <guid>https://kyoheiu.gitlab.io/post/manandthings/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.newyorker.com&#x2F;books&#x2F;page-turner&#x2F;man-and-things&quot;&gt;Man and Things&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;日本では「高級紙」と呼ばれているらしいThe New Yorkerのメールマガジンは、最新記事だけでなく、ときおり過去記事のアーカイヴからピックアップしたものも混ぜて紹介してくれる。たまにひとりの書き手及びその代表的な記事だけを紹介するメールなども送ってくる（しかもそれが何十年も前のルポだったりする）ので、最初はライターという職業にこんなにもリスペクトのある媒体が存在するのかと驚かされた。しかしそういうメールマガジンを受け取り続けていると、だんだんと慣れてきて、これくらいやらないとね、などと思い始めてしまうから贅沢。&lt;&#x2F;p&gt;
&lt;p&gt;しかし先日のメールマガジンにナボコフのテキストがあったのにはさすがに目を疑った。Page-Turnerという、最近の出版物がらみの記事カテゴリがThe New Yorkerの中にあり、ナボコフのテキストもここにカテゴライズされる。読んでみればアメリカで今月出版された、エッセイやレビューなどをまとめたThink, Write, Speakからの抜粋だとわかるものの、トランプの弾劾裁判についての記事と並んでナボコフが写真付きで紹介されているのは何というか、時空を折りたたんでしまったような、一種奇妙な味わいがある。そして読んでみると、この並列こそが編集というものかもしれない、という実感が出てくるからすごい。実際このテキストは、視点、語り口がいかにもナボコフ的でありながら、The New Yorkerの読み物カテゴリに入っていてもおかしくないような身近なテーマを扱っているので、すんなりと画面上で読めてしまう。ホントに恐れ入りました、という感じなのだ。確かにこのレベルの雑誌／新聞は日本にはない。あったら教えてほしいくらい。&lt;&#x2F;p&gt;
&lt;p&gt;The New YorkerはWeb版と紙版がバンドルで購読でき、多少タイムラグはあるが日本にもきちんと郵送で紙版を送ってきてくれる。使われている紙はぺらぺらだが、手にして読み続けても疲れない重さとも言える。今購読するとトートバッグがもらえる（到着までかなり時間がかかる上、縫製がかなり微妙だが）。手元にあれば意外と読む習慣がつくから、おすすめです。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Paul Bloom &#x27;Against Empathy: The Case for Rational Compassion&#x27;</title>
            <pubDate>Tue, 05 Nov 2019 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/againstempathy/</link>
            <guid>https://kyoheiu.gitlab.io/post/againstempathy/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B01FJ5WB0C&#x2F;&quot;&gt;Against Empathy: The Case for Rational Compassion&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;日本語の「共感」がそうであるように、英語でもempathyという言葉は多義的で、このことが議論の混乱を生んでいる模様。作者はまず、empathyをcognitive empathyとemotional empathyとに分ける。前者が、論理的に他者の感じていることを理解し、世界をよりよくするために必要なことは何かを考え実行していくための力であるのに対し、後者は他者の感情をミラーリングし、他者が感じていることをほぼそのまま感じる能力だ。作者が主に批判的検討を加えていくのは後者のミラーリング能力であり、これによって引き起こされる、物事の非論理的な進行である。ショッキングな大事件が人々の感情を動かし、その裏で淡々と進行している悲劇にはだれも注目をしなかったり、政策が中身でなく「どの党がそれを言ったか」で判断される、といったemotional empahtyによって発生していると考えられる様々な事態を仔細に例示する一方で、emotional empathyがよりよい世界／人間を生むためには必要だという主張に対しても執拗な反論を加えていく。スティーブン・ピンカーほどではないが、ブルームもわりとねちっこい議論を展開するタイプである。&lt;&#x2F;p&gt;
&lt;p&gt;ほどではない、というのは主張の中身そのものについても言えて、大雑把に、一方の端に「極端な共感派」を置き、もう一方に「極端な論理派」を置く線分を考えたとき、過激とも思われかねないレベルのeffective altruismを主張するピンカーは「極端な論理派」にほど近いところに位置するだろうけれど、ブルームはそこまではいっていない。真ん中と「極端」の中間地点くらいかな、という気がする。「一般市民」の気持ちもわかるけど、論理的に考えればこうだよね、という感じのbridgingをする一冊と考えればよいと思う。論理的に、と言えば、最終章は「人間の理性的思考」を擁護するパートとなっていて、とかく非論理的なぶち上げが耳目を集める昨今、理性を重視する立場をとるということはなかなか苦労が多そう。&lt;&#x2F;p&gt;
&lt;p&gt;個人的に興味深かったのは、医療・カウンセリングの現場においてemotional empathyは有効か？という４章での議論。技術を習得していく過程でempathyを重要視し強調する教育が行われているけれど、クライアントのネガティブな感情をミラーリングしすぎるといわゆる「燃えつき burnout」の状態にまで至ってしまい、医者・カウンセラーのほうがしんどくなってしまうという話で、これまで読んできた精神医療／カウンセリングの本の主張とも合致し、ここでつながるのか、とちょっとした感慨があった。あくまでも問われているのは病状や症状についての専門的知識と対策であって、クライアントに共感し、一緒になって苦しむことではない。そうした「専門家的態度」をとったときに受けるかもしれない、ミラーリングをしてくれないから冷たく感じる、などといった非難については、それはそれとして別途対策（言葉でしっかりとコミュニケーションをとり、密に確認・連絡をしていく等）をとるべき事柄であって、信頼してほしいからemotional empathyを意識するなどは悪手ということだろう。&lt;&#x2F;p&gt;
&lt;p&gt;それにやや関連して、こどもの共感能力について書かれた幕間の章も、小品ながらけっこう面白かった。こどもに慰められる、というのは、ある種のサプライズと同時に、直接的に心に響いてくる何かがあるように思われるが、以下は本書で引用されているある「慰め」の事例。&lt;&#x2F;p&gt;
&lt;p&gt;“The 15-month-old, Len, was a stocky boy with a fine round tummy, and he played at this time a particular game with his parents that always made them laugh. His game was to come toward them, walking in an odd way, pulling up his T-shirt and showing his big stomach. One day his elder brother fell off the climbing frame in the garden and cried vigorously. Len watched solemnly. Then he approached his brother, pulling up his T-shirt and showing his tummy, vocalizing, and looking at his brother.”&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;“watched solemnly”というところがミソで、これはミラーリングが起きていないということを言いたいのだろう。共感はしていないけれど、痛がっている兄を笑わせようとしている。これは、何か「いい」感じがするシーンだ。もしかすると、共感をしていないにも関わらず、相手の状況を思いやって行われる行為にこそ、もっとも純粋な何かがあるように僕らは感じるのではあるまいか（逆に言うと、ミラーリングが起きている状況で相手に何かをしてあげたがる人物には、自分の気分を改善するためという動機も見てとってしまうのかもしれない）。&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;ちなみに、ブルームのいくつかの議論の参照枠としてたびたび（その多くはやや批判的に）引用されているサイモン・バロン=コーエンは、日本でも翻訳書が出ている、empathy-system理論で著名な自閉症研究者だが、本書では自閉症についてはほとんど記述がない。共感能力の欠如とサイコパス（この単語もまた議論の余地大いにありだが）、ひいては暴力性の関連について語られる章において、自閉症やアスペルガー障害を持つ人にE = empathy能力が欠けているとしても、（バロン=コーエンが指摘しているように）彼らがモンスターであるわけではない、といったことが書かれる程度である。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Joyce Carol Oates &#x27;Sinners in the Hands of an Angry God&#x27;</title>
            <pubDate>Tue, 15 Oct 2019 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/angrygod/</link>
            <guid>https://kyoheiu.gitlab.io/post/angrygod/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.newyorker.com&#x2F;magazine&#x2F;2019&#x2F;10&#x2F;14&#x2F;sinners-in-the-hands-of-an-angry-god&quot;&gt;Sinners in the Hands of an Angry God&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;舞台はNYから160kmほど離れたところにある街・Hazelton-on-Hudson（作者インタビューによると過去作でも用いている架空の街だそう）。異常気象が続く中、60歳手前の老婦人・Luceにはいつの頃からか、変な匂いがするとすぐに医療用の緑のマスクを付ける習慣ができる。それを夫のAndrewは「過剰反応だ」とか「破滅が近いと大騒ぎしている」と言って喜ばない。夫婦の周りの同世代の友人たちはみな、ガンなどの深刻な病を患っているかすでに死んでいるか、という状況。これをLuceは、地球温暖化に対する「神の罰」だと思う。そんな中、Andrewが久しぶりに友人たちを招いてホームパーティを開こうと言い出す。Luceは、以前友人たちと組んでいたヴァイオリンのカルテットを再結成し、パーティの場でシューベルトの『死と乙女』を披露しようと練習を始める。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;地球温暖化と異様な気候変動を恐れるLuceの心境というのは、20世紀に大量に書かれた核戦争小説のキャラクターのそれに近いように思う。罪を背負った人類、最終戦争、世界の終わり。そもそも西洋文明の根幹にあるキリスト教が、少なくともその原始時代には終末論的世界観をベースにして成立しているから、「終末もの」には一定の感覚的な支持と需要があるのだと思う。21世紀のカタストロフィとは核戦争ではなく、地球温暖化であるというのは時代を読む感覚に優れた作家が持つ切り口だろう。&lt;br &#x2F;&gt;
もちろん20世紀のパラノイアックな小説群とオーツのこの短編は同列には語れない。一番の違いは、Luceの怯えぶりと奇妙な確信ぶりというのは、むしろパラノイアックな小説を綴る筆そのものに見られたような態度で、一方この短編はLuceをあくまで三人称で描き、その心理と行動をつぶさに、時に冷徹に観察しながら進んでいくというところにある。トランペットを吹き、世界の終わりを告げてまわるような間抜けな真似をオーツはしない―実際に地球温暖化が人類の「罪」であるかどうかには判断をくださない。Luceの恐怖心は、筋が通っている部分も、通っていない部分もある。そのことが、彼女と夫の、長年連れ添っているにも関わらずどこか緊張感が漂う関係をある意味で形作っているとも言える。もちろん、この夫婦間の（決してどちらも口にはしない）齟齬を生んでいるのは、気候変動をめぐる態度の違いだけではなく、他にたとえばセックスレスだとか、夫が一人で過ごす時間が長すぎるだとか様々な要素が絡み合っているわけなのだが、それでもLuceの怯えが大きくそこに作用しているのは疑いがない。たとえばこれを、原発をめぐる夫婦間の意見の相違と読み替えてみてもエッセンスは損なわれないだろう。問題なのは、それが本当に恐れるべきものかどうか、ということではなく、何かを極度に恐れる人と大して恐れない人は本当の意味で分かり合えるのか？ということなのだと思う。この人間の本能的な心の動きを観察する物語は、夫婦のあいだのまなざしという養分を得て、メロドラマへと突き進んでいくことになる。&lt;&#x2F;p&gt;
&lt;p&gt;中盤以降は老いた男女のアマチュア音楽活動の歩みが綴られるけれど、Luceの目は常にAndrewを探している。彼が発表の場にいるか、聴いているか、感銘を受けているか。カルテットのメンバーとの間にちらつくフラート。振り絞るかのように熱く演奏されるシューベルト、響き渡る雷鳴。物語はこれでもかというくらいドラマチックに描かれていくが、彼女の心の動きを細部にわたって書き留め続ける筆はあくまでも冷静さを崩さない。どこまでも客観性を突き詰めていけば、その先には対象のグロテスクさが待っている。オーツは分かってやっている。この作品について言えば、冷徹な客観性がもたらすのはLuceたちの感傷的で、しかし切実なメロドラマだ。それはグロテスクだが、愛すべき人間くささも同時に備えている。&lt;br &#x2F;&gt;
何かを恐れる人と恐れない人は本当の意味で分かり合えるのか？　とりあえずの答えを出している最後の１行は、こうした試みの結果生み出された一種異様なテキストとなっていて、ちょっと忘れられそうにない。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Moira McCavana &#x27;No Spanish&#x27;</title>
            <pubDate>Sat, 12 Oct 2019 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/nospanish/</link>
            <guid>https://kyoheiu.gitlab.io/post/nospanish/</guid>
            <description>&lt;p&gt;2019年O.ヘンリー賞受賞作集から、２本め。これまで三分の一ほど読み、おおむね粒揃いの受賞作集だけれど、今のところ抜群にいい。&lt;&#x2F;p&gt;
&lt;p&gt;主人公はスペイン人、ローティーンの女の子。両親、そして7つほど歳の離れた兄と一緒に暮らしている。父親がある日突然「この家ではスペイン語は禁止。バスク語だけ話すこと」と言い出し、彼女の日常は大きく変わっていく。時はフランコ政権真っ只中。バスク語を話すのは違法とされていた時代。何より家族はみなバスク語をまったく話せない。最初は本気にしなかった家族だが、スペイン語を話した兄が父に罰をくらうのを見て、父が真剣なのだと知る主人公。そうはいってもお互いにふざけあって日々を過ごしていたけれど、父が転職し、家族みなで引っ越したことで、濃密なバスク語の世界で生きることになり―。&lt;br &#x2F;&gt;
というのがあらすじ。これだけでもこの短編の面白さが伝わるとよいのだけれど。ちなみにバスク語は、世界で最も習得が困難な言語の一つと言われているそう。&lt;&#x2F;p&gt;
&lt;p&gt;どこか抜けているが独断的な父に振り回され、望まない形で他の言語の習得を強制させられる（しかもネイティブ言語を禁じられて！）―という状況は決してハッピーなものではありえないはずなのだけれど、彼女は深刻に落ち込むことなく、時に面白がりながら日々を生きていく。根っこには父のバスク人、バスク語に対する過剰な肩入れがあるけれど、そこに別に民族の物語が色濃く描写されているわけではなく、（実際のところは推測するしかないのだが）彼女からするとただフランコが気に入らないから、という程度に描かれているのも、この状況を深刻さから救っている一つの要素ではあると思うけれど、それより何よりこの主人公の眼差しだ。彼女のレジリエンスというか、どこかしたたかさも含むまっすぐな瞳に、読者のほうが力をもらえるようなのだ。この状況を、深刻な家族の危機や政治の物語としてある意味安易に解釈するのではなく、あくまでも拡大も縮小もせず、写し取っていく。&lt;br &#x2F;&gt;
引越し先での孤独。ある時から急速に身についてくる言葉。友達との夜の時間。男の子との出会い。そして突然訪れる、恩寵のような出来事…。合間合間のちょっとした事件やエピソードも全部引っくるめて、ぞくっとくるほどみずみずしく、美しい話だ。&lt;&#x2F;p&gt;
&lt;p&gt;そして、今「突然」と書いたけれど、突然なんかではない、とも思う。英語で小説を読んでいると、ある瞬間、からだ全体が文章にぐっと引き付けられることがある。文字通り体が前のめりになり、目は大きく開かれ、文章が突然クリアーに見えてくる（目が悪いのに読書中は眼鏡をかけていないからなおさら）。視界の中の他のものはぼやけ、音は遠ざかり、ただ文章だけ、そういう体験がある。&lt;br &#x2F;&gt;
それはたいてい、何か意外なこと、予想外のことが書かれているときなのたが、それだけではなく、大事なのは、その「予想外」が、実は自分が心の底で待ち望んでいた言葉だ、ということなのだ。驚くとともに、納得もする。そうだ、これが読みたかったんだ…と。&lt;br &#x2F;&gt;
なぜかは分からないけれど、今日本語で小説を読んでも、こういうことはほとんど起こらない。もしかすると、昔はたくさんあったのかもしれない（だからこそ、今もこうやって本を読み続けているのかもしれない）のだが。&lt;br &#x2F;&gt;
そしてこれは小説に限らなくて、映画や音楽といった他の表現芸術でも、感じたことがある。そんな気がする。&lt;&#x2F;p&gt;
&lt;p&gt;ともかく、この短編のラスト付近に起こる出来事はまさにそうした体験を僕にもたらした。こういうことがあると、もう読んだことを忘れられなくなる。もう一回読みたくなる。&lt;&#x2F;p&gt;
&lt;p&gt;作者は93年生まれ。ハーバード大出身で、この短編の初出もHarvard Review。バスク地方を舞台にした短編を書き続け、作品集も出したようなのだけれど、検索してもなかなか情報が出てこない。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Tessa Hadley &#x27;Funny Little Snake&#x27;</title>
            <pubDate>Fri, 11 Oct 2019 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/funnylittlesnake/</link>
            <guid>https://kyoheiu.gitlab.io/post/funnylittlesnake/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B07Q188RRQ&#x2F;&quot;&gt;The O. Henry Prize Stories 100th Anniversary Edition (2019) (The O. Henry Prize Collection)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;O.ヘンリー賞は今年で創設100周年だそうです。巻頭には賞のこれまでの歴史が記されていて興味深い。&lt;br &#x2F;&gt;
この賞の対象となるのはアメリカ・カナダの定期刊行物に掲載された英語のstories。もともとは読者からなるいくつかの委員会が、対象のstoriesを徐々に絞り込んでいき、17本にまでなった段階で最終審査員が１〜３位を選ぶ、というものだった。今では、series editorが20本をまず決め、３人の（自身も作家である）審査員がそれぞれのfavoriteの１本を選ぶ、ということになっている。  favoriteの選考過程では作者は匿名にされるので、今のプロセスになってから16年間で、審査員によって作者が特定されたのは２本しかない、とのこと。&lt;br &#x2F;&gt;
O.ヘンリーの時代から”stories”の形は大きく変わったという。一人称でも二人称でも三人称でもよいし、全編会話でも会話なしでもよいし、１パラグラフで構成されていても、脚本形式でもよい。今やstoriesは開かれた分野となったけれど、いくつかの要素は変わっていない―「物語の中の異なるピースの間に存在する関係性と、始まりと終わりを何がしかの形でつなげようという情熱的な欲求」。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;このFunny Little Snakeは受賞作集の巻頭に置かれており、審査員の１人Lala Vapnyarがfavoriteに選んだ作品。読んでみればそれも納得の、読者を強く惹き込む力を持った１本だと感じる。やや老いた印象を受けるが乱れず明晰な文体。&lt;&#x2F;p&gt;
&lt;p&gt;歴史学の教授の新妻である主人公のValerieは、夫と前妻との間にできた娘のRobynを定期的に預かっている。Valerieはちゃんとした待遇を提供しようと気を張るが、Robynとのコミュニケーションはほとんど成立しない。ある日夫が、仕事があるからと、前妻のもとにRobynを送っていく役目をValerieに押しつけてくる。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;THE CHILD WAS NINE YEARS OLD and couldn’t fasten her own buttons.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;これがこの短編の最初の１文であり、Robynは「人形のように生気がない」こどもとして描写されていく。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Valerie had encouraged her into a bath foamed up with bubbles, she still smelled of something furtive—musty spice from the back of a cupboard. [...] Robyn was miniature, a doll—with a plain, pale, wide face, her temples blue-naked where her hair was strained back, her wide-open gray eyes affronted and evasive and set too far apart.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;Robynはほぼコミュニケーションのとれない、不気味な存在だけれど―もしくはそういう存在であるが故に―、彼女から何か危機がもたらされるような気配はなく、Valerieにとっては”無害”であることもまた確かなので、「そういうこども」としていつのまにか存在感は後退していき、むしろ僕の意識は、中盤までは夫との緊張感あるコミュニケーションのほうに向けられていた。この夫の描写がまたうまい―上流階級に位置しながら他人を見下しがちで、とりわけ女性差別の気が濃厚。コミュニケーションの不在よりは、何かを強いられるコミュニケーションのほうが有害に感じられやすい。&lt;br &#x2F;&gt;
しかし、「そういうこども」でしかなかったRobynは、Valerieが前妻の家に彼女を届けるにいたって、鮮やかにリフレーミングされていく。この印象の変化が、物語の一つの動力であり、Vapnyrは、リフレーミングの過程がある種の罪悪感と責任感を読者にもたらし、その結果、読者は物語そのものに否応なしに巻き込まれていく―と巻末に書いている。なるほど確かに確かに、という感じなのだが、後半〜終盤にかけて、僕としては他の部分がむしろ目についた。&lt;br &#x2F;&gt;
Vapnyarの解釈では、Robynがリフレーミングされる先は「ネグレクトされているこども」ということになる。彼女はどう転んでも愛情豊かに育てられている子ではない。前妻の家の様子でそれはすぐにわかる。だからRobynを「ネグレクトされているこども」としてValerieがとらえるのも、読者が受け止めるのも当然だし、僕ももちろんそういう印象を持った。Robynをこのようにリフレーミングしたとき、「母と子」が物語として浮かび上がってもくる。motherhood―前妻がValerieに投げつける言葉だが、その言葉は少なくともValerieと同じくいらには前妻自身を傷つけているように見える。母親であるというよりはむしろこどものような前妻と、本当には何もわかっていない非当事者のValerieは、実は頼りのならなさという点ではあまり変わらない。RobynがValerieにすがる理由は不確かなものでしかない。暗雲がたちこめたまま去らないような、一種寒々しいエンディングの印象はここから来る。&lt;br &#x2F;&gt;
と、こうまとめたときに、もうちょっとだけ言い尽くされていないことがある、とも思う。&lt;&#x2F;p&gt;
&lt;p&gt;無責任な夫がValerieにRobynを送っていくように頼んだとき（「駅からcabにでも乗せてやればいい」）、夫がRobynの実際を何も知らないことに呆れつつ、Valerieは前妻のことを考える。Valerieは彼女を恐れているが、同時に好奇心も抱いている。夫から悪口しか聞かされない彼女は実際にはどんな人物なのか。この時点で僕の中にふんわりと立ち上った期待感は、Robynとの絆についてのものじゃなく、夫を介して生れるかもしれない前妻との間のシスターフッドについてのものだった。「悪女」の前妻と、手を結んで夫に立ち向かう新妻。こうなると面白いな、と。常に見られる立場、弱い立場でいることを素知らぬ顔をして受け入れ生きようとするValerieはどこかで（無意識に？）本当の紐帯を求めていて－この時点では前妻にそれを（やはり無意識に？）期待したんじゃないだろうか。&lt;br &#x2F;&gt;
でもその期待はあっさりと裏切られる。前妻は手を握り合えるような人間ではなかった。Robynを送り届けた後、Valerieが向かうのは自身の実家。彼女は「こども」として読者の前にはっきりと現れる。その後、特に明確な理由もなく前妻の家に舞い戻ったValerieが、窓の向こうのRobynに見たものは？　「ネグレクトされているこども」だけではなく、自分自身の姿をも見たのではなかっただろうか。&lt;br &#x2F;&gt;
人形を持ってき損ねて落ち込むRobynを慰めようとしてうまくいかないValerieの姿は、Robynと同じくらいの少女に見えなくもない。リフレーミングされるのはRobynだけではなく、主人公Valerieもまた、隠れていたアンハッピーな貌をのぞかせる。あたかも母のように強くあることを選んだのではなく、手を伸ばした先がたまたまこの子であったということ、そしてそれでもその手を離さないことを主人公が選んだということ。この短編はやはりシスターフッドを描いているのではないかと思うのだ。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Weike Wang &#x27;Chemistry&#x27;</title>
            <pubDate>Thu, 10 Oct 2019 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/chemisty/</link>
            <guid>https://kyoheiu.gitlab.io/post/chemisty/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B01M0KOP1P&#x2F;&quot;&gt;Chemistry: A novel&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;主人公は合成化学を研究する大学院生（grad student）の女性で、一緒に住むボーイフレンドが１人、犬が１匹。化学という分野の中で、自分の才能不足を感じる日々。ある日、ラボで作業をしている最中にビーカーを割りまくり、事実上の謹慎処分となる。depression状態の主人公とボーイフレンドの関係が変質していく一方、妊娠・出産した親友は夫との関係をこじらせていく。自分の子供時代や両親から耳にしたエピソードを思い返しながら、彼女は思索をめぐらせる。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;Weike Wangはニューヨーク在住の中国系アメリカ人。Wikipediaによると5歳のとき中国を家族で離れ、オーストラリアやカナダを経て11歳のときアメリカへ。ハーバード大学で化学の学位と公衆衛生の博士号を取得。その後ボストン大学でMFA(Master of Fine Arts)を取得。あとがきでボストン大のwritingの教師へ謝辞を述べているから、きっとcreative writingのクラスをとっていたのだろうと思う。&lt;&#x2F;p&gt;
&lt;p&gt;全体に、中国系移民である両親と、移民２世である主人公の緊張関係が満ちている。客観的に見ても父親の教育方針は相当厳しく冷淡だし、母親の娘への接し方はかなりエキセントリックに感じられるが、反抗らしい反抗を主人公はしたことがない。親子的と呼べるような紐帯はほとんどなく、胃にじんわりと冷たく来るような抑圧的でシビアな回想ばかりだが、それらを少しずつつなげながら、主人公は自分なりのポジションを見出そうとする。この静かな努力の中で、両親の印象が変化していく過程が、とても自然に感じられることには驚かされる。なにかシンプルで単純な、隠されていた真実が明らかになり、印象が180°変わる、というようなドラスティックな筋に頼っていない。&lt;br &#x2F;&gt;
もしくは、頼れない、というほうが正確かもしれない。親子の冷たい関係の土台にあるのは、親世代が経験した移民のリアルだ。簡単には仕事が見つからない。母国でやっていた仕事をそのままやれるわけでもない（主人公の母が、中国流の接客をしていたら気味悪がられてクビになったというエピソードはレイシズムの見えづらさを感じさせる）。そして、母国の親戚とは物理的に距離が離れてしまう。これらは確かにタフな状況で、父と母の関係も荒廃していく。こうしたことが、すべて主人公に影響する。主人公の精神的苦境の原因（の少なくとも一部）は明らかに両親との間の緊張関係なのだが、彼女は「親のせい」にはしない。あるいは、そうするのを保留している。&lt;&#x2F;p&gt;
&lt;p&gt;主人公の子供時代、中国に住む母方の祖父が亡くなり、その葬儀に出席するため家族は中国へ戻る。もうアメリカへは戻らない、自分の母親と暮らす、と泣く母。父はそれを認めない。帰りの飛行機で、主人公は母親にこう言いそうになる。お母さんが中国に戻っても、私は気にしないよ。この話を聞いた主人公のカウンセラーは納得できない様子を見せる。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Why do you defend her? the shrink asks. She doesn’t deserve this kind of loyalty.&lt;br &#x2F;&gt;
Because mothers have parents too? Because they have lives beyond their own hildren?&lt;br &#x2F;&gt;
Because I still want her to be happy.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;最初にこの箇所を読んだときは、主人公の心情をうまく理解できなかったけれど、この小説の主題を正面切って「移民のアイデンティティ」であると認めれば、少しずつその心情が見えてくる気がする。なぜなら、彼女は両親が経験したことを理解できるから。少なくともこの小説の主人公は、移民の両親の疲れた心を―それが彼女自身にハードな子供時代を与えたとしても―なかったことにはできないような２世で、それが彼女の困難そのものであり、また出口にもなる。&lt;br &#x2F;&gt;
こうした２世のアンビバレントな立ち位置は、Wangが次に描いた書いた短編 Omakase でも繰り返し描写される。それはoverthinkingなのか、それともnaturalなのか。周囲が受け入れるべきことなのか、それとも考えすぎさと流す権利のあることなのか。誰がそれを決めるのか。曖昧にしか答え切れない主題を、Wangは変わらず平易な文体で描ききっている。&lt;&#x2F;p&gt;
&lt;hr &#x2F;&gt;
&lt;p&gt;ところでこの小説はまた、恋愛小説としても読める。というかむしろ、２世としての心情を綴るパートよりも、ボーイフレンドのEricに対する、ポジティブなものもネガティブなものも全部含んだカラフルな感情が撒き散らされるパートのほうが、当然心の動きは激しい。ビビッドに胸を打つ文章は、かつて光り輝いていた彼との関係を描写する箇所に集中している。&lt;&#x2F;p&gt;
&lt;p&gt;文体に注目してみる。断片として漂い、流れていく主人公の思考は、それらすべてが現在形で綴られているのがまず目につく。話し言葉にはさすがに別の時制が使われることもあるが、基本的には現在形がベースだ。これは思考が点的である、という印象を読者に持たせる。それはfragmentというよりはむしろmoleculeであり（多用される化学的なエピソードともちろんオーバーラップする）、その周囲にあるvacuumを想像させずにはいない。そしてそれは容易に主人公の状況にリンクしていく。少し乱暴に言ってしまうと、この本で描かれるあらゆる人間関係の通奏低音は、孤独な分子とその結合（は不可能なのか？）、というテーマで、だから、引用される科学的記述がときに必ずしもchemistryでないとしても、このタイトルでなければならないのだと思う。&lt;&#x2F;p&gt;
&lt;p&gt;けれど、現在形がまったく別の効果を生む瞬間もある。胸を打たれるのはそういう瞬間だ。たとえば、主人公とボーイフレンドが過去に足を運んだ、ビートルズを流すレーザーライトショウ。彼はビートルズが好きだが、主人公には知識がない。よく分からないながらも付き合い、音楽を聴く主人公。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;During the show, I get carried away by the lasers. There are so many of them.&lt;br &#x2F;&gt;
A laser is colorful by emission. It is green because it emits green light. It is not like a leaf that is green because it absorbs red light.&lt;br &#x2F;&gt;
Some students have trouble with this—whether the color they perceive is through emission or absorption. Then I tell the student, If you can see the color in the dark, it is its own thing, it is emission. In this way, a green laser is a purer form of color than the world’s greenest leaf.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;現在形でつづられる科学のテキストとは、世界でもっとも揺るぎない「真実」の一つに他ならないから、この小説の中で科学的なエピソードが紹介されるとき、そこには畏敬と圧倒と悲しみと諦めと、美しさが込められている、と思う。&lt;br &#x2F;&gt;
時に真実は美しい。その美しさが、ふたりがかつて見た光の純度と重なり、同時に、真実の輝きの後ろで、ちっぽけなふたりの思い出はそっと遠ざかっていく。&lt;&#x2F;p&gt;
&lt;p&gt;またたとえば、ボーイフレンドがはじめて主人公にプロポーズをしたときのこと。海で打ち上げられる花火を遊歩道から、彼らは見ている。&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Not this one.&lt;br &#x2F;&gt;
Or this one.&lt;br &#x2F;&gt;
Or this one.&lt;br &#x2F;&gt;
The largest one is coming at the end.&lt;br &#x2F;&gt;
And then the barge from which the fireworks launched catches on fire and the show abruptly stops.&lt;br &#x2F;&gt;
This cannot be happening, he says.&lt;br &#x2F;&gt;
So we stay another minute while everyone around us scatters. When the barge is fully consumed by flames and other boats are speeding to its rescue, we have to be evacuated in case the barge explodes.&lt;br &#x2F;&gt;
I say we’ll come back next year, and he says he can’t wait until then. I say we’ll watch another show on TV, and he says he can’t do that either.&lt;br &#x2F;&gt;
I don’t understand until on the train back, in a tunnel, he puts the ring on my knee.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;ほんの瞬間だけ現在形で現前するのは、すでに失われたとわかっている光景。&lt;&#x2F;p&gt;
&lt;p&gt;こうした美しい文章がボーイフレンドとのエピソードに集中しているように思え、そして両親との関係の描写にはそれがわずかばかり足らないように思えるのは、すでに失われたものと、まだ失われてはいないかもしれないものの、ほんのわずかの差ということなのかもしれない。彼女の苦境の出口となるのは明らかに、両親との関係を再定義しようとする彼女のもがきであり、エンディングで示されるボーイフレンドとの関係のとりあえずの決着は、そのもがきが生む副産物に過ぎない、というのも切ない感じがするのだった。&lt;&#x2F;p&gt;
</description>
        </item>
    </channel>
</rss>
