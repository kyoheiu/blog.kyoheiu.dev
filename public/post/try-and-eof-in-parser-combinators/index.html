<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
<title>各パーサーコンビネータにおけるtry&#x2F;eof(endOfInput)の挙動 | tudurikata</title>


  <link rel="shortcut icon" type="image/png" href="&#x2F;images&#x2F;penguin.png">
  <meta name="viewport" content="width=device-width,initial-scale=1">

  
  <link id="stylesheet" rel="stylesheet" type="text/css" href="/dark.css">
  

<script type="text/javascript" src="/js/theme.js"></script>

</head>

<div class="header">
  <div class="site_title">
    <p><a href="/"><img src="https:&#x2F;&#x2F;tudurikata.com&#x2F;images&#x2F;penguin.png"
      alt="tudurikata" width="70" height=auto></a></p>
    <p><a href="/">&nbsp;tudurikata</a></p>
  </div>
  <div class="menu">
    <a href="/post">>archives</a>
    &nbsp;<a href="/about">>about</a>

    

  </div>
</div>

<body onload = "getTheme()">
  <section class="section">
    <div class="container">
      
<p>
  <div class="title_postpage">各パーサーコンビネータにおけるtry&#x2F;eof(endOfInput)の挙動</div>
</p>
<p>
  <div class="date_postpage">2021-07-31</div>
  <div class="taxonomies_postpage">
  
      
      <a href="https://tudurikata.com/categories/code/">/code</a>
      
  
  
      
      &emsp;<a href="https://tudurikata.com/tags/haskell/">#Haskell</a>
      
      &emsp;<a href="https://tudurikata.com/tags/megaparsec/">#Megaparsec</a>
      
      &emsp;<a href="https://tudurikata.com/tags/attoparsec/">#Attoparsec</a>
      
      &emsp;<a href="https://tudurikata.com/tags/parsec/">#Parsec</a>
      
  
  </div>
</p>

<p>
  <p><a href="https://adventofcode.com/2020/day/19">Advent of Code 2020のDay 19</a>を解いていて、複数パーサーの選択でしばらくつまずいていたのでメモ。</p>
<h3 id="tl-dr">TL;DR</h3>
<ul>
<li>MegaparsecおよびParsecでは、tryでくるんだパーサー内でeofを使うと正常に動かない場合がある？</li>
<li>Attoparsecではchoice内でも問題なくendOfInputが動く。</li>
</ul>
<h3 id="tekisutowozhi-he-xing-norisutonipasusuru">テキストを直和型のリストにパースする</h3>
<p>Day 19では次のようなテキストを適切にパースすることが求められる。</p>
<pre><code>0: 4 1 5
1: 2 3 | 3 2
2: 4 4 | 5 5
3: 4 5 | 5 4
4: &quot;a&quot;
5: &quot;b&quot;
</code></pre>
<p>これを、ひとまず次のような型としてパースしたい。</p>
<pre><code>data Rule = Zero [Int]
          | Pairs Int [(Int,Int)]
          | Key Int Char
          deriving Show

-- expected result
[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]
</code></pre>
<ul>
<li>０から始まる行は「特殊ルール」として、Zero [Int]で拾う。</li>
<li>それ以外の行は、
<ul>
<li>数字と&quot;|&quot;のみの行についてはPairsで、</li>
<li>アルファベットが含まれる行はKeyで拾う。</li>
</ul>
</li>
</ul>
<h3 id="magaparsec-trydeshi-bai-sitekurenai">Magaparsec - <code>try</code>で失敗してくれない？</h3>
<p>最初に使ったのはMegaparsec。このソースコードから始めよう。</p>
<pre data-lang="hs" class="language-hs "><code class="language-hs" data-lang="hs">import qualified Data.Map.Strict as M
import Text.Megaparsec
import Text.Megaparsec.Char
import qualified Data.Text as T
import Data.Void
import Data.Either (rights)

type Parser = Parsec Void String

readInt x = read x :: Int

data Rule = Zero [Int]
          | Pairs Int [(Int,Int)]
          | Key Int Char
          deriving Show

zero :: Parser Rule
zero = do
  string &quot;0: &quot;
  list &lt;- sepBy1 (many alphaNumChar) (char &#x27; &#x27;)
  return $ Zero (map readInt list)

pair :: Parser (Int,Int)
pair = do
  y &lt;- many digitChar
  char &#x27; &#x27;
  z &lt;- many digitChar
  return (readInt y, readInt z)

pairs :: Parser Rule
pairs = do
  n &lt;- readInt &lt;$&gt; many alphaNumChar
  string &quot;: &quot;
  p &lt;- sepBy1 pair (string &quot; | &quot;)
  return $ Pairs n p

key :: Parser Rule
key = do
  n &lt;- readInt &lt;$&gt; many alphaNumChar
  string &quot;: \&quot;&quot;
  c &lt;- letterChar
  char &#x27;\&quot;&#x27;
  return $ Key n c

rules = try zero &lt;|&gt; key &lt;|&gt; pairs

main = readFile &quot;day19e.txt&quot; &gt;&gt;= print . rights . map (parse rules &quot;&quot;) . lines
</code></pre>
<p><code>cabal repl</code>で<code>main</code>を実行すると、結果はこうなる。</p>
<pre><code>[Zero [4,1,5],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]
</code></pre>
<p><code>Data.Either</code>の<code>rights</code>で強制的に<code>Right</code>のみを抽出しているので分かりにくいが、２〜４行めはパースに失敗している。ちなみにエラーメッセージはかなり難解。</p>
<pre><code>Right (Zero [4,1,5]),Left (ParseErrorBundle {bundleErrors = TrivialError 1 (Just (Tokens (&#x27;:&#x27; :| &quot; 2&quot;))) (fromList [Tokens (&#x27;:&#x27; :| &quot; \&quot;&quot;),Label (&#x27;a&#x27; :| &quot;lphanumeric character&quot;)]) :| [], bundlePosState = PosState {pstateInput = &quot;1: 2 3 | 3 2&quot;, pstateOffset = 0, pstateSourcePos = SourcePos {sourceName = &quot;&quot;, sourceLine = Pos 1, sourceColumn = Pos 1}, pstateTabWidth = Pos 8, pstateLinePrefix = &quot;&quot;}}),Left (ParseErrorBundle {bundleErrors = TrivialError 1 (Just (Tokens (&#x27;:&#x27; :| &quot; 4&quot;))) (fromList [Tokens (&#x27;:&#x27; :| &quot; \&quot;&quot;),Label (&#x27;a&#x27; :| &quot;lphanumeric character&quot;)]) :| [], bundlePosState = PosState {pstateInput = &quot;2: 4 4 | 5 5&quot;, pstateOffset = 0, pstateSourcePos = SourcePos {sourceName = &quot;&quot;, sourceLine = Pos 1, sourceColumn = Pos 1}, pstateTabWidth = Pos 8, pstateLinePrefix = &quot;&quot;}}),Left (ParseErrorBundle {bundleErrors = TrivialError 1 (Just (Tokens (&#x27;:&#x27; :| &quot; 4&quot;))) (fromList [Tokens (&#x27;:&#x27; :| &quot; \&quot;&quot;),Label (&#x27;a&#x27; :| &quot;lphanumeric character&quot;)]) :| [], bundlePosState = PosState {pstateInput = &quot;3: 4 5 | 5 4&quot;, pstateOffset = 0, pstateSourcePos = SourcePos {sourceName = &quot;&quot;, sourceLine = Pos 1, sourceColumn = Pos 1}, pstateTabWidth = Pos 8, pstateLinePrefix = &quot;&quot;}}),Right (Key 4 &#x27;a&#x27;),Right (Key 5 &#x27;b&#x27;)]
</code></pre>
<p>色々と試行錯誤した結果わかったのは、<code>try</code>でくるんでいるからといって必ず適切なパーサーを選択してくれるわけではない（適切に選択してもらうためには工夫が必要）ということ。</p>
<p>たとえば２行目の<code>1: 2 3 | 3 2</code>のみをパースしてみると、</p>
<pre><code>*Main&gt; parseTest rules &quot;1: 2 3 | 3 2&quot;
1:2:
  |
1 | 1: 2 3 | 3 2
  |  ^^^
unexpected &quot;: 2&quot;
expecting &quot;: &quot;&quot; or alphanumeric character
</code></pre>
<p><code>try</code>でくるんでいるから最終的にはpairsを使ってパースしてくれるはずなのに、そうなっていない。<br />
ちなみに<code>pairs</code>単体でパースすると、</p>
<pre><code>*Main&gt; parseTest pairs &quot;1: 2 3 | 3 2&quot;
Pairs 1 [(2,3),(3,2)]
</code></pre>
<p>となって正しい結果が出るので、<code>pairs</code>自体にミスがあるわけではなさそうだ。</p>
<p><code>rules</code>はまず<code>zero</code>をトライするが、<code>string &quot;0: &quot;</code>にマッチしないので失敗し、backtrackが発生する。<br />
次に<code>key</code>をトライする。そうすると、最初の<code>many alphaNumChar</code>は成功するが、次の<code>string &quot;: \&quot;&quot;</code>は失敗するのでまたbacktrackが発生する…はずなのだがそうならず、パースは失敗に終わる。</p>
<h3 id="tryyi-jiang-noxuan-ze-zhi-noshun-fan-nanoka"><code>try</code>以降の選択肢の順番なのか？</h3>
<p>最初に、<code>try</code>のくるみ方に問題があるのかもしれないと考えて、<code>try</code>のあとを色々と変えてみた。すると実際、<code>rules = try key &lt;|&gt; zero &lt;|&gt; pairs</code>とした場合は、</p>
<pre><code>[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]
</code></pre>
<p>となり成功している。</p>
<p>さらに、<code>rules = try key &lt;|&gt; pairs &lt;|&gt; zero</code>の場合。</p>
<pre><code>[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]
</code></pre>
<p>一見成功しているように見えるが、第１行めが<code>Zero</code>ではなく<code>Pairs</code>でのパースになってしまっているので間違っている。</p>
<p><code>zero</code>, <code>pairs</code>, <code>key</code>の順番を入れ替えて試した結果は以下の通り。</p>
<table><thead><tr><th align="left">order</th><th align="left">result</th><th align="center">T/F</th></tr></thead><tbody>
<tr><td align="left"><code>zero key pairs</code></td><td align="left"><code>[Zero [4,1,5],Key 4 'a',Key 5 'b']</code></td><td align="center">F</td></tr>
<tr><td align="left"><code>zero pairs key</code></td><td align="left"><code>[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)]]</code></td><td align="center">F</td></tr>
<tr><td align="left"><code>pairs zero key</code></td><td align="left"><code>[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 'a',Key 5 'b']</code></td><td align="center">F</td></tr>
<tr><td align="left"><code>pairs key zero</code></td><td align="left"><code>[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 'a',Key 5 'b']</code></td><td align="center">F</td></tr>
<tr><td align="left"><code>key zero pairs</code></td><td align="left"><code>[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 'a',Key 5 'b']</code></td><td align="center">T</td></tr>
<tr><td align="left"><code>key pairs zero</code></td><td align="left"><code>[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 'a',Key 5 'b']</code></td><td align="center">F</td></tr>
</tbody></table>
<p>このあたりで薄々ストーリーが見えてくる。<code>zero</code>で拾いたいのに<code>pairs</code>になってしまっているのは、<code>0: 4 1 5</code>で言うと&quot;1&quot;までは<code>pairs</code>で拾えてしまえることがまず発端になっている。それだけなら残りを失敗するのでいいじゃないか、となりそうだが、途中でパースが止まっても成功扱いとなり、次の行に進んでしまう。</p>
<p>実際、</p>
<pre data-lang="hs" class="language-hs "><code class="language-hs" data-lang="hs">pairs :: Parser Rule
pairs = do
  n &lt;- readInt &lt;$&gt; many alphaNumChar
  string &quot;: &quot;
  p &lt;- sepBy pair (string &quot; | &quot;)
  return $ Pairs n p
</code></pre>
<p>と、<code>sepBy1</code>から<code>sepBy</code>にしてみると、結果は</p>
<pre><code>[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Pairs 4 [],Pairs 5 []]
</code></pre>
<p>となって最後の２行が<code>pairs</code>で拾われてしまっていることがわかる。</p>
<h3 id="megaparsecdenoeofnoju-dong">Megaparsecでのeofの挙動</h3>
<p><code>4: &quot;a&quot;</code>が<code>pairs</code>ではなく<code>key</code>で拾うべき行だということをプログラムに伝えるには、<code>try</code>以降のパーサーの順番をあれこれいじるよりも<code>eof</code>を使えばよいのではないか、と思いつき、以下のようにしてみる。</p>
<pre data-lang="hs" class="language-hs "><code class="language-hs" data-lang="hs">zero :: Parser Rule
zero = do
  string &quot;0: &quot;
  list &lt;- sepBy1 (many alphaNumChar) (char &#x27; &#x27;)
  eof
  return $ Zero (map readInt list)

pair :: Parser (Int,Int)
pair = do
  y &lt;- readInt &lt;$&gt; many alphaNumChar
  char &#x27; &#x27;
  z &lt;- readInt &lt;$&gt; many alphaNumChar
  return (y,z)

pairs :: Parser Rule
pairs = do
  n &lt;- readInt &lt;$&gt; many alphaNumChar
  string &quot;: &quot;
  p &lt;- sepBy1 pair (string &quot; | &quot;)
  eof
  return $ Pairs n p

key :: Parser Rule
key = do
  n &lt;- readInt &lt;$&gt; many alphaNumChar
  string &quot;: \&quot;&quot;
  c &lt;- letterChar
  char &#x27;\&quot;&#x27;
  eof
  return $ Key n c
</code></pre>
<p>しかし結果は変わらず、</p>
<pre><code>-- try zero &lt;|&gt; pairs &lt;|&gt; key
[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)]]
</code></pre>
<p>入力の終了にのみマッチするはずの<code>eof</code>が動いていない。</p>
<p>念のため、テストパーサーを書いてみるとこちらはちゃんと機能する。</p>
<pre><code>test :: Parser String
test = do
  s &lt;- many alphaNumChar
  eof
  return s

---

*Main&gt; parseTest test &quot;aaa&quot;
&quot;aaa&quot;
*Main&gt; parseTest test &quot;aaa111&quot;
&quot;aaa111&quot;
*Main&gt; parseTest test &quot;aaa111+++&quot;
1:7:
  |
1 | aaa111+++
  |       ^
unexpected &#x27;+&#x27;
expecting alphanumeric character or end of input
</code></pre>
<h3 id="attoparsecdenoju-dong">Attoparsecでの挙動</h3>
<p>つまり、<code>try</code>でくるんだパーサーにおいて<code>eof</code>がちゃんと動いていないのではないか？ということだ。<br />
どこかのコードが間違っている可能性も十分あるし、ソースコードを読んでいないのでMegaparsecの調査としてはここまでなのだが、本来であれば、<code>try</code>以降のパーサーの順序は極力考慮せず組み立てられるのが理想…だと思うので、これは困る。ちなみに、後に検証してみたところ、Parsecの<code>try</code>/<code>eof</code>でも同じ問題が発生する。</p>
<p>そこで、試しにAttoparsecを使ってみるとこちらはうまくいった。</p>
<pre data-lang="hs" class="language-hs "><code class="language-hs" data-lang="hs">import Data.Attoparsec.Text
import qualified Data.Text as T
import qualified Data.Text.IO as TIO
import Data.Either (rights)

readInt x = read x :: Int

data Rule = Zero [Int]
          | Pairs Int [(Int,Int)]
          | Key Int Char
          deriving Show

zero :: Parser Rule
zero = do
  string &quot;0: &quot;
  list &lt;- many1 digit `sepBy1` char &#x27; &#x27;
  endOfInput
  return $ Zero (map readInt list)

pair :: Parser (Int,Int)
pair = do
  x &lt;- readInt &lt;$&gt; many1 digit
  space
  y &lt;- readInt &lt;$&gt; many1 digit
  return (x,y)

pairs :: Parser Rule
pairs = do
  n &lt;- readInt &lt;$&gt; many1 digit
  string &quot;: &quot;
  p &lt;- sepBy1 pair (string &quot; | &quot;)
  endOfInput
  return $ Pairs n p

key :: Parser Rule
key = do
  n &lt;- readInt &lt;$&gt; many1 digit
  string &quot;: \&quot;&quot;
  c &lt;- letter
  char &#x27;\&quot;&#x27;
  endOfInput
  return $ Key n c

rules = choice [pairs, key, zero]

main = TIO.readFile &quot;day19e.txt&quot; &gt;&gt;= print . rights . map (parseOnly rules) . T.lines

---

*Main&gt; main
[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]
</code></pre>
<p>もちろん、<code>choice</code>以降のリスト内の順序をどのパターンにしても、結果は変わらなかった。</p>
<p>ちなみに各パーサーの<code>endOfInput</code>を外すと、</p>
<pre><code>-- rules = choice [pairs, key, zero]
[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &quot;a&quot;,Key 5 &quot;b&quot;]
</code></pre>
<p>となって１行目を<code>pairs</code>で拾ってしまっているので、やっぱり<code>endOfInput</code>が機能していることがわかる。</p>
<p>コード自体はほぼ変わらない。主な変更点としては、</p>
<table><thead><tr><th align="center">Megaparsec</th><th align="center">Attoparsec</th></tr></thead><tbody>
<tr><td align="center"><code>try</code></td><td align="center"><code>choice</code></td></tr>
<tr><td align="center"><code>eof</code></td><td align="center"><code>endOfInput</code></td></tr>
</tbody></table>
<p>まず１点め、<code>try</code>でなく<code>choice</code>を使うというのは、Attoparsecがデフォルトで失敗時backtrackをする仕様のためで、これは素晴らしい（<code>try</code>も実装されているが、これはParsecとの互換性のためと<a href="https://hackage.haskell.org/package/attoparsec-0.14.1/docs/Data-Attoparsec-ByteString.html#v:try">明記されている</a>）。<br />
そしてMegaparsecの<code>eof</code>とAttoparsecの<code>endOfInput</code>は、どうやら局所的に違う挙動をするらしい。（MegaparsecとParsecがこの点で同じ動きをしたのは、MegaparsecがParsecのフォークだからかもしれない）</p>
<p>同じようなディテールで頭を悩ませている人がいたら、参考になれば幸いです。</p>

</p>




    </div>
  </section>
</body>

<div class="footer">
  <a href="/">tudurikata</a>&emsp;&copy; Kyohei Uto<br>
  powered by <a href="https://www.getzola.org/">Zola</a>, theme <a href="https://github.com/kyoheiu/emily_zola_theme">emily</a>.
</div>

</html>