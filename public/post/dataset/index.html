<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
<title>Haskellで種類の数を数える（重複の削除） | tudurikata</title>


  <link rel="shortcut icon" type="image/png" href="&#x2F;images&#x2F;penguin.png">
  <meta name="viewport" content="width=device-width,initial-scale=1">

  
  <link id="stylesheet" rel="stylesheet" type="text/css" href="/dark.css">
  

<script type="text/javascript" src="/js/theme.js"></script>

</head>

<div class="header">
  <div class="site_title">
    <p><a href="/"><img src="https:&#x2F;&#x2F;tudurikata.com&#x2F;images&#x2F;penguin.png"
      alt="tudurikata" width="70" height=auto></a></p>
    <p><a href="/">&nbsp;tudurikata</a></p>
  </div>
  <div class="menu">
    <a href="/post">>archives</a>
    &nbsp;<a href="/about">>about</a>

    

  </div>
</div>

<body onload = "getTheme()">
  <section class="section">
    <div class="container">
      
<p>
  <div class="title_postpage">Haskellで種類の数を数える（重複の削除）</div>
</p>
<p>
  <div class="date_postpage">2020-05-01</div>
  <div class="taxonomies_postpage">
  
      
      <a href="https://tudurikata.com/categories/code/">/code</a>
      
  
  
      
      &emsp;<a href="https://tudurikata.com/tags/haskell/">#Haskell</a>
      
  
  </div>
</p>

<p>
  <p>複数の要素を扱うための基礎的なライブラリをいろいろテストしてみる題材として、こちらの問題を使用させてもらう。</p>
<p>At Coder abc164 C - gacha </p>
<p>https://atcoder.jp/contests/abc164/tasks/abc164_c</p>
<blockquote>
<p>実行時間制限: 2 sec / メモリ制限: 1024 MB
配点 : 300点
問題文
くじ引きをN回行い、i回目には種類が文字列Siで表される景品を手に入れました。
何種類の景品を手に入れましたか？</p>
<p>制約
1 &lt;= N &lt;= 2*(10^5)
Siは英小文字のみからなり、長さは1以上10以下</p>
</blockquote>
<p>たとえば入力が</p>
<pre><code>3
apple
orange
apple
</code></pre>
<p>の場合は、appleとorangeの２種類を入手することになるので、正解の出力は2となる。</p>
<p>結局のところ、「種類の数」をどう定義するか（Haskellではどう定義できるか）を考えるわけだが、</p>
<ol>
<li>ひとつひとつの要素が、すでにあるリストに含まれていないかを、再帰関数でチェックしていった結果生成されるリストのlength</li>
<li>要素のかたまりを、同じ要素のかたまりに分けたときの、そのかたまりの数</li>
</ol>
<p>たとえばこういったふうにおくことができると思う。</p>
<h2 id="zai-gui-guan-shu-dejie-ku">再帰関数で解く</h2>
<h3 id="risutowoyong-itazai-gui-guan-shu">リストを用いた再帰関数</h3>
<p>まずリストで再帰関数を作ったバージョン。</p>
<pre data-lang="hs" class="language-hs "><code class="language-hs" data-lang="hs">--TLE
import Control.Monad

delDupe :: [String] -&gt; [String] -&gt; [String]
delDupe [] _ = []
delDupe (x:xs) lst
    | x `notElem` lst = x : delDupe xs (x : lst)
    | otherwise       = delDupe xs lst

main = do
    n &lt;- readLn
    s &lt;- replicateM n getLine
    print $ length $ delDupe s []
</code></pre>
<p><code>delDupe</code>は、与えられるリストを<code>(x:xs)</code>とし、重複がなければ<code>x</code>を第二引数の<code>lst</code>に加えつつ、<code>x</code>を含むリストを返す再帰関数。
しかしこれでは遅く、18の入力のうち７つがTLEとなってしまう。</p>
<h3 id="nubnozheng-ti">nubの正体</h3>
<p>あとで気づいたのだが、Preludeにはリストの重複を削除する関数<code>nub</code>が標準でついているので、次のように書けることは書ける。</p>
<pre data-lang="hs" class="language-hs "><code class="language-hs" data-lang="hs">import Control.Monad

main = do
    n &lt;- readLn
    s &lt;- replicateM n getLine
    print $ length $ nub s
</code></pre>
<p>が、これは実は最初の「再帰での重複チェック→新たなリストの生成」と実行時間・メモリ使用量ともに変わらなかった。Preludeの<code>nub</code>の定義はこちら。</p>
<p>https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.OldList.html#nub</p>
<pre data-lang="hs" class="language-hs "><code class="language-hs" data-lang="hs">-- | &#x2F;O(n^2)&#x2F;. The &#x27;nub&#x27; function removes duplicate elements from a list.
-- In particular, it keeps only the first occurrence of each element.
-- (The name &#x27;nub&#x27; means \`essence\&#x27;.)
-- It is a special case of &#x27;nubBy&#x27;, which allows the programmer to supply
-- their own equality test.
--
-- &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
-- [1,2,3,4,5]
nub                     :: (Eq a) =&gt; [a] -&gt; [a]
nub                     =  nubBy (==)

-- | The &#x27;nubBy&#x27; function behaves just like &#x27;nub&#x27;, except it uses a
-- user-supplied equality predicate instead of the overloaded &#x27;==&#x27;
-- function.
--
-- &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
-- [1,2,6]
nubBy                   :: (a -&gt; a -&gt; Bool) -&gt; [a] -&gt; [a]
#if defined(USE_REPORT_PRELUDE)
nubBy eq []             =  []
nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -&gt; not (eq x y)) xs)
#else
-- stolen from HBC
nubBy eq l              = nubBy&#x27; l []
  where
    nubBy&#x27; [] _         = []
    nubBy&#x27; (y:ys) xs
       | elem_by eq y xs = nubBy&#x27; ys xs
       | otherwise       = y : nubBy&#x27; ys (y:xs)
</code></pre>
<p>これは最初に作った再帰関数そのものだから、結果が同じになって当然なのだった。</p>
<h2 id="sortsitemiru">sortしてみる</h2>
<h3 id="sortsitegroup-risuto">sortしてgroup（リスト）</h3>
<p>そこで２つめの、<code>sort</code>して重複をまとめる方法。
まずはリストを用いると、このようになる。</p>
<pre data-lang="hs" class="language-hs "><code class="language-hs" data-lang="hs">--AC
import Control.Monad
import Data.List as List

main = do
    n &lt;- readLn
    s &lt;- replicateM n getLine
    print $ length . group $ List.sort s
</code></pre>
<p>Data.Listの<code>sort</code>関数をかませたリストに、隣接する同要素をリスト内リストにまとめる<code>group</code>関数をさらにかませてリスト内要素の長さをとるという手順。
かなり泥臭いやり方だが、再帰や<code>nub</code>よりも速いというのはちょっとおもしろい。</p>
<h3 id="data-vectornouniqguan-shu-woyong-iru">Data.Vectorのuniq関数を用いる</h3>
<p>リスト以外のデータ構造ではどうだろう。<br />
まずData.Vectorから。普通に入門書を読んでいるだけだとまず遭遇しないライブラリだが、海外のQ&amp;AサイトではSequenceとどっちがいいの、といった質問でたまに見かける名前だ。</p>
<p>Data.Vector<br />
https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector.html</p>
<p>これはポリフォーミックなarrayで、リスト操作とarray操作のいいとこどりをしたものである、とHackageでは説明されている。
一通りの標準的な関数は装備されているが、ここで用いたいのは<code>uniq</code>関数。</p>
<pre data-lang="hs" class="language-hs "><code class="language-hs" data-lang="hs">uniq :: Eq a =&gt; Vector a -&gt; Vector a
</code></pre>
<p>隣接した同じ要素を<code>drop</code>できるものだが、「隣接している」ことが条件なのでsortedが前提となる。
そこで<code>sort</code>関数と組み合わせて次のようにする。</p>
<pre data-lang="hs" class="language-hs "><code class="language-hs" data-lang="hs">--AC
import Control.Monad
import qualified Data.Vector as V
import qualified Data.List as L

main = do
    n &lt;- readLn
    s &lt;- replicateM n getLine
    print $ length . V.uniq . V.fromList $ L.sort s
</code></pre>
<p>これでも一応問題はクリアだが、実はリストによる<code>group . sort</code>のほうが若干早いということも分かった。
感覚的には必要のない重複を<code>drop</code>できる<code>uniq</code>関数のほうがmake senseではあるのだけれど、<code>V.fromList</code>でO(n)かかってしまっているので致し方ないというところだろうか。</p>
<h2 id="data-setnosizeguan-shu">Data.Setのsize関数</h2>
<p>もうひとつ、Data.Setを見てみる。その名の通り、集合論をベースにした、同型の要素のSetを扱えるライブラリだ。</p>
<p>Data.Set<br />
https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Set.html</p>
<p>このライブラリが楽しいのは、<code>Set.fromList</code>でリストからSetを生成する過程で、重複要素が自動的に<code>drop</code>される点。この自動<code>drop</code>がいかにも自然に感じられるところがmake senseだ。<br />
Data.Setを用いたコードは次のようになる。</p>
<pre data-lang="hs" class="language-hs "><code class="language-hs" data-lang="hs">--AC
import Control.Monad
import qualified Data.Set as Set
 
main = do
    n &lt;- readLn
    s &lt;- replicateM n getLine
    print $ Set.size $ Set.fromList s
</code></pre>
<p><code>Set.size</code>はリストでいう<code>length</code>だが、これはO(1)。<br />
実行結果も、リスト版<code>group . sort</code>と大差がつくわけではないものの、最速。<br />
集合論的な発想を武器にできれば、色々な場面でかなり効率的にデータ処理ができそうな予感がする。</p>

</p>




    </div>
  </section>
</body>

<div class="footer">
  <a href="/">tudurikata</a>&emsp;&copy; Kyohei Uto<br>
  powered by <a href="https://www.getzola.org/">Zola</a>, theme <a href="https://github.com/kyoheiu/emily_zola_theme">emily</a>.
</div>

</html>