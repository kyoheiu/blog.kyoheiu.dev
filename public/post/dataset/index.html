<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <title>tudurikata</title>
  <link rel="stylesheet" href="https:&#x2F;&#x2F;tudurikata.com&#x2F;main.css">
  <link rel="shortcut icon" type="image/svg+xml" href="&#x2F;images&#x2F;penguin.svg">
  <meta name="viewport" content="width=device-width,initial-scale=1">
 
  

</head>

<div class="header">
  <p><a href="/"><img src="https:&#x2F;&#x2F;tudurikata.com&#x2F;images&#x2F;penguin.svg" alt="tudurikata" width="50" height="50"></a></p>
  <div class="site_title">
    <a href="/">&thinsp;tudurikata</a>
  </div>
  <div class="menu">
    <a href="/post">>archives</a>
    &nbsp;<a href="/about">>about</a>
  </div>
</div>

<body>
  <section class="section">
    <div class="container">
      
<h1 class="title">
  Haskellで種類の数を数える（重複の削除）
</h1>
<p class="subtitle"><strong>2020-05-01</strong></p>
<p><p>複数の要素を扱うための基礎的なライブラリをいろいろテストしてみる題材として、こちらの問題を使用させてもらう。</p>
<p>At Coder abc164 C - gacha </p>
<p>https://atcoder.jp/contests/abc164/tasks/abc164_c</p>
<blockquote>
<p>実行時間制限: 2 sec / メモリ制限: 1024 MB
配点 : 300点
問題文
くじ引きをN回行い、i回目には種類が文字列Siで表される景品を手に入れました。
何種類の景品を手に入れましたか？</p>
<p>制約
1 &lt;= N &lt;= 2*(10^5)
Siは英小文字のみからなり、長さは1以上10以下</p>
</blockquote>
<p>たとえば入力が</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#c0c5ce;">3
apple
orange
apple
</span></code></pre>
<p>の場合は、appleとorangeの２種類を入手することになるので、正解の出力は2となる。</p>
<p>結局のところ、「種類の数」をどう定義するか（Haskellではどう定義できるか）を考えるわけだが、</p>
<ol>
<li>ひとつひとつの要素が、すでにあるリストに含まれていないかを、再帰関数でチェックしていった結果生成されるリストのlength</li>
<li>要素のかたまりを、同じ要素のかたまりに分けたときの、そのかたまりの数</li>
</ol>
<p>たとえばこういったふうにおくことができると思う。</p>
<h2 id="zai-gui-guan-shu-dejie-ku">再帰関数で解く</h2>
<h3 id="risutowoyong-itazai-gui-guan-shu">リストを用いた再帰関数</h3>
<p>まずリストで再帰関数を作ったバージョン。</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#65737e;">--TLE
</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Control.Monad

</span><span style="color:#8fa1b3;">delDupe </span><span style="color:#b48ead;">::</span><span style="color:#c0c5ce;"> [</span><span style="color:#b48ead;">String</span><span style="color:#c0c5ce;">] </span><span style="color:#b48ead;">-&gt;</span><span style="color:#c0c5ce;"> [</span><span style="color:#b48ead;">String</span><span style="color:#c0c5ce;">] </span><span style="color:#b48ead;">-&gt;</span><span style="color:#c0c5ce;"> [</span><span style="color:#b48ead;">String</span><span style="color:#c0c5ce;">]
delDupe </span><span style="color:#d08770;">[]</span><span style="color:#c0c5ce;"> _ = </span><span style="color:#d08770;">[]
</span><span style="color:#c0c5ce;">delDupe (x:xs) lst
    | x </span><span style="color:#8fa1b3;">`</span><span style="color:#c0c5ce;">notElem</span><span style="color:#8fa1b3;">`</span><span style="color:#c0c5ce;"> lst = x : delDupe xs (x : lst)
    | otherwise       = delDupe xs lst

main = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">    n &lt;- readLn
    s &lt;- replicateM n getLine
    print $ length $ delDupe s </span><span style="color:#d08770;">[]
</span></code></pre>
<p><code>delDupe</code>は、与えられるリストを<code>(x:xs)</code>とし、重複がなければ<code>x</code>を第二引数の<code>lst</code>に加えつつ、<code>x</code>を含むリストを返す再帰関数。
しかしこれでは遅く、18の入力のうち７つがTLEとなってしまう。</p>
<h3 id="nubnozheng-ti">nubの正体</h3>
<p>あとで気づいたのだが、Preludeにはリストの重複を削除する関数<code>nub</code>が標準でついているので、次のように書けることは書ける。</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Control.Monad

main = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">    n &lt;- readLn
    s &lt;- replicateM n getLine
    print $ length $ nub s
</span></code></pre>
<p>が、これは実は最初の「再帰での重複チェック→新たなリストの生成」と実行時間・メモリ使用量ともに変わらなかった。Preludeの<code>nub</code>の定義はこちら。</p>
<p>https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.OldList.html#nub</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#65737e;">-- | /O(n^2)/. The &#39;nub&#39; function removes duplicate elements from a list.
-- In particular, it keeps only the first occurrence of each element.
-- (The name &#39;nub&#39; means \`essence\&#39;.)
-- It is a special case of &#39;nubBy&#39;, which allows the programmer to supply
-- their own equality test.
--
-- &gt;&gt;&gt; nub [1,2,3,4,3,2,1,2,4,3,5]
-- [1,2,3,4,5]
</span><span style="color:#8fa1b3;">nub                     </span><span style="color:#b48ead;">::</span><span style="color:#c0c5ce;"> (</span><span style="color:#b48ead;">Eq </span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">) </span><span style="color:#b48ead;">=&gt;</span><span style="color:#c0c5ce;"> [</span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">] </span><span style="color:#b48ead;">-&gt;</span><span style="color:#c0c5ce;"> [</span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">]
nub                     =  nubBy </span><span style="color:#8fa1b3;">(==)

</span><span style="color:#65737e;">-- | The &#39;nubBy&#39; function behaves just like &#39;nub&#39;, except it uses a
-- user-supplied equality predicate instead of the overloaded &#39;==&#39;
-- function.
--
-- &gt;&gt;&gt; nubBy (\x y -&gt; mod x 3 == mod y 3) [1,2,4,5,6]
-- [1,2,6]
</span><span style="color:#8fa1b3;">nubBy                   </span><span style="color:#b48ead;">::</span><span style="color:#c0c5ce;"> (</span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; Bool</span><span style="color:#c0c5ce;">) </span><span style="color:#b48ead;">-&gt;</span><span style="color:#c0c5ce;"> [</span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">] </span><span style="color:#b48ead;">-&gt;</span><span style="color:#c0c5ce;"> [</span><span style="color:#bf616a;">a</span><span style="color:#c0c5ce;">]
#if defined(</span><span style="color:#d08770;">USE_REPORT_PRELUDE</span><span style="color:#c0c5ce;">)
nubBy eq </span><span style="color:#d08770;">[]             </span><span style="color:#c0c5ce;">=  </span><span style="color:#d08770;">[]
</span><span style="color:#c0c5ce;">nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -&gt; not (eq x y)) xs)
#else
</span><span style="color:#65737e;">-- stolen from HBC
</span><span style="color:#c0c5ce;">nubBy eq l              = nubBy&#39; l </span><span style="color:#d08770;">[]
  </span><span style="color:#b48ead;">where
</span><span style="color:#c0c5ce;">    nubBy&#39; </span><span style="color:#d08770;">[]</span><span style="color:#c0c5ce;"> _         = </span><span style="color:#d08770;">[]
</span><span style="color:#c0c5ce;">    nubBy&#39; (y:ys) xs
       | elem_by eq y xs = nubBy&#39; ys xs
       | otherwise       = y : nubBy&#39; ys (y:xs)
</span></code></pre>
<p>これは最初に作った再帰関数そのものだから、結果が同じになって当然なのだった。</p>
<h2 id="sortsitemiru">sortしてみる</h2>
<h3 id="sortsitegroup-risuto">sortしてgroup（リスト）</h3>
<p>そこで２つめの、<code>sort</code>して重複をまとめる方法。
まずはリストを用いると、このようになる。</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#65737e;">--AC
</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Control.Monad
</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Data.List </span><span style="color:#b48ead;">as </span><span style="color:#c0c5ce;">List

main = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">    n &lt;- readLn
    s &lt;- replicateM n getLine
    print $ length . group $ </span><span style="color:#d08770;">List</span><span style="color:#c0c5ce;">.sort s
</span></code></pre>
<p>Data.Listの<code>sort</code>関数をかませたリストに、隣接する同要素をリスト内リストにまとめる<code>group</code>関数をさらにかませてリスト内要素の長さをとるという手順。
かなり泥臭いやり方だが、再帰や<code>nub</code>よりも速いというのはちょっとおもしろい。</p>
<h3 id="data-vectornouniqguan-shu-woyong-iru">Data.Vectorのuniq関数を用いる</h3>
<p>リスト以外のデータ構造ではどうだろう。<br />
まずData.Vectorから。普通に入門書を読んでいるだけだとまず遭遇しないライブラリだが、海外のQ&amp;AサイトではSequenceとどっちがいいの、といった質問でたまに見かける名前だ。</p>
<p>Data.Vector<br />
https://hackage.haskell.org/package/vector-0.12.0.1/docs/Data-Vector.html</p>
<p>これはポリフォーミックなarrayで、リスト操作とarray操作のいいとこどりをしたものである、とHackageでは説明されている。
一通りの標準的な関数は装備されているが、ここで用いたいのは<code>uniq</code>関数。</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#8fa1b3;">uniq </span><span style="color:#b48ead;">:: Eq </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">=&gt; Vector </span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; Vector </span><span style="color:#bf616a;">a
</span></code></pre>
<p>隣接した同じ要素を<code>drop</code>できるものだが、「隣接している」ことが条件なのでsortedが前提となる。
そこで<code>sort</code>関数と組み合わせて次のようにする。</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#65737e;">--AC
</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Control.Monad
</span><span style="color:#b48ead;">import qualified </span><span style="color:#c0c5ce;">Data.Vector </span><span style="color:#b48ead;">as </span><span style="color:#c0c5ce;">V
</span><span style="color:#b48ead;">import qualified </span><span style="color:#c0c5ce;">Data.List </span><span style="color:#b48ead;">as </span><span style="color:#c0c5ce;">L

main = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">    n &lt;- readLn
    s &lt;- replicateM n getLine
    print $ length . </span><span style="color:#d08770;">V</span><span style="color:#c0c5ce;">.uniq . </span><span style="color:#d08770;">V</span><span style="color:#c0c5ce;">.fromList $ </span><span style="color:#d08770;">L</span><span style="color:#c0c5ce;">.sort s
</span></code></pre>
<p>これでも一応問題はクリアだが、実はリストによる<code>group . sort</code>のほうが若干早いということも分かった。
感覚的には必要のない重複を<code>drop</code>できる<code>uniq</code>関数のほうがmake senseではあるのだけれど、<code>V.fromList</code>でO(n)かかってしまっているので致し方ないというところだろうか。</p>
<h2 id="data-setnosizeguan-shu">Data.Setのsize関数</h2>
<p>もうひとつ、Data.Setを見てみる。その名の通り、集合論をベースにした、同型の要素のSetを扱えるライブラリだ。</p>
<p>Data.Set<br />
https://hackage.haskell.org/package/containers-0.6.2.1/docs/Data-Set.html</p>
<p>このライブラリが楽しいのは、<code>Set.fromList</code>でリストからSetを生成する過程で、重複要素が自動的に<code>drop</code>される点。この自動<code>drop</code>がいかにも自然に感じられるところがmake senseだ。<br />
Data.Setを用いたコードは次のようになる。</p>
<pre style="background-color:#2b303b;">
<code><span style="color:#65737e;">--AC
</span><span style="color:#b48ead;">import </span><span style="color:#c0c5ce;">Control.Monad
</span><span style="color:#b48ead;">import qualified </span><span style="color:#c0c5ce;">Data.Set </span><span style="color:#b48ead;">as </span><span style="color:#c0c5ce;">Set
 
main = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">    n &lt;- readLn
    s &lt;- replicateM n getLine
    print $ </span><span style="color:#d08770;">Set</span><span style="color:#c0c5ce;">.size $ </span><span style="color:#d08770;">Set</span><span style="color:#c0c5ce;">.fromList s
</span></code></pre>
<p><code>Set.size</code>はリストでいう<code>length</code>だが、これはO(1)。<br />
実行結果も、リスト版<code>group . sort</code>と大差がつくわけではないものの、最速。<br />
集合論的な発想を武器にできれば、色々な場面でかなり効率的にデータ処理ができそうな予感がする。</p>
</p>

    </div>
  </section>
</body>

<div class="footer">
  <a href="/">tudurikata</a>&emsp;&copy; Kyohei Uto | powered by Zola.
</div>

</html>
