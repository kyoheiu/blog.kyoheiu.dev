<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="utf-8">
  
<title>リストモナドの非決定性／可能性について | tudurikata</title>


  <link rel="shortcut icon" type="image/png" href="&#x2F;images&#x2F;logo.svg">
  <meta name="viewport" content="width=device-width,initial-scale=1">

  
  <link id="stylesheet" rel="stylesheet" type="text/css" href="/dark.css">
  

<script type="text/javascript" src="/js/theme.js"></script>

</head>

<div class="header">
  <div class="site_title">
    <p><a href="/"><img src="https:&#x2F;&#x2F;tudurikata.com&#x2F;images&#x2F;logo.svg"
      alt="tudurikata" width="70" height=auto></a></p>
    <p><a href="/">&nbsp;tudurikata</a></p>
  </div>
  <div class="menu">
    <a href="/post">>archives</a>
    &nbsp;<a href="/about">>about</a>

    
    &nbsp;<button onclick="changeTheme()">change theme</button>
    

  </div>
</div>

<body onload = "getTheme()">
  <section class="section">
    <div class="container">
      
<p>
<div class="archive_title">[リストモナドの非決定性／可能性について]</div>
<div class="date">2020-05-24</div>
<div class="taxonomies">
  
      
      <a href="https://tudurikata.com/categories/code/">/code</a>
      
  
  
      
      &emsp;<a href="https://tudurikata.com/tags/haskell/">#Haskell</a>
      
  
</div>
</p>

<p>
  <p>勉強中、リストモナドの挙動が興味深かったので、ざっくり調べてみた結果をとりあえずまとめてみる。</p>
<p>リストは次のように実装される。</p>
<pre style="background-color:#2b303b;">
<code class="language-hs" data-lang="hs"><span style="color:#d08770;">Data List </span><span style="color:#c0c5ce;">= </span><span style="color:#d08770;">Empty </span><span style="color:#c0c5ce;">| cons a (</span><span style="color:#d08770;">List</span><span style="color:#c0c5ce;"> a)
</span></code></pre>
<p>そして、</p>
<pre style="background-color:#2b303b;">
<code class="language-hs" data-lang="hs"><span style="color:#d08770;">Prelude</span><span style="color:#c0c5ce;">&gt; zipWith </span><span style="color:#8fa1b3;">(+)</span><span style="color:#c0c5ce;"> [</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">] [</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">6</span><span style="color:#c0c5ce;">]
[</span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">7</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">9</span><span style="color:#c0c5ce;">]

</span><span style="color:#d08770;">Prelude</span><span style="color:#c0c5ce;">&gt; concatMap (\x -&gt; [x, x^</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">]) [</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">]
[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">9</span><span style="color:#c0c5ce;">]

</span><span style="color:#d08770;">Prelude</span><span style="color:#c0c5ce;">&gt; [</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">] ++ [</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">6</span><span style="color:#c0c5ce;">]
[</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">6</span><span style="color:#c0c5ce;">]
</span></code></pre>
<p>まずはその中に入っているものはとにかく入っているのだという前提で学んでいく。<br />
こうしたリストの使い勝手の良さはHaskellのよいところの１つだと思うが、さらに面白いのは、実は<code>Fanctor, Applicative, Monad</code>各クラスのインスタンスであるという点。つまり、（<a href="https://www.amazon.co.jp/dp/B07SFCMP66/">入門Haskellプログラミング</a>の表現をまず借りると）上記したような「コンテナとしてのリスト」という側面と別に、「コンテクストとしてのリスト」が存在している。</p>
<p>「コンテクストとしてのリスト」、つまりモナドリストは、たとえば次のような使い方をされる。</p>
<pre style="background-color:#2b303b;">
<code class="language-hs" data-lang="hs"><span style="color:#d08770;">Prelude</span><span style="color:#c0c5ce;">&gt; </span><span style="color:#8fa1b3;">(+) </span><span style="color:#c0c5ce;">&lt;$&gt; [</span><span style="color:#d08770;">1</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">2</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">3</span><span style="color:#c0c5ce;">] &lt;*&gt; [</span><span style="color:#d08770;">4</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">6</span><span style="color:#c0c5ce;">]
[</span><span style="color:#d08770;">5</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">6</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">7</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">6</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">7</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">7</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">8</span><span style="color:#c0c5ce;">,</span><span style="color:#d08770;">9</span><span style="color:#c0c5ce;">]

</span><span style="color:#d08770;">Prelude</span><span style="color:#c0c5ce;">&gt; </span><span style="color:#8fa1b3;">(++) </span><span style="color:#c0c5ce;">&lt;$&gt; [&quot;</span><span style="color:#a3be8c;">white </span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black </span><span style="color:#c0c5ce;">&quot;] &lt;*&gt; [&quot;</span><span style="color:#a3be8c;">cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">dog</span><span style="color:#c0c5ce;">&quot;] 
[&quot;</span><span style="color:#a3be8c;">white cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">white dog</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black dog</span><span style="color:#c0c5ce;">&quot;]
</span></code></pre>
<p>Will Kurtによると、モナドとしてのリストを理解するには「非決定論的な計算」という考え方をするのが最善だという。<code>&lt;*&gt;</code>でつながれたそれぞれのリストは「そのうちのどれであるかが決定されていない」ものであり、計算結果はありうる結果すべてを表現している…。<br />
プログラミングの世界で非決定論的、なんていう言葉を目にするとは思っていなかっただけに、これには驚かされた。</p>
<p>コンテクストという言葉は、おそらく厳密に言えば圏論をしっかり理解しないと腑に落ちないワードだと思う（圏論を理解していないので断言もできない）のだが、Haskellでのモナドを頭に入れるだけであれば次のように考えるとよさそうだ。</p>
<p>コンテナとコンテクスト、という二種類のデータのあり方は、pure function 純粋関数とunpure function 非純粋関数にそれぞれ対応している。<br />
関数が純粋であるとはこの場合、side effectを持たず、その関数にある引数を与えたとき、必ず同じ返り値が出てくる、という意味だ。これは、関数の役割が、ただその関数の定義と引数のみから完全に表現できる、ということでもある。<br />
それは数学の純粋性にどこか似ている。定義、命題、そういったクリアーなモジュールとして在るのが純粋関数、そういう風に考える。<br />
では非純粋とはなにかといえば、「それ自体」以外の役割、something elseを持つかもしれないもの、ということになる。関数と引数が持つデータ以外に何かを引き連れていたり、何かを生んだり、何かを表示したり…といった、つまりside effectを持つかもしれないものが非純粋関数だ。これを扱うために<code>Fanctor, Applicative, Monad</code>という考え方がある。</p>
<p>次に、純粋なものとしてのリストと、非純粋なものとしてのリスト、それぞれをコンテナ／コンテクストとして呼ぶ「意味」は何か、ということを考える。どちらも、ある種の比喩を含む表現だと思う。この比喩が面白いと思うのだが、まずコンテナのほうは「箱」だ。しかもフタが空いていて、何かを追加したり取り出したりするのは自由だが、とにかく中にはこれこれが入っているということが「確定している」。だから計算結果にはゆらぎがない（ように見える）。<br />
一方、コンテクストとは、「何かを理解するために役立つ、状況や事象、情報」のことである。つまり、その何かというのは、コンテクスト(=something else)なしでは完全には意味をとれない。意味が決定されていない。</p>
<pre style="background-color:#2b303b;">
<code class="language-hs" data-lang="hs"><span style="color:#d08770;">Prelude</span><span style="color:#c0c5ce;">&gt; </span><span style="color:#8fa1b3;">(++) </span><span style="color:#c0c5ce;">&lt;$&gt; [&quot;</span><span style="color:#a3be8c;">white </span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black </span><span style="color:#c0c5ce;">&quot;] &lt;*&gt; [&quot;</span><span style="color:#a3be8c;">cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">dog</span><span style="color:#c0c5ce;">&quot;] 
[&quot;</span><span style="color:#a3be8c;">white cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">white dog</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black dog</span><span style="color:#c0c5ce;">&quot;]
</span></code></pre>
<p>上の式は、白か黒かが決定されておらず、犬か猫かも決定されていない、というように読むこともできる。結果は、すべてのあり得る可能性を拾い尽くしたものになる。</p>
<p>もちろんこれは、あえて文学的に表現すれば…ということで、実際にはこの式は<code>do</code>構文を用いると次のようになる。<br />
（参考: <a href="https://kazu-yamamoto.hatenablog.jp/entry/20090313/1236935179">リストモナドの動作原理を考える - あどけない話</a>）</p>
<pre style="background-color:#2b303b;">
<code class="language-hs" data-lang="hs"><span style="color:#c0c5ce;">sample = </span><span style="color:#b48ead;">do
</span><span style="color:#c0c5ce;">    x &lt;- [&quot;</span><span style="color:#a3be8c;">white </span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black </span><span style="color:#c0c5ce;">&quot;]
    y &lt;- [&quot;</span><span style="color:#a3be8c;">cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">dog</span><span style="color:#c0c5ce;">&quot;]
    return (x ++ y)

*</span><span style="color:#d08770;">Main</span><span style="color:#c0c5ce;">&gt; sample
[&quot;</span><span style="color:#a3be8c;">white cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">white dog</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black dog</span><span style="color:#c0c5ce;">&quot;]
</span></code></pre>
<p>上の<code>sample</code>関数を脱糖するとこうなる。</p>
<pre style="background-color:#2b303b;">
<code class="language-hs" data-lang="hs"><span style="color:#c0c5ce;">sample = [&quot;</span><span style="color:#a3be8c;">white </span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black </span><span style="color:#c0c5ce;">&quot;] &gt;&gt;= \x -&gt; [&quot;</span><span style="color:#a3be8c;">cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">dog</span><span style="color:#c0c5ce;">&quot;] &gt;&gt;= \y -&gt; return (x ++ y)
</span></code></pre>
<p>リストモナドにおいて、<code>return</code>と<code>&gt;&gt;=</code>はそれぞれ</p>
<pre style="background-color:#2b303b;">
<code class="language-hs" data-lang="hs"><span style="color:#c0c5ce;">return x = [x]
l &gt;&gt;= f = concatMap f l
</span></code></pre>
<p>このように定義されているから、<code>sample</code>関数はさらに</p>
<pre style="background-color:#2b303b;">
<code class="language-hs" data-lang="hs"><span style="color:#c0c5ce;">sample = concatMap (\x -&gt; [&quot;</span><span style="color:#a3be8c;">cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">dog</span><span style="color:#c0c5ce;">&quot;] &gt;&gt;= \y -&gt; [x ++ y]) [&quot;</span><span style="color:#a3be8c;">white </span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black </span><span style="color:#c0c5ce;">&quot;]
       = concatMap (\x -&gt; concatMap (\y -&gt; [x ++ y]) [&quot;</span><span style="color:#a3be8c;">cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">dog</span><span style="color:#c0c5ce;">&quot;]) [&quot;</span><span style="color:#a3be8c;">white </span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black </span><span style="color:#c0c5ce;">&quot;]
</span></code></pre>
<p>と変形できる。<br />
これを内側、外側の順に計算すると、</p>
<pre style="background-color:#2b303b;">
<code class="language-hs" data-lang="hs"><span style="color:#c0c5ce;">sample = concatMap (\x -&gt; [x ++ &quot;</span><span style="color:#a3be8c;">cat</span><span style="color:#c0c5ce;">&quot;, x ++ &quot;</span><span style="color:#a3be8c;">dog</span><span style="color:#c0c5ce;">&quot;]) [&quot;</span><span style="color:#a3be8c;">white </span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black </span><span style="color:#c0c5ce;">&quot;]
       = [&quot;</span><span style="color:#a3be8c;">white cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">white dog</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black cat</span><span style="color:#c0c5ce;">&quot;,&quot;</span><span style="color:#a3be8c;">black dog</span><span style="color:#c0c5ce;">&quot;]
</span></code></pre>
<p>リストモナドの計算に非決定性／すべてのありうる可能性…といったsomething elseが現れる根拠は、この式変換でいうと<code>concatMap</code>の存在だろう。</p>
<pre style="background-color:#2b303b;">
<code class="language-hs" data-lang="hs"><span style="color:#c0c5ce;">:t concatMap
</span><span style="color:#8fa1b3;">concatMap </span><span style="color:#b48ead;">:: Foldable </span><span style="color:#bf616a;">t </span><span style="color:#b48ead;">=&gt;</span><span style="color:#c0c5ce;"> (</span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt;</span><span style="color:#c0c5ce;"> [</span><span style="color:#bf616a;">b</span><span style="color:#c0c5ce;">]) </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">t a </span><span style="color:#b48ead;">-&gt;</span><span style="color:#c0c5ce;"> [</span><span style="color:#bf616a;">b</span><span style="color:#c0c5ce;">]
</span></code></pre>
<p>ところで、<code>&gt;&gt;=</code>の型は</p>
<pre style="background-color:#2b303b;">
<code class="language-hs" data-lang="hs"><span style="color:#c0c5ce;">:t </span><span style="color:#8fa1b3;">(&gt;&gt;=)
(&gt;&gt;=) </span><span style="color:#b48ead;">:: Monad </span><span style="color:#bf616a;">m </span><span style="color:#b48ead;">=&gt; </span><span style="color:#bf616a;">m a </span><span style="color:#b48ead;">-&gt;</span><span style="color:#c0c5ce;"> (</span><span style="color:#bf616a;">a </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">m b</span><span style="color:#c0c5ce;">) </span><span style="color:#b48ead;">-&gt; </span><span style="color:#bf616a;">m b
</span></code></pre>
<p>こうなっている。<br />
<code>concatMap</code>とは引数の順番が違うが、<code>flip</code>を使ってもよいと考えると<code>concatMap</code>のほうはこうなる。</p>
<pre style="background-color:#2b303b;">
<code class="language-hs" data-lang="hs"><span style="color:#c0c5ce;">:t flip concatMap
flip concatMap :: </span><span style="color:#d08770;">Foldable</span><span style="color:#c0c5ce;"> t =&gt; t a -&gt; (a -&gt; [b]) -&gt; [b]
</span></code></pre>
<p>これを<code>&gt;&gt;=</code>と見比べてみると、<code>&gt;&gt;=</code>の<code>m a/m b</code>がconcatMapでは<code>t a/[b]</code>になっているだけで、構造としては同じだ。「モナドな何かについて、モナドでない何かをとってモナドな何かを返す関数を適用することで、モナドな何かを返す」…これが<code>&gt;&gt;=</code>だとすれば、「<code>Foldable</code>な何かについて、リストでない何かをとってリストを返す関数を適用することで、リストを返す」ものが<code>concatMap</code>だというわけだ。一般論としての<code>&gt;&gt;=</code>と<code>concatMap</code>の関連性（正確ではないかもしれないが、抽象／具体の関係と呼んでみる）が、こう表現すると明らかになってくる。つまり、要素をリストに入れ、リストを返すという「リスト化」が、<code>&lt;*&gt;</code>でつながれたそれぞれの引数について不足なく行われる結果、可能性全体を表現するかのようなリストが生成される、というふうに考えることができる。</p>
<p>ここで文学的な解釈にあえて戻ってみると、結局、非決定性／可能性とは全体性なのだ、ということができるような気がする。こぼさずすべてを取り尽くすことが非決定性／可能性を生む。逆に言えば、その一部をとらないーすくわず、捨て去るたび毎に、それは凝固し、決定的になっていく。同時に、可能性がなくなり、固定されていく。こんな風に言い換えることもできるかもしれない。決まっていないことは可能性であり、決めることはゆらぎがなくなっていくことだと。当たり前といえば当たり前なのだが、あまりにも豊かすぎる表現のように感じられる。モナドという概念は、やっぱり面白い。</p>

</p>




    </div>
  </section>
</body>

<div class="footer">
  <a href="/">tudurikata</a>&emsp;&copy; Kyohei Uto<br>
  powered by <a href="https://www.getzola.org/">Zola</a>, theme <a href="https://gitlab.com/kyoheiu/emily_zola_theme">emily</a>.
</div>

</html>