<?xml version="1.0" encoding="UTF-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
      <title>kyoheiu.gitlab.io - code</title>
        <link>https://kyoheiu.gitlab.io</link>
        <description>personal notes</description>
        <generator>Zola</generator>
        <language>ja</language>
        <atom:link href="https://kyoheiu.gitlab.io/categories/code/rss.xml" rel="self" type="application/rss+xml"/>
        <lastBuildDate>Wed, 09 Mar 2022 00:00:00 +0000</lastBuildDate>
        <item>
            <title>JavaScriptをdenoでシンプルに書く</title>
            <pubDate>Wed, 09 Mar 2022 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/just-js-deno/</link>
            <guid>https://kyoheiu.gitlab.io/post/just-js-deno/</guid>
            <description>&lt;p&gt;ちょっとしたタスクでTwitter APIを叩かないといけなくなり、前は叩くところからデータフォーマットまで全部Rustのファイル１枚で書いたので、今度は別の言語にするかな～と、軽い気持ちでGoで書いてみたらなぜかうまくいかなかった。&lt;&#x2F;p&gt;
&lt;p&gt;json.Unmarshalがよしなに動いてくれなかったのがうまくいかなかった理由（多分）。jsonの処理はあまりにも普遍的なのでどの言語でも一緒だろ～～とか思ってたら意外とそんなことはなかった…。Unmarshalが動かなかったときのデバッグってどうすればいいんだろう。&lt;&#x2F;p&gt;
&lt;p&gt;Goに慣れていないので、全部をGoのStandard Libraryのせいにする気はないけれど、たとえばRustのserdeと比べてみると、Goのほうが一段高いレベルでざっくり抽象化されているような気がしていて、その分デバッグも微妙にやりにくいように思う。&lt;&#x2F;p&gt;
&lt;p&gt;（最近ずっとRustを書いているという理由で別言語を選んだわけなので、そもそもGoを選んだのはちょっと違ったかな…とは思っている）&lt;&#x2F;p&gt;
&lt;p&gt;ん～どうするかな…と３秒くらい考えて、どうせレスポンスのjsonをあれこれするならもうJs&#x2F;Tsでいいのでは？となり、Jsを50行くらい書いて&lt;code&gt;deno run&lt;&#x2F;code&gt;したら一瞬でタスクが終わったので、denoいいね…となった。HTTPリクエスト送る系のタスクはこれでいいのかもしれない。データ量が膨大だったり後処理が複雑だと話は変わってくるのだろうけど。シェルスクリプトの代替としてのJs&#x2F;Tsというのも案外ありなのかな、とも思った。zxというのもあるけど、別に文法を変えなくても生Jsで良くないかな？&lt;&#x2F;p&gt;
&lt;p&gt;あと、この程度の規模だと型なくても全然いいね…というのも実感としてあった。Haskellから入ったくらいなので、型がないともうどうしていいか分からないくらいuntyped langへの苦手意識があったのだが、アロー記法とか高階関数のおかげでかなり息がしやすくなっていて良かった。denoのエラーメッセージもけっこう親切で、シンプルにJsそのものに向き合える感じがあるというか。&lt;&#x2F;p&gt;
&lt;p&gt;denoはTs、というイメージが強いように思うが、Jsも普通に書けるので、ちょっとしたタスクにJsを使ってみようかなという向きには非常におすすめの組み合わせです。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>fcitxが壊れたので設定を見直す</title>
            <pubDate>Wed, 29 Dec 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/fcitx-does-not-work/</link>
            <guid>https://kyoheiu.gitlab.io/post/fcitx-does-not-work/</guid>
            <description>&lt;h3 id=&quot;huai-retayuan-yin&quot;&gt;壊れた原因&lt;&#x2F;h3&gt;
&lt;p&gt;普段はMac bookでzoomを使っていたのだけれど、ちょっとした用事でメインのデスクトップにもzoomを入れることになり、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;yay -S zoom
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;でインストール（officialじゃなくてaurだよ）。&lt;&#x2F;p&gt;
&lt;p&gt;しかしこのzoom、理由は不明だが依存パッケージにibusがあり、おそらくこいつが原因でfcitxが正常に動かなくなってしまった。多分何かしらのコンフリクトが発生している。状態としては、起動するけれど変換してくれない、というもの。&lt;&#x2F;p&gt;
&lt;p&gt;明らかにzoomインストール後の不具合だったので、何とか依存パッケージごと削除してもとに戻そうとするも、どこかのファイルに変更が加えられてしまったのか、うまくいかない。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;koremade&quot;&gt;これまで&lt;&#x2F;h3&gt;
&lt;p&gt;fcitxの起動はこれまで、&lt;code&gt;.xinitrc&lt;&#x2F;code&gt;に&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;export GTK_IM_MODULE=fcitx
export QT_IM_MODULE=fcitx
export XMODIFIERS=@im=fcitx
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;と記述した上で、i3のスタート時起動 &lt;code&gt;exec --no-startup-id fcitx&lt;&#x2F;code&gt; を行っていた。&lt;br &#x2F;&gt;
のだが、どうやら一連のexportは通常&lt;code&gt;.xprofile&lt;&#x2F;code&gt;に記述するほうが正しいみたい。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;.xprofile&lt;&#x2F;code&gt;への記述で、fcitx自体は無事動くようになった（なぜかは不明）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhui-jia-nowen-ti&quot;&gt;追加の問題&lt;&#x2F;h3&gt;
&lt;p&gt;ただ、こうすると、fcitxが起動している状態でターミナルを立ち上げたとき、日本語のインプットが必ず先に入ってしまう（これまではなぜかターミナルではデフォルト英数だった）。自作ランチャーにも日本語が入るようになり、すごくわずらわしい。いちいち切り替えて入力するのも嫌だし…。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dui-ce&quot;&gt;対策&lt;&#x2F;h3&gt;
&lt;p&gt;exportの記述をすべて&lt;code&gt;.xprofile&lt;&#x2F;code&gt;に移した上で、思いきってスタート時のfcitx起動を削除した。
代わりに、i3の設定で&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;#IME
bindsym $mod+i exec fcitx
bindsym $mod+k exec &amp;quot;killall fcitx&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;として、ショートカットでfcitxの起動／停止を行うようにした。IME自体をデフォルトで無効にして、どうしても必要なときに日本語入力を立ち上げる。こうなると「日本語入力ができる」ほうがむしろ特殊な状態になるので、「今日本語入力だっけ…？」的なわずらわしさがちょっと減り、わりと頭の中はスッキリする。&lt;br &#x2F;&gt;
だいたい起動時に問答無用でfcitxを起動している人が多い印象ですが、むしろ使わないときはkillallしてしまったほうが快適ですね。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zui-hou-ni&quot;&gt;最後に&lt;&#x2F;h3&gt;
&lt;p&gt;zoom(ibus)許すまじ。&lt;&#x2F;p&gt;
&lt;p&gt;(本当は、日本語入力するデバイスと英語／コードを書くデバイスを思いきって分けてしまったほうが楽かもしれない)&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>RustプロジェクトのビルドテストをGithub Actionsで行う（Arch Linuxのタグに要注意）</title>
            <pubDate>Thu, 25 Nov 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/arch-docker-gcc/</link>
            <guid>https://kyoheiu.gitlab.io/post/arch-docker-gcc/</guid>
            <description>&lt;p&gt;タイトルの通りなのだが、若干ハマったので記録しておきます。&lt;&#x2F;p&gt;
&lt;p&gt;Rustのプロジェクトにおいて、自分のローカル環境以外でもうまくインストールできるかのテストを行うためにGitHub Actionsを使っている。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# .github&amp;#x2F;workflows&amp;#x2F;install_test.yml

name: &amp;#x27;install test&amp;#x27;

on:
  push:
    branches-ignore: &amp;#x27;main&amp;#x27;
    paths-ignore:
      - &amp;#x27;*.md&amp;#x27;

env:
  CARGO_TERM_COLOR: always

jobs:
  ubuntu-install:
    runs-on: ubuntu-latest
    steps:
    - uses: actions&amp;#x2F;checkout@v2
    - name: Install
      run: |
        cargo install --path .
  macos-install:
    runs-on: macos-latest
    steps:
    - uses: actions&amp;#x2F;checkout@v2
    - name: Install
      run: |
        cargo install --path .
  archlinux-install:
    runs-on: ubuntu-latest
    container:
      image: archlinux:latest
    steps:
    - uses: actions&amp;#x2F;checkout@v2
    - name: Install
      run: |
        pacman -Syu --noconfirm
        pacman -S gcc --noconfirm
        pacman -S rustup --noconfirm
        rustup install stable
        rustup default stable
        cargo install --path .
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;jobsは３つ。Ubuntu上・macOS上・Arch Linux上それぞれでのインストールをテストしている。（&lt;code&gt;cargo install --path .&lt;&#x2F;code&gt;が通ればcrates.ioからのインストールも問題ないという認識）&lt;&#x2F;p&gt;
&lt;p&gt;ご覧の通り、UbuntuとmacOSでは特に追加でライブラリをインストールする必要なくパスしているが、archlinux:latestを使った最後のテストでは、&lt;code&gt;gcc&lt;&#x2F;code&gt;と&lt;code&gt;rustup&lt;&#x2F;code&gt;を先にインストールしている。
&lt;code&gt;rustup&lt;&#x2F;code&gt;がarchlinux:latestに含まれていないのは当たり前のことなのでこれは良い。問題なのは&lt;code&gt;gcc&lt;&#x2F;code&gt;。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;gcc&lt;&#x2F;code&gt;を事前インストールしない場合、テスト中に&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;error: linker `cc` not found
  |
  = note: No such file or directory (os error 2)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;とビルドエラーが出てしまう。 &lt;&#x2F;p&gt;
&lt;p&gt;そもそものarchlinux:latestイメージの中に入ってみると、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# docker run -it archlinux:latest
[root@0fd34e31306a &amp;#x2F;]# pacman -Qi gcc
warning: database file for &amp;#x27;core&amp;#x27; does not exist (use &amp;#x27;-Sy&amp;#x27; to download)
warning: database file for &amp;#x27;extra&amp;#x27; does not exist (use &amp;#x27;-Sy&amp;#x27; to download)
warning: database file for &amp;#x27;community&amp;#x27; does not exist (use &amp;#x27;-Sy&amp;#x27; to download)
error: package &amp;#x27;gcc&amp;#x27; was not found
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;うーん、やっぱり入ってない。&lt;code&gt;gcc&lt;&#x2F;code&gt;が含まれてないなんて、そんなことある？　と思いながら、テストはパスするのでそのままにしていた。&lt;&#x2F;p&gt;
&lt;p&gt;でもやっぱり引っかかる。そこで、よく&lt;a href=&quot;https:&#x2F;&#x2F;hub.docker.com&#x2F;_&#x2F;archlinux&quot;&gt;公式の説明&lt;&#x2F;a&gt;を読んで見ると…&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;Besides &lt;code&gt;base&lt;&#x2F;code&gt; we also provide images for the &lt;code&gt;base-devel&lt;&#x2F;code&gt; package group. &lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;tagにちゃんと&lt;code&gt;base-devel&lt;&#x2F;code&gt;がある…！　そして&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;The &lt;code&gt;latest&lt;&#x2F;code&gt; tag will always match the latest &lt;code&gt;base&lt;&#x2F;code&gt; tag.&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;はい、ありがちな&lt;code&gt;base-devel&lt;&#x2F;code&gt;抜け。&lt;br &#x2F;&gt;
何も考えずlatestを使ってはいけないという教訓を得ました。&lt;&#x2F;p&gt;
&lt;p&gt;というわけで冒頭のymlを次のように変更。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;  archlinux-install:
    runs-on: ubuntu-latest
    container:
      image: archlinux:base-devel
    steps:
    - uses: actions&amp;#x2F;checkout@v2
    - name: Install
      run: |
        pacman -Syu --noconfirm
        pacman -S rustup --noconfirm
        rustup install stable
        rustup default stable
        cargo install --path .
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;データベースの更新はいずれにせよ必要として、&lt;code&gt;gcc&lt;&#x2F;code&gt;の明示的インストールを削除。テストももちろんパス。あースッキリした。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>felix - a tui file manager written in Rust</title>
            <pubDate>Thu, 25 Nov 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/felix-file-manager/</link>
            <guid>https://kyoheiu.gitlab.io/post/felix-file-manager/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;crates.io&#x2F;crates&#x2F;felix&quot;&gt;&lt;img src=&quot;https:&#x2F;&#x2F;img.shields.io&#x2F;crates&#x2F;v&#x2F;felix&quot; alt=&quot;crates.io&quot; &#x2F;&gt;&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;A tui file manager with vim-like key mapping, written in Rust.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;sample.gif&quot; alt=&quot;sample gif&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;While heavliy inspired by the great &lt;code&gt;vifm&lt;&#x2F;code&gt; and trying to implement its pleasant experience in Rust, at the same time this project focuses on the following points:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;simple and fast&lt;&#x2F;li&gt;
&lt;li&gt;easy to configure how to open files&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;status&quot;&gt;Status&lt;&#x2F;h2&gt;
&lt;ul&gt;
&lt;li&gt;Linux : works well&lt;&#x2F;li&gt;
&lt;li&gt;MacOS : &lt;em&gt;should&lt;&#x2F;em&gt; work, though some unusual errors may occur&lt;&#x2F;li&gt;
&lt;li&gt;Windows: almost unavailable due to file-name encoding error&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;&#x2F;h2&gt;
&lt;p&gt;Before you do the following, make sure &lt;code&gt;gcc&lt;&#x2F;code&gt; is installed.&lt;&#x2F;p&gt;
&lt;p&gt;from crates.io:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;cargo install felix
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;or from GitHub repository:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;kyoheiu&amp;#x2F;felix.git
cd felix
cargo install --path .
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;usage&quot;&gt;Usage&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;command&lt;&#x2F;th&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;fx&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Show items in the current directory.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&lt;code&gt;fx &amp;lt;directory path&amp;gt;&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td&gt;Show items in the path. Both relative and absolute available.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h2 id=&quot;key-manual&quot;&gt;Key manual&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Key&lt;&#x2F;th&gt;&lt;th&gt;Explanation&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;j &#x2F; Key Up&lt;&#x2F;td&gt;&lt;td&gt;Go up. If the list exceeds max-row, list &amp;quot;scrolls&amp;quot; before the top of the list.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;k &#x2F; Key Down&lt;&#x2F;td&gt;&lt;td&gt;Go down. If the list exceeds max-row, list &amp;quot;scrolls&amp;quot; before the bottom of the list.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;h &#x2F; Key Left&lt;&#x2F;td&gt;&lt;td&gt;Go to parent directory if exists.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;l &#x2F; Key Right &#x2F; Enter&lt;&#x2F;td&gt;&lt;td&gt;Open file or change directory. Commands for execution can be managed in config file.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;gg&lt;&#x2F;td&gt;&lt;td&gt;Go to the top.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;G&lt;&#x2F;td&gt;&lt;td&gt;Go to the bottom.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;dd&lt;&#x2F;td&gt;&lt;td&gt;Delete and yank item (item will go to the trash directory).&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;yy&lt;&#x2F;td&gt;&lt;td&gt;Yank item. If you yanked other item before, its information is replaced by this one.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;p&lt;&#x2F;td&gt;&lt;td&gt;Put yanked item(s) in the current directory. If item with same name exists, copied item will be renamed with the suffix &amp;quot;_copied&amp;quot;.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;V&lt;&#x2F;td&gt;&lt;td&gt;Switch to select mode, where you can move cursor to select items.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;d (select mode)&lt;&#x2F;td&gt;&lt;td&gt;Delete and yank selected items, and return to normal mode.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;y (select mode)&lt;&#x2F;td&gt;&lt;td&gt;Yank selected items, and return to normal mode.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;t&lt;&#x2F;td&gt;&lt;td&gt;Toggle sort order (by name &amp;lt;-&amp;gt; by modified time). This change remains until the program ends (sort order will be restored as configured).&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;:&lt;&#x2F;td&gt;&lt;td&gt;Switch to shell mode (&lt;em&gt;&lt;strong&gt;experimantal&lt;&#x2F;strong&gt;&lt;&#x2F;em&gt;). Type command and press Enter to execute it. You can use any command in the displayed directory, but it may fail to execute the command (e.g. &lt;code&gt;cd&lt;&#x2F;code&gt; doesn&#x27;t work for now), and also the display of items may collapse during execution.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;c&lt;&#x2F;td&gt;&lt;td&gt;Switch to rename mode (enter new name and press Enter to rename the item).&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;&#x2F;&lt;&#x2F;td&gt;&lt;td&gt;Switch to filter mode (enter keyword and press Enter to go to filtered list).&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Esc&lt;&#x2F;td&gt;&lt;td&gt;Return to normal mode.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;:e&lt;&#x2F;td&gt;&lt;td&gt;Reload the current directory. Useful when something goes wrong in filter mode (e.g. no matches) or shell mode.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;:empty&lt;&#x2F;td&gt;&lt;td&gt;Empty the trash directory. &lt;strong&gt;Please think twice before using this command.&lt;&#x2F;strong&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;:h&lt;&#x2F;td&gt;&lt;td&gt;Show help.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;:q &#x2F; ZZ&lt;&#x2F;td&gt;&lt;td&gt;Exit the program.&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Note that items moved to the trash directory are prefixed with Unix time (like &lt;code&gt;1633843993&lt;&#x2F;code&gt;) to avoid name conflict. This prefix will be removed when paste.&lt;&#x2F;p&gt;
&lt;h2 id=&quot;settings&quot;&gt;Settings&lt;&#x2F;h2&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;th&gt;&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;config file&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;$XDG_CONFIG_HOME&#x2F;felix&#x2F;config.toml&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;trash directory&lt;&#x2F;td&gt;&lt;td&gt;&lt;code&gt;$XDG_CONFIG_HOME&#x2F;felix&#x2F;trash&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;Default config file, which is &lt;a href=&quot;config.toml&quot;&gt;here&lt;&#x2F;a&gt;, will be created automatically when you launch the program for the first time.&lt;&#x2F;p&gt;
&lt;p&gt;In config.toml, you can set:&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;color of directories, files, and symlinks separatively&lt;&#x2F;li&gt;
&lt;li&gt;default key for sorting item list (&amp;quot;Name&amp;quot; or &amp;quot;Time&amp;quot;)&lt;&#x2F;li&gt;
&lt;li&gt;how to open files&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;command-setting&quot;&gt;Command setting&lt;&#x2F;h3&gt;
&lt;p&gt;If you write&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;default = &amp;quot;nvim&amp;quot;

[exec]
feh = [&amp;quot;jpg&amp;quot;, &amp;quot;jpeg&amp;quot;, &amp;quot;png&amp;quot;, &amp;quot;gif&amp;quot;, &amp;quot;svg&amp;quot;]
zathura = [&amp;quot;pdf&amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;then, .jpg, .jpeg, .png, .gif and .svg files are opened by &lt;code&gt;feh &amp;lt;file-name&amp;gt;&lt;&#x2F;code&gt;, .pdf files by &lt;code&gt;zathura &amp;lt;file-name&amp;gt;&lt;&#x2F;code&gt; and others by &lt;code&gt;nvim &amp;lt;file-name&amp;gt;&lt;&#x2F;code&gt; .&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>関数型的に入門するC++</title>
            <pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/getting-started-functional-cpp/</link>
            <guid>https://kyoheiu.gitlab.io/post/getting-started-functional-cpp/</guid>
            <description>&lt;p&gt;C++に興味が出てきて勉強中。参考としているのは&lt;a href=&quot;https:&#x2F;&#x2F;ezoeryou.github.io&#x2F;cpp-intro&#x2F;#%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0&quot;&gt;江添亮の C++入門&lt;&#x2F;a&gt;。わかりやすく、ユーモアもところどころあって楽しい。とりあえずアルゴリズムについて、関数型（というか Haskell）的な視点でまとめておく。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;yi-lan&quot;&gt;一覧&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;ezoeryou.github.io&#x2F;cpp-intro&#x2F;#%E3%82%A2%E3%83%AB%E3%82%B4%E3%83%AA%E3%82%BA%E3%83%A0&quot;&gt;アルゴリズム&lt;&#x2F;a&gt;の章で紹介されている各関数は高階関数として捉えると理解が捗る。とくにこの場合、イテレータから説明が続いているので、&lt;code&gt;Foldable a&lt;&#x2F;code&gt;に対して適用される&lt;code&gt;Data.List&lt;&#x2F;code&gt;収録の関数として変換していくととても覚えやすいと思う。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;for_each -&amp;gt; map || foldr
all_of -&amp;gt; all
any_of -&amp;gt; any
none_of -&amp;gt; !all
find -&amp;gt; elem
find_if -&amp;gt; head . filter f
count -&amp;gt; length . filter (==x)
count_if -&amp;gt; length . filter f
equal -&amp;gt; [a] == [b] || f([a]) == f([b])　 &amp;#x2F;&amp;#x2F;関数をとる場合もある
search -&amp;gt; ???
transform -&amp;gt; map

&amp;#x2F;&amp;#x2F;ラムダ式
[](a x) -&amp;gt; b {...}
\x -&amp;gt; f(x) :: a -&amp;gt; b
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;練習も兼ねて書いてみよう。上が Haskell、下が main 関数で記述した C++（厳密には対応していないので悪しからず）。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;for-each&quot;&gt;for_each&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;map (*2) [1..4]

-----

void f(int x)
{
    x = x * 2;
    std::cout &amp;lt;&amp;lt; x &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;;
}

int main()
{
    std::vector&amp;lt;int&amp;gt; v = {1, 2, 3, 4};
    for_each(std::begin(v), std::end(v), f);
}

&amp;#x2F;&amp;#x2F;ラムダ式
for_each(std::begin(v), std::end(v), [](auto x)
             { std::cout &amp;lt;&amp;lt; x * 2 &amp;lt;&amp;lt; &amp;quot;\n&amp;quot;; });
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;all-of&quot;&gt;all_of&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;all (even) [2,4,6,8]

-----

int main()
{
    std::vector&amp;lt;int&amp;gt; v = {2, 4, 6, 8};
    std::cout &amp;lt;&amp;lt; std::boolalpha;
    std::cout &amp;lt;&amp;lt; all_of(std::begin(v), std::end(v), [](auto value)
                        { return value % 2 == 0; });
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;find&quot;&gt;find&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;3 `elem` [1..4] &amp;#x2F;&amp;#x2F; True
5 `elem` [1..4] &amp;#x2F;&amp;#x2F; False

-----

int main()
{
    std::vector&amp;lt;int&amp;gt; v = {2, 4, 6, 8};
    if (std::end(v) == find(std::begin(v), std::end(v), 4))
    {
        std::cout &amp;lt;&amp;lt; &amp;quot;Not found.\n&amp;quot;;
    }
    else
    {
        std::cout &amp;lt;&amp;lt; &amp;quot;Found.\n&amp;quot;;
    }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;find(first, last, value)&lt;&#x2F;code&gt;の場合、value が見つからなかったときに返るのは last だが、出力時に要素の&lt;code&gt;0&lt;&#x2F;code&gt;と区別がつかなくなってしまうので、&lt;code&gt;std::end(v)&lt;&#x2F;code&gt;との比較でケースを分けている。パターンマッチングでもっとシンプルにしたいが…？&lt;&#x2F;p&gt;
&lt;h4 id=&quot;count&quot;&gt;count&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;(length . filter (==1)) [1,2,1,1,2,1,3]

-----

int main()
{
    std::vector&amp;lt;int&amp;gt; v = {1, 2, 1, 1, 2, 1, 3};
    std::cout &amp;lt;&amp;lt; count(v.begin(), v.end(), 1);
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h4 id=&quot;search&quot;&gt;search&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;import qualified Data.List as L

search :: Eq a =&amp;gt; [a] -&amp;gt; [a] -&amp;gt; Maybe Int
search xs ys =
  case L.elemIndex (head xs) ys of
    Just n -&amp;gt;
      if take (length xs) (drop n ys) == xs
        then Just n
        else (+) &amp;lt;$&amp;gt; Just (n + 1) &amp;lt;*&amp;gt; search xs (drop (n + 1) ys)
    Nothing -&amp;gt; Nothing

-----

int main()
{
    std::vector&amp;lt;int&amp;gt; v1 = {1, 2, 3, 4, 5, 6};
    std::vector&amp;lt;int&amp;gt; v2 = {2, 3, 4};

    std::cout &amp;lt;&amp;lt; *search(v1.begin(), v1.end(), v2.begin(), v2.end());
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;search(first1,last1,first2,last2)&lt;&#x2F;code&gt;は、[first1,last1)の範囲に[first2,last2)があれば、見つかったサブシークエンスの先頭のイテレータを返す関数。微妙に複雑だ。&lt;br &#x2F;&gt;
これを Haskell で実装してみると…。単に「含むかどうか」を&lt;code&gt;Bool&lt;&#x2F;code&gt;で返すなら&lt;code&gt;isInfixOf&lt;&#x2F;code&gt;があるが、最初の要素となると、先頭がマッチするだけでなく、そのあとの並びがきちんと求めるリストと一致しているかどうかを見た上で、&lt;code&gt;drop&lt;&#x2F;code&gt;した数と足していかないといけない。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;c-mian-bai-i&quot;&gt;C++、面白い&lt;&#x2F;h4&gt;
&lt;p&gt;「C++で関数型プログラミングをする」ために書かれた本もいくつかあるようだ。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.manning.com&#x2F;books&#x2F;functional-programming-in-c-plus-plus&quot;&gt;Manning | Functional Programming in C++&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B07MTBCCV5&quot;&gt;Amazon | Hands-On Functional Programming with C++: An effective guide to writing accelerated functional code using C++17 and C++20 (English Edition) [Kindle edition] by Bolboaca, Alexandru | Hardware | Kindle ストア&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;上の Manning の本を読み始めているが、関数合成的（？）なことができるパイプというものがあるらしく、色々できそうで楽しみです。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>purify Amazon URL - an extention for Firefox</title>
            <pubDate>Fri, 20 Aug 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/purify-amazon-url/</link>
            <guid>https://kyoheiu.gitlab.io/post/purify-amazon-url/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;addons.mozilla.org&#x2F;en-US&#x2F;firefox&#x2F;addon&#x2F;purify-amazon-url&#x2F;&quot;&gt;purify Amazon URL – Get this Extension for 🦊 Firefox (en-US)&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;An extention for Firefox that purifies Amazon URL and reloads tab.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;example&quot;&gt;example&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;https:&amp;#x2F;&amp;#x2F;www.amazon.com&amp;#x2F;Learn-You-Haskell-Great-Good-ebook-dp-B004VB3V0K&amp;#x2F;dp&amp;#x2F;B004VB3V0K&amp;#x2F;ref=mt_other?_encoding=UTF8&amp;amp;me=&amp;amp;qid=
-&amp;gt;
https:&amp;#x2F;&amp;#x2F;www.amazon.com&amp;#x2F;dp&amp;#x2F;B004VB3V0K
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;usage&quot;&gt;usage&lt;&#x2F;h3&gt;
&lt;p&gt;Just right-click and choose &amp;quot;purify Amazon URL&amp;quot; to reload Amazon page with purified URL.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>rewind - A CLI tool to downgrade packages using local Pacman cache</title>
            <pubDate>Sun, 08 Aug 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/rewind-downgrade-cli/</link>
            <guid>https://kyoheiu.gitlab.io/post/rewind-downgrade-cli/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kyoheiu&#x2F;rewind&quot;&gt;kyoheiu&#x2F;rewind&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;sample.gif&quot; alt=&quot;gif&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;installation&quot;&gt;Installation&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;kyoheiu&amp;#x2F;rewind.git
cd rewind
cabal install
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;rewind [package name you want to downgrade]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;like &lt;code&gt;rewind neovim&lt;&#x2F;code&gt;.
You can use mutliple arguments like &lt;code&gt;rewind neovim emacs&lt;&#x2F;code&gt; as well.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>reme - A simple CLI tool to create slack reminder</title>
            <pubDate>Tue, 03 Aug 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/reme-slack-reminder-cli/</link>
            <guid>https://kyoheiu.gitlab.io/post/reme-slack-reminder-cli/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kyoheiu&#x2F;reme&quot;&gt;kyoheiu&#x2F;reme&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;sample.gif&quot; alt=&quot;gif&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;h2 id=&quot;installation&quot;&gt;Installation&lt;&#x2F;h2&gt;
&lt;pre&gt;&lt;code&gt;git clone https:&amp;#x2F;&amp;#x2F;github.com&amp;#x2F;kyoheiu&amp;#x2F;reme.git
cd reme
cabal install
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You need &lt;code&gt;~&#x2F;.config&#x2F;reme.dhall&lt;&#x2F;code&gt; file to store the slack authentication token.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;dhall&quot; class=&quot;language-dhall &quot;&gt;&lt;code class=&quot;language-dhall&quot; data-lang=&quot;dhall&quot;&gt;{ slackToken = &amp;quot;xoxp-xxxxxx...&amp;quot;
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;If you&#x27;d like to change the file path, replace &lt;code&gt;path&lt;&#x2F;code&gt; in Main.hs.&lt;&#x2F;p&gt;
&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;&#x2F;h3&gt;
&lt;p&gt;To set reminder,&lt;code&gt;reme &amp;quot;[text]&amp;quot; &amp;quot;[time]&amp;quot;&lt;&#x2F;code&gt; will work.&lt;br &#x2F;&gt;
&lt;code&gt;reme &amp;quot;[text]&amp;quot;&lt;&#x2F;code&gt; will ask you the time to send reminder.&lt;br &#x2F;&gt;
&lt;code&gt;reme&lt;&#x2F;code&gt; shows this help.&lt;&#x2F;p&gt;
&lt;p&gt;For example,&lt;br &#x2F;&gt;
&lt;code&gt;reme &amp;quot;foo&amp;quot; &amp;quot;in 1 hour&amp;quot;&lt;&#x2F;code&gt; sets the reminder for &amp;quot;foo&amp;quot; in 1 hour.&lt;br &#x2F;&gt;
&lt;code&gt;reme &amp;quot;foo&amp;quot;&lt;&#x2F;code&gt; asks you the time to send reminder for &amp;quot;foo&amp;quot;.&lt;&#x2F;p&gt;
&lt;p&gt;For the token and argument for the time detail, see &lt;a href=&quot;https:&#x2F;&#x2F;api.slack.com&#x2F;methods&#x2F;reminders.add&quot;&gt;reminders.add method | Slack&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>各パーサーコンビネータにおけるtry&#x2F;eof(endOfInput)の挙動</title>
            <pubDate>Sat, 31 Jul 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/try-and-eof-in-parser-combinators/</link>
            <guid>https://kyoheiu.gitlab.io/post/try-and-eof-in-parser-combinators/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;adventofcode.com&#x2F;2020&#x2F;day&#x2F;19&quot;&gt;Advent of Code 2020のDay 19&lt;&#x2F;a&gt;を解いていて、複数パーサーの選択でしばらくつまずいていたのでメモ。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tl-dr&quot;&gt;TL;DR&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;MegaparsecおよびParsecでは、tryでくるんだパーサー内でeofを使うと正常に動かない場合がある？&lt;&#x2F;li&gt;
&lt;li&gt;Attoparsecではchoice内でも問題なくendOfInputが動く。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;tekisutowozhi-he-xing-norisutonipasusuru&quot;&gt;テキストを直和型のリストにパースする&lt;&#x2F;h3&gt;
&lt;p&gt;Day 19では次のようなテキストを適切にパースすることが求められる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;0: 4 1 5
1: 2 3 | 3 2
2: 4 4 | 5 5
3: 4 5 | 5 4
4: &amp;quot;a&amp;quot;
5: &amp;quot;b&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これを、ひとまず次のような型としてパースしたい。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;data Rule = Zero [Int]
          | Pairs Int [(Int,Int)]
          | Key Int Char
          deriving Show

-- expected result
[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &amp;#x27;a&amp;#x27;,Key 5 &amp;#x27;b&amp;#x27;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;ul&gt;
&lt;li&gt;０から始まる行は「特殊ルール」として、Zero [Int]で拾う。&lt;&#x2F;li&gt;
&lt;li&gt;それ以外の行は、
&lt;ul&gt;
&lt;li&gt;数字と&amp;quot;|&amp;quot;のみの行についてはPairsで、&lt;&#x2F;li&gt;
&lt;li&gt;アルファベットが含まれる行はKeyで拾う。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;magaparsec-trydeshi-bai-sitekurenai&quot;&gt;Magaparsec - &lt;code&gt;try&lt;&#x2F;code&gt;で失敗してくれない？&lt;&#x2F;h3&gt;
&lt;p&gt;最初に使ったのはMegaparsec。このソースコードから始めよう。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;import qualified Data.Map.Strict as M
import Text.Megaparsec
import Text.Megaparsec.Char
import qualified Data.Text as T
import Data.Void
import Data.Either (rights)

type Parser = Parsec Void String

readInt x = read x :: Int

data Rule = Zero [Int]
          | Pairs Int [(Int,Int)]
          | Key Int Char
          deriving Show

zero :: Parser Rule
zero = do
  string &amp;quot;0: &amp;quot;
  list &amp;lt;- sepBy1 (many alphaNumChar) (char &amp;#x27; &amp;#x27;)
  return $ Zero (map readInt list)

pair :: Parser (Int,Int)
pair = do
  y &amp;lt;- many digitChar
  char &amp;#x27; &amp;#x27;
  z &amp;lt;- many digitChar
  return (readInt y, readInt z)

pairs :: Parser Rule
pairs = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  string &amp;quot;: &amp;quot;
  p &amp;lt;- sepBy1 pair (string &amp;quot; | &amp;quot;)
  return $ Pairs n p

key :: Parser Rule
key = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  string &amp;quot;: \&amp;quot;&amp;quot;
  c &amp;lt;- letterChar
  char &amp;#x27;\&amp;quot;&amp;#x27;
  return $ Key n c

rules = try zero &amp;lt;|&amp;gt; key &amp;lt;|&amp;gt; pairs

main = readFile &amp;quot;day19e.txt&amp;quot; &amp;gt;&amp;gt;= print . rights . map (parse rules &amp;quot;&amp;quot;) . lines
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;cabal repl&lt;&#x2F;code&gt;で&lt;code&gt;main&lt;&#x2F;code&gt;を実行すると、結果はこうなる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[Zero [4,1,5],Key 4 &amp;#x27;a&amp;#x27;,Key 5 &amp;#x27;b&amp;#x27;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Data.Either&lt;&#x2F;code&gt;の&lt;code&gt;rights&lt;&#x2F;code&gt;で強制的に&lt;code&gt;Right&lt;&#x2F;code&gt;のみを抽出しているので分かりにくいが、２〜４行めはパースに失敗している。ちなみにエラーメッセージはかなり難解。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;Right (Zero [4,1,5]),Left (ParseErrorBundle {bundleErrors = TrivialError 1 (Just (Tokens (&amp;#x27;:&amp;#x27; :| &amp;quot; 2&amp;quot;))) (fromList [Tokens (&amp;#x27;:&amp;#x27; :| &amp;quot; \&amp;quot;&amp;quot;),Label (&amp;#x27;a&amp;#x27; :| &amp;quot;lphanumeric character&amp;quot;)]) :| [], bundlePosState = PosState {pstateInput = &amp;quot;1: 2 3 | 3 2&amp;quot;, pstateOffset = 0, pstateSourcePos = SourcePos {sourceName = &amp;quot;&amp;quot;, sourceLine = Pos 1, sourceColumn = Pos 1}, pstateTabWidth = Pos 8, pstateLinePrefix = &amp;quot;&amp;quot;}}),Left (ParseErrorBundle {bundleErrors = TrivialError 1 (Just (Tokens (&amp;#x27;:&amp;#x27; :| &amp;quot; 4&amp;quot;))) (fromList [Tokens (&amp;#x27;:&amp;#x27; :| &amp;quot; \&amp;quot;&amp;quot;),Label (&amp;#x27;a&amp;#x27; :| &amp;quot;lphanumeric character&amp;quot;)]) :| [], bundlePosState = PosState {pstateInput = &amp;quot;2: 4 4 | 5 5&amp;quot;, pstateOffset = 0, pstateSourcePos = SourcePos {sourceName = &amp;quot;&amp;quot;, sourceLine = Pos 1, sourceColumn = Pos 1}, pstateTabWidth = Pos 8, pstateLinePrefix = &amp;quot;&amp;quot;}}),Left (ParseErrorBundle {bundleErrors = TrivialError 1 (Just (Tokens (&amp;#x27;:&amp;#x27; :| &amp;quot; 4&amp;quot;))) (fromList [Tokens (&amp;#x27;:&amp;#x27; :| &amp;quot; \&amp;quot;&amp;quot;),Label (&amp;#x27;a&amp;#x27; :| &amp;quot;lphanumeric character&amp;quot;)]) :| [], bundlePosState = PosState {pstateInput = &amp;quot;3: 4 5 | 5 4&amp;quot;, pstateOffset = 0, pstateSourcePos = SourcePos {sourceName = &amp;quot;&amp;quot;, sourceLine = Pos 1, sourceColumn = Pos 1}, pstateTabWidth = Pos 8, pstateLinePrefix = &amp;quot;&amp;quot;}}),Right (Key 4 &amp;#x27;a&amp;#x27;),Right (Key 5 &amp;#x27;b&amp;#x27;)]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;色々と試行錯誤した結果わかったのは、&lt;code&gt;try&lt;&#x2F;code&gt;でくるんでいるからといって必ず適切なパーサーを選択してくれるわけではない（適切に選択してもらうためには工夫が必要）ということ。&lt;&#x2F;p&gt;
&lt;p&gt;たとえば２行目の&lt;code&gt;1: 2 3 | 3 2&lt;&#x2F;code&gt;のみをパースしてみると、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;*Main&amp;gt; parseTest rules &amp;quot;1: 2 3 | 3 2&amp;quot;
1:2:
  |
1 | 1: 2 3 | 3 2
  |  ^^^
unexpected &amp;quot;: 2&amp;quot;
expecting &amp;quot;: &amp;quot;&amp;quot; or alphanumeric character
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;try&lt;&#x2F;code&gt;でくるんでいるから最終的にはpairsを使ってパースしてくれるはずなのに、そうなっていない。&lt;br &#x2F;&gt;
ちなみに&lt;code&gt;pairs&lt;&#x2F;code&gt;単体でパースすると、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;*Main&amp;gt; parseTest pairs &amp;quot;1: 2 3 | 3 2&amp;quot;
Pairs 1 [(2,3),(3,2)]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;となって正しい結果が出るので、&lt;code&gt;pairs&lt;&#x2F;code&gt;自体にミスがあるわけではなさそうだ。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;rules&lt;&#x2F;code&gt;はまず&lt;code&gt;zero&lt;&#x2F;code&gt;をトライするが、&lt;code&gt;string &amp;quot;0: &amp;quot;&lt;&#x2F;code&gt;にマッチしないので失敗し、backtrackが発生する。&lt;br &#x2F;&gt;
次に&lt;code&gt;key&lt;&#x2F;code&gt;をトライする。そうすると、最初の&lt;code&gt;many alphaNumChar&lt;&#x2F;code&gt;は成功するが、次の&lt;code&gt;string &amp;quot;: \&amp;quot;&amp;quot;&lt;&#x2F;code&gt;は失敗するのでまたbacktrackが発生する…はずなのだがそうならず、パースは失敗に終わる。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tryyi-jiang-noxuan-ze-zhi-noshun-fan-nanoka&quot;&gt;&lt;code&gt;try&lt;&#x2F;code&gt;以降の選択肢の順番なのか？&lt;&#x2F;h3&gt;
&lt;p&gt;最初に、&lt;code&gt;try&lt;&#x2F;code&gt;のくるみ方に問題があるのかもしれないと考えて、&lt;code&gt;try&lt;&#x2F;code&gt;のあとを色々と変えてみた。すると実際、&lt;code&gt;rules = try key &amp;lt;|&amp;gt; zero &amp;lt;|&amp;gt; pairs&lt;&#x2F;code&gt;とした場合は、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &amp;#x27;a&amp;#x27;,Key 5 &amp;#x27;b&amp;#x27;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;となり成功している。&lt;&#x2F;p&gt;
&lt;p&gt;さらに、&lt;code&gt;rules = try key &amp;lt;|&amp;gt; pairs &amp;lt;|&amp;gt; zero&lt;&#x2F;code&gt;の場合。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &amp;#x27;a&amp;#x27;,Key 5 &amp;#x27;b&amp;#x27;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;一見成功しているように見えるが、第１行めが&lt;code&gt;Zero&lt;&#x2F;code&gt;ではなく&lt;code&gt;Pairs&lt;&#x2F;code&gt;でのパースになってしまっているので間違っている。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;zero&lt;&#x2F;code&gt;, &lt;code&gt;pairs&lt;&#x2F;code&gt;, &lt;code&gt;key&lt;&#x2F;code&gt;の順番を入れ替えて試した結果は以下の通り。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;order&lt;&#x2F;th&gt;&lt;th align=&quot;left&quot;&gt;result&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;T&#x2F;F&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;zero key pairs&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;[Zero [4,1,5],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;F&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;zero pairs key&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)]]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;F&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;pairs zero key&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;F&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;pairs key zero&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;F&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;key zero pairs&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;T&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;key pairs zero&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &#x27;a&#x27;,Key 5 &#x27;b&#x27;]&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;F&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;このあたりで薄々ストーリーが見えてくる。&lt;code&gt;zero&lt;&#x2F;code&gt;で拾いたいのに&lt;code&gt;pairs&lt;&#x2F;code&gt;になってしまっているのは、&lt;code&gt;0: 4 1 5&lt;&#x2F;code&gt;で言うと&amp;quot;1&amp;quot;までは&lt;code&gt;pairs&lt;&#x2F;code&gt;で拾えてしまえることがまず発端になっている。それだけなら残りを失敗するのでいいじゃないか、となりそうだが、途中でパースが止まっても成功扱いとなり、次の行に進んでしまう。&lt;&#x2F;p&gt;
&lt;p&gt;実際、&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;pairs :: Parser Rule
pairs = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  string &amp;quot;: &amp;quot;
  p &amp;lt;- sepBy pair (string &amp;quot; | &amp;quot;)
  return $ Pairs n p
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;と、&lt;code&gt;sepBy1&lt;&#x2F;code&gt;から&lt;code&gt;sepBy&lt;&#x2F;code&gt;にしてみると、結果は&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Pairs 4 [],Pairs 5 []]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;となって最後の２行が&lt;code&gt;pairs&lt;&#x2F;code&gt;で拾われてしまっていることがわかる。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;megaparsecdenoeofnoju-dong&quot;&gt;Megaparsecでのeofの挙動&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;4: &amp;quot;a&amp;quot;&lt;&#x2F;code&gt;が&lt;code&gt;pairs&lt;&#x2F;code&gt;ではなく&lt;code&gt;key&lt;&#x2F;code&gt;で拾うべき行だということをプログラムに伝えるには、&lt;code&gt;try&lt;&#x2F;code&gt;以降のパーサーの順番をあれこれいじるよりも&lt;code&gt;eof&lt;&#x2F;code&gt;を使えばよいのではないか、と思いつき、以下のようにしてみる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;zero :: Parser Rule
zero = do
  string &amp;quot;0: &amp;quot;
  list &amp;lt;- sepBy1 (many alphaNumChar) (char &amp;#x27; &amp;#x27;)
  eof
  return $ Zero (map readInt list)

pair :: Parser (Int,Int)
pair = do
  y &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  char &amp;#x27; &amp;#x27;
  z &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  return (y,z)

pairs :: Parser Rule
pairs = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  string &amp;quot;: &amp;quot;
  p &amp;lt;- sepBy1 pair (string &amp;quot; | &amp;quot;)
  eof
  return $ Pairs n p

key :: Parser Rule
key = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many alphaNumChar
  string &amp;quot;: \&amp;quot;&amp;quot;
  c &amp;lt;- letterChar
  char &amp;#x27;\&amp;quot;&amp;#x27;
  eof
  return $ Key n c
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;しかし結果は変わらず、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;-- try zero &amp;lt;|&amp;gt; pairs &amp;lt;|&amp;gt; key
[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)]]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;入力の終了にのみマッチするはずの&lt;code&gt;eof&lt;&#x2F;code&gt;が動いていない。&lt;&#x2F;p&gt;
&lt;p&gt;念のため、テストパーサーを書いてみるとこちらはちゃんと機能する。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;test :: Parser String
test = do
  s &amp;lt;- many alphaNumChar
  eof
  return s

---

*Main&amp;gt; parseTest test &amp;quot;aaa&amp;quot;
&amp;quot;aaa&amp;quot;
*Main&amp;gt; parseTest test &amp;quot;aaa111&amp;quot;
&amp;quot;aaa111&amp;quot;
*Main&amp;gt; parseTest test &amp;quot;aaa111+++&amp;quot;
1:7:
  |
1 | aaa111+++
  |       ^
unexpected &amp;#x27;+&amp;#x27;
expecting alphanumeric character or end of input
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;attoparsecdenoju-dong&quot;&gt;Attoparsecでの挙動&lt;&#x2F;h3&gt;
&lt;p&gt;つまり、&lt;code&gt;try&lt;&#x2F;code&gt;でくるんだパーサーにおいて&lt;code&gt;eof&lt;&#x2F;code&gt;がちゃんと動いていないのではないか？ということだ。&lt;br &#x2F;&gt;
どこかのコードが間違っている可能性も十分あるし、ソースコードを読んでいないのでMegaparsecの調査としてはここまでなのだが、本来であれば、&lt;code&gt;try&lt;&#x2F;code&gt;以降のパーサーの順序は極力考慮せず組み立てられるのが理想…だと思うので、これは困る。ちなみに、後に検証してみたところ、Parsecの&lt;code&gt;try&lt;&#x2F;code&gt;&#x2F;&lt;code&gt;eof&lt;&#x2F;code&gt;でも同じ問題が発生する。&lt;&#x2F;p&gt;
&lt;p&gt;そこで、試しにAttoparsecを使ってみるとこちらはうまくいった。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;import Data.Attoparsec.Text
import qualified Data.Text as T
import qualified Data.Text.IO as TIO
import Data.Either (rights)

readInt x = read x :: Int

data Rule = Zero [Int]
          | Pairs Int [(Int,Int)]
          | Key Int Char
          deriving Show

zero :: Parser Rule
zero = do
  string &amp;quot;0: &amp;quot;
  list &amp;lt;- many1 digit `sepBy1` char &amp;#x27; &amp;#x27;
  endOfInput
  return $ Zero (map readInt list)

pair :: Parser (Int,Int)
pair = do
  x &amp;lt;- readInt &amp;lt;$&amp;gt; many1 digit
  space
  y &amp;lt;- readInt &amp;lt;$&amp;gt; many1 digit
  return (x,y)

pairs :: Parser Rule
pairs = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many1 digit
  string &amp;quot;: &amp;quot;
  p &amp;lt;- sepBy1 pair (string &amp;quot; | &amp;quot;)
  endOfInput
  return $ Pairs n p

key :: Parser Rule
key = do
  n &amp;lt;- readInt &amp;lt;$&amp;gt; many1 digit
  string &amp;quot;: \&amp;quot;&amp;quot;
  c &amp;lt;- letter
  char &amp;#x27;\&amp;quot;&amp;#x27;
  endOfInput
  return $ Key n c

rules = choice [pairs, key, zero]

main = TIO.readFile &amp;quot;day19e.txt&amp;quot; &amp;gt;&amp;gt;= print . rights . map (parseOnly rules) . T.lines

---

*Main&amp;gt; main
[Zero [4,1,5],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &amp;#x27;a&amp;#x27;,Key 5 &amp;#x27;b&amp;#x27;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;もちろん、&lt;code&gt;choice&lt;&#x2F;code&gt;以降のリスト内の順序をどのパターンにしても、結果は変わらなかった。&lt;&#x2F;p&gt;
&lt;p&gt;ちなみに各パーサーの&lt;code&gt;endOfInput&lt;&#x2F;code&gt;を外すと、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;-- rules = choice [pairs, key, zero]
[Pairs 0 [(4,1)],Pairs 1 [(2,3),(3,2)],Pairs 2 [(4,4),(5,5)],Pairs 3 [(4,5),(5,4)],Key 4 &amp;quot;a&amp;quot;,Key 5 &amp;quot;b&amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;となって１行目を&lt;code&gt;pairs&lt;&#x2F;code&gt;で拾ってしまっているので、やっぱり&lt;code&gt;endOfInput&lt;&#x2F;code&gt;が機能していることがわかる。&lt;&#x2F;p&gt;
&lt;p&gt;コード自体はほぼ変わらない。主な変更点としては、&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Megaparsec&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Attoparsec&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;try&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;choice&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;eof&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;&lt;code&gt;endOfInput&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;まず１点め、&lt;code&gt;try&lt;&#x2F;code&gt;でなく&lt;code&gt;choice&lt;&#x2F;code&gt;を使うというのは、Attoparsecがデフォルトで失敗時backtrackをする仕様のためで、これは素晴らしい（&lt;code&gt;try&lt;&#x2F;code&gt;も実装されているが、これはParsecとの互換性のためと&lt;a href=&quot;https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;attoparsec-0.14.1&#x2F;docs&#x2F;Data-Attoparsec-ByteString.html#v:try&quot;&gt;明記されている&lt;&#x2F;a&gt;）。&lt;br &#x2F;&gt;
そしてMegaparsecの&lt;code&gt;eof&lt;&#x2F;code&gt;とAttoparsecの&lt;code&gt;endOfInput&lt;&#x2F;code&gt;は、どうやら局所的に違う挙動をするらしい。（MegaparsecとParsecがこの点で同じ動きをしたのは、MegaparsecがParsecのフォークだからかもしれない）&lt;&#x2F;p&gt;
&lt;p&gt;同じようなディテールで頭を悩ませている人がいたら、参考になれば幸いです。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Haskell環境再構築</title>
            <pubDate>Wed, 05 May 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/restart-haskell/</link>
            <guid>https://kyoheiu.gitlab.io/post/restart-haskell/</guid>
            <description>&lt;p&gt;ここ数ヶ月、ずっとimperative programmingをしていてちょっと疲れてきたのと、今Haskellに戻ったら前よりはもう少し書ける／わかるようになっているかもしれないという期待で、あらためてHaskellに入門してみる。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;huan-jing-gou-zhu&quot;&gt;環境構築&lt;&#x2F;h3&gt;
&lt;p&gt;前にやっていたときは確か存在していなかったような気がするのだが、&lt;code&gt;ghcup&lt;&#x2F;code&gt;という&lt;code&gt;rustup&lt;&#x2F;code&gt;的なツールが登場していたのでさっそく入れてみる。&lt;br &#x2F;&gt;
これはghc, cabal, haskell-language-server(HLS)のインストール・バージョン管理を行ってくれるありがたいツールで、途中２回ほどコマンド入力する場面があるので完全放置では完了まで行かないが、スムーズにインストールが可能。以前はstackを使っていたが、cabalがだいぶフレンドリーになってきているという噂を見かけたのでcabal一本でやってみようかと思っている。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gui-men-haskell-language-server&quot;&gt;鬼門・haskell-language-server&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;hie&lt;&#x2F;code&gt;の頃からHaskellのLSPにはいい思い出がなく、ビルド時間が地獄のように長いとか、頑張って入れても全然動かないとかで、この辺の環境構築周りのもどかしさもあっていったん離れることに決めたのだった。今はというと、ほぼ公式のLSPであるHLSがghcupでツルッと入ってくる。これを使えばいい。&lt;&#x2F;p&gt;
&lt;p&gt;ただ、Arch Linux系のディストロを使っている人は、HLSとVS Codeのインテグレーションでおそらく引っかかるだろう。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;haskell&#x2F;haskell-language-server&#x2F;issues&#x2F;236&quot;&gt;VSCode extension not detecting Cabal&#x2F;Stack due to incomplete $PATH in &lt;code&gt;&#x2F;etc&#x2F;profile&lt;&#x2F;code&gt; · Issue #236 · haskell&#x2F;haskell-language-server&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;このissueで指摘されているが、Arch系の場合、&lt;code&gt;.bashrc&lt;&#x2F;code&gt;にghcupのPATHを書いてもVS Codeが認識せず、&lt;code&gt;etc&#x2F;profile&lt;&#x2F;code&gt;に書かないと動かない。&lt;del&gt;そして僕の場合は、&lt;code&gt;etc&#x2F;profile&lt;&#x2F;code&gt;に書いた上で、（ランチャーからではなく）ターミナルから&lt;code&gt;code&lt;&#x2F;code&gt;とコマンドを打って起動しないとHLSが動かなかった。ここまでわかるのに半日費やしてしまった…。&lt;&#x2F;del&gt;&lt;&#x2F;p&gt;
&lt;p&gt;(2021-05-22追記)&lt;code&gt;etc&#x2F;profile&lt;&#x2F;code&gt;への記述が間違っていた模様。以下のようにすればVS Codeでバッチリ動いてくれました。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# etc&amp;#x2F;profile
PATH=~&amp;#x2F;.ghcup&amp;#x2F;bin&amp;#x2F;:$PATH
PATH=~&amp;#x2F;.cabal&amp;#x2F;bin&amp;#x2F;:$PATH
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;ランチャーからの起動が実質できないのは良くないので、これを機にneovimでの編集に移行してみる。&lt;br &#x2F;&gt;
ただしvim&#x2F;neovimであっても、Arch系であれば&lt;code&gt;etc&#x2F;profile&lt;&#x2F;code&gt;にPATHを書かなければならないのは同じ（記入後、要再起動）。その上で、HLS公式のイントロダクションに書いてあるとおり、CocでHLSを設定すれば、動く。&lt;&#x2F;p&gt;
&lt;p&gt;久々にHaskellを書くと、頭も指も全然動かなくて逆に面白い。&lt;br &#x2F;&gt;
以前いじっていたときには存在に気づかなかったパイプライン演算子を使って、Project Eulerの２問め。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;import Data.Function

fib:: Integer -&amp;gt; Integer -&amp;gt; Integer -&amp;gt; Integer
fib a b count
    | count == 1 || count == 0 = b
    | count &amp;gt;= 2 = fib b (a+b) (count-1)
    | otherwise = 0

makeFib = fib 1 1

euler2FibList:: Integer -&amp;gt; Integer
euler2FibList n = takeWhile (\x -&amp;gt; makeFib x &amp;lt; n) [1..] &amp;amp; map makeFib &amp;amp; filter even &amp;amp; sum

main = print $ euler2FibList 4000000
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;makeFib&lt;&#x2F;code&gt;を２回使っているのがかっこよくないですね。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>OSSのREADME.md更新について</title>
            <pubDate>Sat, 01 May 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/update-readme/</link>
            <guid>https://kyoheiu.gitlab.io/post/update-readme/</guid>
            <description>&lt;p&gt;先日publicリポジトリに移したmarkdownパーサ&lt;code&gt;nmark&lt;&#x2F;code&gt;をちまちま更新しているのだが、更新するたびに以下のような作業が発生していてだんだん面倒になってきた。&lt;&#x2F;p&gt;
&lt;script&gt;window.addEventListener(&quot;message&quot;, function(e) {var i = e.data.split(&quot;:&quot;)[1];var h = e.data.split(&quot;:&quot;)[2];if (e.data.split(&quot;:&quot;)[0] == &quot;swimlanes-io&quot; &amp;&amp; i &amp;&amp; h) {document.getElementById(&quot;__sw-io-&quot; + i).setAttribute(&quot;style&quot;,&quot;height:&quot; + h + &quot;px&quot;);}}, false);&lt;&#x2F;script&gt;&lt;div id=&quot;__sw-io-fZAw&quot;&gt;&lt;iframe style=&quot;border:none; width:100%; height:100%&quot; scrolling=&quot;no&quot; src=&quot;https:&#x2F;&#x2F;cdn.swimlanes.io&#x2F;dist&#x2F;embeded.html#fZA7D8IwDIT3&#x2F;ApvQKTC3gEJiYqJhYq9aWJoROpEeUj039MHUKlDN8v3new7zqkV&#x2F;gXJKRERvE1RE3LO2LTPjjAO+Y8ItsXYaHrOgBRBbMvyssuBEBVECx6lcDF5hBpJNgPJ&#x2F;tjCU5Fua4OgKURhzHSvWsVBQqZyjwZFwFFc4ZvOoX&#x2F;0qWCzPwwC1EkbtVlYvjGldR3g21kf+yjz98s67lMdt+J0vhbsAw==#fZAw&quot;&gt;&lt;&#x2F;iframe&gt;&lt;&#x2F;div&gt;
&lt;p&gt;（さっき見つけた&lt;a href=&quot;https:&#x2F;&#x2F;swimlanes.io&#x2F;&quot;&gt;swimlane.io&lt;&#x2F;a&gt;を使ってみたかったのであえて作ってみた）&lt;&#x2F;p&gt;
&lt;p&gt;今思いつく解決策としては、&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;ベンチマーク出力を２つの外部プログラム（静的サイトジェネレータ、hyperfine）に頼っているので、&lt;code&gt;nmark&lt;&#x2F;code&gt;内に実装し、SCFなりでREADME.mdを生成する関数も書いて更新する。&lt;&#x2F;li&gt;
&lt;li&gt;ベンチマークを画像として出力し、リポジトリに含めて&lt;code&gt;git push&lt;&#x2F;code&gt;し、README.md内には画像リンクとして取り込む。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;git push&lt;&#x2F;code&gt;をトリガーとしてベンチマークをとってくれるCIを設定し、出力を取り込んでREADME.mdを更新する（もしくは更新するところまでGitHub Actionsなどで実装する）。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;という感じだが、&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;nmark&lt;&#x2F;code&gt;内に全部取り込むのは（可能だが）間違っている気がする&lt;&#x2F;li&gt;
&lt;li&gt;数字を画像で出すのは嫌だ&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;で、CIを勉強してみようかなぁと思っている。最終的にはジェネレータを使わないという選択になりそうな気がする。&lt;&#x2F;p&gt;
&lt;p&gt;こんなふうに、機能を追加したりバグを修正したりするたびにREADME.md内の細かい数字をアップデートしないといけない状況というのはあると思うのだけれど、何か効率的なやり方があるんだろうか。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zhui-ji&quot;&gt;追記&lt;&#x2F;h3&gt;
&lt;p&gt;シェルスクリプトの代わりにNimscriptを書いて、パフォーマンス比較の詳細を記したmarkdownファイルをREADME.mdとは別に作り、そこに&lt;code&gt;hyperfine&lt;&#x2F;code&gt;の結果をコピーするというやり方にしてみた。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nim&quot; class=&quot;language-nim &quot;&gt;&lt;code class=&quot;language-nim&quot; data-lang=&quot;nim&quot;&gt;mode = ScriptMode.Verbose

const version = &amp;quot;0.1.6&amp;quot;

const text = &amp;quot;&amp;quot;&amp;quot;
# Perfomance comparison detail
...
### nmark@&amp;quot;&amp;quot;&amp;quot; 

cd &amp;quot;..&amp;#x2F;casa&amp;quot;

exec(&amp;quot;nimble install nmark&amp;quot;)
exec(&amp;quot;nim c -d:release casa&amp;quot;)
exec(&amp;quot;hyperfine &amp;#x27;.&amp;#x2F;casa build&amp;#x27; --export-markdown nmark.md&amp;quot;)
let s = text &amp;amp; version &amp;amp; &amp;quot;&amp;quot;&amp;quot;
&amp;gt;&amp;gt;
&amp;quot;&amp;quot;&amp;quot; &amp;amp; readFile(&amp;quot;nmark.md&amp;quot;)

cd &amp;quot;..&amp;#x2F;nmark&amp;quot;

writeFile(&amp;quot;perfcmp.md&amp;quot;, s)

echo &amp;quot;Done.&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;手動でいじるのは定数として入れているバージョン番号のみなのでだいぶ楽にはなった。この番号も、何らかのスクリプトで.nimbleファイルからとってきたいところだが、適当な関数が見つからないためとりあえずここまでにしている。tomlと見なしてパースすればいいような気もする。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>nmark - a markdown parser written in Nim</title>
            <pubDate>Tue, 27 Apr 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/nmark/</link>
            <guid>https://kyoheiu.gitlab.io/post/nmark/</guid>
            <description>&lt;p&gt;Fast markdown parser, based on CommonMark, written in Nim.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kyoheiu&#x2F;nmark&quot;&gt;kyoheiu&#x2F;nmark&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;usage&quot;&gt;Usage&lt;&#x2F;h3&gt;
&lt;pre data-lang=&quot;nim&quot; class=&quot;language-nim &quot;&gt;&lt;code class=&quot;language-nim&quot; data-lang=&quot;nim&quot;&gt;import nmark

let txt = &amp;quot;&amp;quot;&amp;quot;
&amp;gt; Lorem ipsum dolor
sit amet.
&amp;gt; - Qui *quodsi iracundia*
&amp;gt; - aliquando id
&amp;quot;&amp;quot;&amp;quot;

echo txt.markdown
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;...and it&#x27;s done.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# output
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;Lorem ipsum dolor
sit amet.&amp;lt;&amp;#x2F;p&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;Qui &amp;lt;em&amp;gt;quodsi iracundia&amp;lt;&amp;#x2F;em&amp;gt;&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;li&amp;gt;aliquando id&amp;lt;&amp;#x2F;li&amp;gt;
&amp;lt;&amp;#x2F;ul&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;You can use tables in &lt;code&gt;nmark&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;| abc | defghi |
:-: | -----------:
bar | baz
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;is converted to:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;table&amp;gt;
&amp;lt;thead&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;th align=&amp;quot;center&amp;quot;&amp;gt;abc&amp;lt;&amp;#x2F;th&amp;gt;
&amp;lt;th align=&amp;quot;right&amp;quot;&amp;gt;defghi&amp;lt;&amp;#x2F;th&amp;gt;
&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;&amp;#x2F;thead&amp;gt;
&amp;lt;tbody&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td align=&amp;quot;center&amp;quot;&amp;gt;bar&amp;lt;&amp;#x2F;td&amp;gt;
&amp;lt;td align=&amp;quot;right&amp;quot;&amp;gt;baz&amp;lt;&amp;#x2F;td&amp;gt;
&amp;lt;&amp;#x2F;tr&amp;gt;
&amp;lt;&amp;#x2F;tbody&amp;gt;
&amp;lt;&amp;#x2F;table&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;(Tables need to be separated from other blocks by empty line.)&lt;&#x2F;p&gt;
&lt;h3 id=&quot;performance-comparison&quot;&gt;Performance comparison&lt;&#x2F;h3&gt;
&lt;p&gt;One of the reason I&#x27;m working on this parser is that other markdown parser librarys written in Nim seemed relatively slow. Here is a comparison between &lt;code&gt;nim-markdown&lt;&#x2F;code&gt;, which I think is the standard Nim markdown parser, and &lt;code&gt;nmark&lt;&#x2F;code&gt;, through a static site generator(which, btw, I made) and &lt;code&gt;hyperfine&lt;&#x2F;code&gt;.&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;.&#x2F;casa build&lt;&#x2F;code&gt; generates 100 same htmls containing a lot of markdown delimiter. For detail please check my &lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kyoheiu&#x2F;Casa&quot;&gt;repo&lt;&#x2F;a&gt;.&lt;&#x2F;p&gt;
&lt;h4 id=&quot;nim-markdown-0-8-5&quot;&gt;nim-markdown@0.8.5 &amp;gt;&amp;gt;&lt;&#x2F;h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Command&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Mean [ms]&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Min [ms]&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Max [ms]&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Relative&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;.&#x2F;casa build&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;296.1 ± 12.2&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;287.6&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;322.4&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;1.00&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h4 id=&quot;nmark-0-1-3&quot;&gt;nmark@0.1.3 &amp;gt;&amp;gt;&lt;&#x2F;h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;left&quot;&gt;Command&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Mean [ms]&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Min [ms]&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Max [ms]&lt;&#x2F;th&gt;&lt;th align=&quot;right&quot;&gt;Relative&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;left&quot;&gt;&lt;code&gt;.&#x2F;casa build&lt;&#x2F;code&gt;&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;53.1 ± 7.0&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;51.2&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;91.7&lt;&#x2F;td&gt;&lt;td align=&quot;right&quot;&gt;1.00&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;h3 id=&quot;caution&quot;&gt;Caution&lt;&#x2F;h3&gt;
&lt;p&gt;This is still work-in-progess project, and does not FULLY pass the &lt;a href=&quot;https:&#x2F;&#x2F;spec.commonmark.org&#x2F;0.29&#x2F;&quot;&gt;spec-test of CommonMark&lt;&#x2F;a&gt;. For example,&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;&amp;gt; foo
bar
===
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;... is, by &lt;code&gt;nmark&lt;&#x2F;code&gt;, converted to:&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;blockquote&amp;gt;
&amp;lt;h1&amp;gt;foo
bar&amp;lt;&amp;#x2F;h1&amp;gt;
&amp;lt;&amp;#x2F;blockquote&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Though I believe &lt;code&gt;nmark&lt;&#x2F;code&gt; is enough for normal usage, I&#x27;m working on improving the accuracy and performance. And issues, pull requests always welcome.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>starshipで絵文字を表示させる（Arch Linux）</title>
            <pubDate>Wed, 31 Mar 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/starship-emoji/</link>
            <guid>https://kyoheiu.gitlab.io/post/starship-emoji/</guid>
            <description>&lt;p&gt;先日のArch Linux再インストールに伴い、色々とアプリケーションを入れ直していたのだけれど、&lt;a href=&quot;https:&#x2F;&#x2F;starship.rs&#x2F;&quot;&gt;starship&lt;&#x2F;a&gt;の絵文字表示ができなくなってしまいちょっと手こずったので、メモ。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;bi-yao-napatukezi&quot;&gt;必要なパッケージ&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;starship&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;nerd font(AURの&lt;code&gt;nerd-fonts-source-code-pro&lt;&#x2F;code&gt;を使っているが何でもいいはず)&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;noto-emoji&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;noto-fonts&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;noto-fonts-cjk&lt;&#x2F;code&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;最後の２つのパッケージがないとカバーできないUnicode絵文字が微妙に存在する（たとえば[⇡]）。&lt;&#x2F;p&gt;
&lt;p&gt;starshipの意義については正直なんとも言えないが、デバッグを繰り返しているときに前の実行結果との切れ目がわかりやすい…という効果はある。かもしれない。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>バックアップについて考える</title>
            <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/about-backup/</link>
            <guid>https://kyoheiu.gitlab.io/post/about-backup/</guid>
            <description>&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;reinstall-arch&#x2F;&quot;&gt;Arch Linuxを再インストールした話&lt;&#x2F;a&gt;に関連して。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dotfilesnoxi-ifang&quot;&gt;dotfilesの扱い方&lt;&#x2F;h3&gt;
&lt;p&gt;今回感じたのは、最低限i3と、ターミナルエミュレーター &#x2F; vifm &#x2F; nvimを入れて、dotfilesをリモートリポジトリから引っ張ってくれば作業環境は整うわけなので、追加のバックアップ作業はもしかしたら要らないのかも、ということ。これまではtimeshiftで定期的にバックアップをとっていたのだが、結局一度も使わないままだったし…。&lt;br &#x2F;&gt;
逆に上記のパッケージのdotfilesがリモートに存在しない場合、動くことは動くが、細かい設定を整えようとするとかなり面倒くさいことになってしまうので、思っていた以上にdotfilesのバックアップは大事だったとも言える（r&#x2F;unixpornに貼りつけるだけのアレじゃなかった）。&lt;&#x2F;p&gt;
&lt;p&gt;シェルスクリプトでdotfilesの設定ファイルのシンボリックリンクを各所に貼るプログラムを書いている人が多いと思うが、同じようなものをNimでさくっと書いてみたので貼っておきます。&lt;&#x2F;p&gt;
&lt;script src=&quot;https:&#x2F;&#x2F;gist.github.com&#x2F;kyoheiu&#x2F;9b5c634d38f26d1b67ad1d34bb29ef76.js&quot;&gt;&lt;&#x2F;script&gt;
&lt;p&gt;&lt;code&gt;os&lt;&#x2F;code&gt;ライブラリの&lt;code&gt;createSymlink&lt;&#x2F;code&gt;は同名のファイルが存在した場合failになるので、ファイルを削除してからシンボリックリンクを作成している。利用する場合は自己責任でお願いします。
nvimのcolorsディレクトリを除いているのはこれ以上コードが入れ子になるのが嫌だったから、程度の理由。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shu-kitupanasikodonoxi-ifang&quot;&gt;書きっぱなしコードの扱い方&lt;&#x2F;h3&gt;
&lt;p&gt;これまで練習用に書いてきたHaskellやらRustやらのコードはクリーンインストールによりすべて消えてしまった。まあ見返すことはほとんどなかったし、作り途中のプロジェクトはGitLabのプライベートリポジトリに上げながらやっているから無事だ。それ以外にも、ちょっと面倒な感じの、たとえばHaskellでスクレイピングするプログラムの骨子などはサイトに上げているので、残りのちまちましたやつ（Project Eulerの解答とか）は別にいいかな…と思いつつ、でもやっぱりちょっとさびしい。&lt;br &#x2F;&gt;
こういう断片的なコードをいちいちGitHub GistsやGitLab Snippetsに上げるか、それとも書き捨てのつもりで気にしないかはけっこう微妙な問題だと思う。見返さなかったとはいえ、振り返ると意外と発見があったり、最近書いていない言語を思い出すのに使ったり、ということもあるだろうし、悩ましい。&lt;br &#x2F;&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;note.com&#x2F;konojunya&#x2F;n&#x2F;n461544d2f881&quot;&gt;Gistsに自動アップロードするCLIを書いている&lt;&#x2F;a&gt;方を見つけて、なるほど、と思ったが、書いた端から上げたい感じもある。VS Codeのエクステンションとか、もうありそうだな…と思ったら&lt;a href=&quot;https:&#x2F;&#x2F;github.com&#x2F;kenhowardpdx&#x2F;vscode-gist&quot;&gt;あった&lt;&#x2F;a&gt;。自分なりに使いそうなフローで何かCLIを作ってみてもいいかもしれない。&lt;br &#x2F;&gt;
GitLabも&lt;a href=&quot;https:&#x2F;&#x2F;docs.gitlab.com&#x2F;ee&#x2F;api&#x2F;snippets.html#get-a-single-snippet&quot;&gt;Snippets APIの紹介がとてもよくまとまっている&lt;&#x2F;a&gt;のでけっこう使いやすそう。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;jing-de-saitozieneretanoluo-tosixue&quot;&gt;静的サイトジェネレーターの落とし穴(?)&lt;&#x2F;h3&gt;
&lt;p&gt;それと、Hugo &#x2F; Zolaなどの静的サイトジェネレーターを使っている場合は、サイト上にフロントマター付きの.mdファイルが存在するわけではないので、もしデータが消えてしまった場合はサイト上のテキストをコピーしてきて、あらためて.mdとしてタグ付けをしないといけない（もしくはサイトをスクレイピングして.mdファイルを生成するプログラムを書くか。できなくはないが面倒ではある）。&lt;br &#x2F;&gt;
幸い、数か月前までプライベートリポジトリにサイトごと上げていたので、手作業での.md復旧は数記事で済んだのだが、これがまったくバックアップがない状況だったらけっこう辛かったかもしれない。プライベートリポジトリでもいいので更新時にpushしておくのが大事だとしみじみ思った（もちろん、github.ioなどでサイトをホスティングしている場合は当然バックアップがとれているのでこんなことは考えなくていい）。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;owarini&quot;&gt;おわりに&lt;&#x2F;h3&gt;
&lt;p&gt;以上に書いたものはすべてgitのリモートリポジトリの存在が前提になっている。ここに何か落とし穴がまだあるかもしれない。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Arch Linux再インストールで発見したこと</title>
            <pubDate>Sun, 21 Mar 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/reinstall-arch/</link>
            <guid>https://kyoheiu.gitlab.io/post/reinstall-arch/</guid>
            <description>&lt;p&gt;先日自分のミスでパーティションをブレイクしてしまい、Arch Linuxが起動不可の状態に。インストールメディアを準備して&lt;code&gt;arch-chroot&lt;&#x2F;code&gt;すればもしかしたら救出できたのかもしれなかったが、少し時間があったのでこの際、とクリーンインストールをした（ちょうどKDE neonを入れたサブ機を用意したてだったのが本当にラッキーだった）。前回インストールをしたのは１年前だったと思うが、少し様子が変わっていたのでメモ。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;roguwotoreruyouninatuteita&quot;&gt;ログをとれるようになっていた&lt;&#x2F;h4&gt;
&lt;p&gt;もしかするとこれは前からだったかもしれないが、インストール作業のログをとれるようになっている。また、ArchWikiへの誘導も冒頭にあって、ちょっぴり親切な雰囲気が醸し出されていた。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;wifi-menugashi-enai&quot;&gt;wifi-menuが使えない&lt;&#x2F;h4&gt;
&lt;p&gt;最新のisoでは&lt;code&gt;wifi-menu&lt;&#x2F;code&gt;が含まれていないのか、開幕&lt;code&gt;wifi-menu&lt;&#x2F;code&gt;でとりあえずネットワーク接続を確保するということができない。&lt;br &#x2F;&gt;
ArchWikiでは&lt;code&gt;iwctl&lt;&#x2F;code&gt;による接続を推奨している。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;iwctl
device list # デバイス名の確認
station &amp;lt;デバイス名&amp;gt; connect &amp;lt;アクセスポイント名&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これでOK。接続したら&lt;code&gt;ctrl+C&lt;&#x2F;code&gt;で抜けることを忘れずに。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;systemd-bootnoshe-ding-womisusitemoqi-kanai&quot;&gt;systemd-bootの設定をミスしても泣かない&lt;&#x2F;h4&gt;
&lt;p&gt;ここで何回かミスってしまったのだが、最初からやり直す必要はない。インストールメディアを挿したまま再起動し、ネットワーク接続を確保した後、マウント。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;mount &amp;#x2F;dev&amp;#x2F;device2 &amp;#x2F;mnt
mount &amp;#x2F;dev&amp;#x2F;device1 &amp;#x2F;mnt&amp;#x2F;boot
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;その後、&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;arch-chroot &amp;#x2F;mnt
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これで&lt;code&gt;&#x2F;boot&lt;&#x2F;code&gt;以下の設定ファイルもいじれるようになる。&lt;&#x2F;p&gt;
&lt;p&gt;個人的にミスしやすいポイントとしては、&lt;code&gt;&#x2F;boot&#x2F;loader&#x2F;entries&#x2F;arch.conf&lt;&#x2F;code&gt;内のoptions行。&lt;br &#x2F;&gt;
&lt;code&gt;blkid&lt;&#x2F;code&gt;で調べたPARTUUIDを入れるのだが、間違えてUUIDを入れるとか、違うパーティションのPARTUUIDを入れてしまうといったミスが起こりやすい。ここは落ち着いて写真を撮って進行しましょう。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;systemddeyarikurisuruyounizu-mu&quot;&gt;systemdでやりくりするように組む&lt;&#x2F;h4&gt;
&lt;p&gt;以前は&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;archinstall&#x2F;&quot;&gt;この記事&lt;&#x2F;a&gt;にあるようにブートローダーとしてgrubを選択していたのだけど、このコマンドを正確に打つのめっちゃ大変ですよね。systemd-bootに切り替えたほうがインストールは楽になるはず。&lt;br &#x2F;&gt;
ネットワーク接続についても、複数のパッケージで組もうとするとその分再インストールの手間が増え、手順も複雑になって後々わけがわからなくなるので、極力systemd内で生きていくように選択していったほうがよいように思う。&lt;br &#x2F;&gt;
ネットワーク接続は僕の場合、&lt;code&gt;iwd&lt;&#x2F;code&gt;を入れて&lt;code&gt;iwctl&lt;&#x2F;code&gt;で接続したのち、systemd-networkdとsystemd-resolvedを&lt;code&gt;enable&lt;&#x2F;code&gt;し、&lt;code&gt;dhcpcd&lt;&#x2F;code&gt;も入れてnetworkdの各種設定ファイルを作成、で再起動後も自動接続できた（こう書くとかなり面倒くさそうだが、意外とそうでもない）。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Rust入門ルート</title>
            <pubDate>Sat, 13 Feb 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/beginning-rust/</link>
            <guid>https://kyoheiu.gitlab.io/post/beginning-rust/</guid>
            <description>&lt;p&gt;３、４回の挫折を経てようやく「なんとなくRustわかってきたかな」というところまで来れたので、個人的に効率的と考える入門ルートを紹介してみたい。&lt;&#x2F;p&gt;
&lt;p&gt;結論から書くと、&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;『プログラミング言語Rust入門』を読む&lt;&#x2F;li&gt;
&lt;li&gt;とりあえず書いてみる&lt;&#x2F;li&gt;
&lt;li&gt;実践Rustプログラミング入門』を読む&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;これで実践のじの字まではたどり着ける。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gong-shi-dokiyumentonituite&quot;&gt;公式ドキュメントについて&lt;&#x2F;h3&gt;
&lt;p&gt;もちろん充実しているし、丁寧な書きぶり・カバーぶりなのでいろいろなところでおすすめされている。でも、前知識なしに＆おおまかな全体像を持たず読もうとするとだいたいトレイトあたりで力尽きる。実際にプログラムを組むためにはそのあとの.iter()やクロージャを形式的にでも分かっていないと厳しい。Rustの場合は、公式ドキュメントはその他の資料で迷子になったときに戻ってくる場所として認識しておいたほうがよいと思う。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;1-puroguraminguyan-yu-rustru-men&quot;&gt;1. 『プログラミング言語Rust入門』&lt;&#x2F;h3&gt;
&lt;p&gt;C、C++の知識のない人間がRustを始めるにはまずここからがよいと思う。簡潔な語り口と丁寧な説明で、入門書の名前にふさわしい。基本文法や所有権のおおまかな概念理解をすませておくと、先々の言語仕様にも必要以上にひるまずに進めるはず。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;2-toriaezushu-itemiru&quot;&gt;2. とりあえず書いてみる&lt;&#x2F;h3&gt;
&lt;p&gt;なんとなくいけそうな感じになってきたら、何でもいいから書いてみる。Rustはコンパイラに手取り足取り教えてもらって初めて分かるようになる言語だ。だから言語に最短で慣れるには、エラーを取り除くということをたくさんやる、つまりエラーがいっぱいのコードを書くのがいい。&lt;br &#x2F;&gt;
作りたいものがなかったり、作りたくてもハードルが高すぎる場合は、競技プログラミングの問題を解いてみよう。&lt;br &#x2F;&gt;
AtCoderでもいいが、I&#x2F;Oのことを考えないでとりあえず書いてみたい場合はLeetCodeやProject Eulerがおすすめ。前者は数学以外の問題もたくさんあり、後者はすべて数学の問題になっているという違いはあるけれど、いずれも基本的な配列の操作や制御フローの学習に向いている。特にLeetCodeは以下の点でおすすめ。&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;ヒントが充実しているし、ユーザー数が多く、ディスカッションもたくさん行われているので、つまずきにくい&lt;&#x2F;li&gt;
&lt;li&gt;わかりやすい難度表示があるのでトライのハードルが低い&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;3-shi-jian-rustpuroguraminguru-men&quot;&gt;3. 『実践Rustプログラミング入門』&lt;&#x2F;h3&gt;
&lt;p&gt;雰囲気で書けるようになってきたらこれを読んで写経してみる。ふわっとした知識だったところが整理され、理解が深まる感じがする。用語の説明不足も、ここまできたら許容範囲に収まっているはず。&lt;br &#x2F;&gt;
逆に言うと、雰囲気ででも書けないと、序盤からわからない用語が出てきてつらい気持ちになるはずなので、これで入門するのはおすすめできない。タイトルの入門は「実践的なプログラミングへの入門」であって「文法や基礎知識への入門」ではない。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;rustlings&quot;&gt;rustlings&lt;&#x2F;h3&gt;
&lt;p&gt;公式で提供されているRustコードのデバッグ問題集。正直駆け出しにはかなり難度が高いが、『実践Rustプログラミング入門』まで読めたら数問を除いてパスできるようになっているはず。また、雰囲気が分かってきたトピックの穴を洗い出すためにも使える。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ta-yan-yu-tonobi-jiao-ji-shi&quot;&gt;他言語との比較記事&lt;&#x2F;h3&gt;
&lt;p&gt;HaskellとRustの比較記事をいくつか読んだが、Haskellの知識があれば万事うまくいくわけでは全然ないので、足場にしすぎないことが大事。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;zatukurisitadui-ying-guan-xi&quot;&gt;ざっくりした対応関係&lt;&#x2F;h4&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th&gt;Haskell&lt;&#x2F;th&gt;&lt;th&gt;Rust&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td&gt;Maybeモナド&lt;&#x2F;td&gt;&lt;td&gt;Option型&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;Eitherモナド&lt;&#x2F;td&gt;&lt;td&gt;Result型&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;data&lt;&#x2F;td&gt;&lt;td&gt;struct enum&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;tr&gt;&lt;td&gt;case&lt;&#x2F;td&gt;&lt;td&gt;match&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
</description>
        </item>
        <item>
            <title>Nimで静的サイトジェネレーターを実装する</title>
            <pubDate>Tue, 02 Feb 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/nim-ssg/</link>
            <guid>https://kyoheiu.gitlab.io/post/nim-ssg/</guid>
            <description>&lt;p&gt;Rust製の静的サイトジェネレーターZolaでスクラッチからテーマを自作したことで、静的サイトジェネレーターそのものに興味が出てきた（以下、「ジェネレーター」と略す箇所が多々あります）。&lt;br &#x2F;&gt;
そこで調べてみて初めて知ったのだが、実は世の中には無数といっていい数の静的サイトジェネレーターがある。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;jamstack.org&#x2F;generators&#x2F;&quot;&gt;Static Site Generators - Top Open Source SSGs | Jamstack&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;このページでは、GitHubのスターが多い順に322ものジェネレーターをリストアップしている。Next.js、Hugoに始まり、見たこともないジェネレーターも上のほうにけっこうあったりする。&lt;br &#x2F;&gt;
中には、同じ言語・同じテンプレートエンジンで作られているものもある。たとえば[Pytyon, jinja2]の組み合わせはちょっと数えただけでも10以上ある。それぞれ実装している機能が異なるのだろうし、使い勝手も違うのだろうと思うが、それにしても静的サイトジェネレーターの機能というのはコアの部分はシンプルなはずなので、「ジェネレーターがたくさん作られている」というこの現象は面白い。&lt;br &#x2F;&gt;
なぜなのか、少し考えてみたけれど、まず触っていて気持ちがいいというのは大きいと思う。バッとビルドすれば自分のホームが完成する。こうなるだろうと思ったところから外れることはほとんどない。それでいて、成果物は自分好みのページになっている。これは楽しい。&lt;br &#x2F;&gt;
そして仕組みも、いじっているうちにだんだんわかってくる。テンプレートがあって、マークダウンのファイルがあって、組み合わせて…と、なんだか自分で作れそうな気持ちが湧いてくる。そんな風にして、すでに存在しているジェネレーターと機能は被っている（あるいは場合によっては劣っている）としても、みんなジェネレーターを作ってみたくなるんじゃないだろうか。&lt;&#x2F;p&gt;
&lt;p&gt;僕も実装してみたところ、ざっくりしたプリミティブなジェネレーターが出来たので、紹介してみたい。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;gitlab.com&#x2F;kyoheiu&#x2F;casa&quot;&gt;Kyohei Uto &#x2F; Casa · GitLab&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;今回は、ただジェネレーターを実装するだけでなく、若い言語Nimを触りながら何かを作ってみる、という狙いもあった。&lt;br &#x2F;&gt;
ちなみにNim製の静的サイトジェネレーターはすでに存在しているし、機能も今のところそちらのほうがずっと多い。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nazenimnanoka&quot;&gt;なぜNimなのか&lt;&#x2F;h3&gt;
&lt;p&gt;ジェネレーターを作るとして、言語の縛りはない。というかむしろ、自分の好きな言語／テンプレートエンジンでジェネレーターを実装する、というところが楽しいはずだ。&lt;br &#x2F;&gt;
最初に検討したのはHaskell。Pandocがあるということ、自分がある程度慣れた言語であるということ、Haskell製のジェネレーターHakyllは公式のテーマリストが長らく更新されていないこと、が理由だったのだが、これは厳しかった。最近触る機会がなかったというのもあるけれど、やっぱりHaskellは難しい。Haskellは好きだけど、今回はできればあまり血と涙と時間を費やしたくなかったので、他の言語を検討することに。&lt;&#x2F;p&gt;
&lt;p&gt;一方でなるべく新しい言語に触れたいという気持ちがあって最近ドキュメントを読んでいたのがJuliaとNimだったが、どちらかというとNimのほうが実行まわりで個人的に相性がよさそうだな…というくらいの感じで、Nimでジェネレーターを作ることに決めた。後述するがNimには言語付属のテンプレートエンジンがあり、これが実にサイトジェネレーター向けの仕様だった。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;gou-cheng&quot;&gt;構成&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;.
├── casa
├── casa.nim
├── config.json
├── content
│   ├── 1
│   │   ├── 1.json
│   │   └── 1.md
│   ...
├── css
├── public
└── templates
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;全体のフローは非常にシンプルで、contentフォルダに対してforループをまわし、markdownファイルをパースしつつjsonで書いた各記事の設定ファイルを読み込んで、記事ページ、ランディングページおよびタクソノミーのテンプレートに必要な変数を渡す、という流れになる。&lt;&#x2F;p&gt;
&lt;p&gt;テンプレートについては、Nim付属のSource Code Filtersと呼ばれるテンプレートエンジンを使った。たとえば各記事ページのテンプレートを用意したい場合は、こうなる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;#? stdtmpl(subsChar = &amp;#x27;$&amp;#x27;, metaChar = &amp;#x27;#&amp;#x27;)
#proc generatePageHtml(siteTitle, siteUrl, pageContent, pageDate, pageTitle: string, pageCategories, pageTags: seq): string =
#  result = &amp;quot;&amp;quot;
&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html lang=&amp;quot;en&amp;quot;&amp;gt;

&amp;lt;head&amp;gt;
  &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;
      $pageTitle | $siteTitle
    &amp;lt;&amp;#x2F;title&amp;gt;

  &amp;lt;link rel=&amp;quot;shortcut icon&amp;quot; type=&amp;quot;image&amp;#x2F;png&amp;quot; href=&amp;quot;$siteUrl&amp;#x2F;static&amp;#x2F;image&amp;#x2F;icon.png&amp;quot;&amp;gt;
  &amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width,initial-scale=1&amp;quot;&amp;gt;
  &amp;lt;link id=&amp;quot;style&amp;quot; rel=&amp;quot;stylesheet&amp;quot; type=&amp;quot;text&amp;#x2F;css&amp;quot; href=&amp;quot;..&amp;#x2F;..&amp;#x2F;main.css&amp;quot;&amp;gt;
&amp;lt;&amp;#x2F;head&amp;gt;

&amp;lt;h2&amp;gt;
  $pageTitle
&amp;lt;&amp;#x2F;h2&amp;gt;

&amp;lt;div class=&amp;quot;date&amp;quot;&amp;gt;
  $pageDate
&amp;lt;&amp;#x2F;div&amp;gt;

#for category in items(pageCategories) :
  &amp;lt;a href=&amp;quot;$siteUrl&amp;#x2F;categories&amp;#x2F;$category&amp;quot;&amp;gt;&amp;#x2F;$category&amp;lt;&amp;#x2F;a&amp;gt;
#end for

#for tag in items(pageTags) :
  &amp;lt;a href=&amp;quot;$siteUrl&amp;#x2F;tags&amp;#x2F;$tag&amp;quot;&amp;gt;#$tag&amp;lt;&amp;#x2F;a&amp;gt;
#end for

&amp;lt;p&amp;gt;
  $pageContent
&amp;lt;&amp;#x2F;p&amp;gt;

&amp;lt;div class=&amp;quot;footer&amp;quot;&amp;gt;
  &amp;lt;a href=&amp;quot;$siteUrl&amp;quot;&amp;gt;$siteTitle&amp;lt;&amp;#x2F;a&amp;gt; | built in Nim
&amp;lt;&amp;#x2F;div&amp;gt;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;SCFのテンプレート内では、#を文頭につければNimのコードを動かせる。このMetaCharは自由に変更可能なので、#をテンプレート内の文頭で使いたいときは、たとえば+なり@なりを設定すればいい。ただし１行目の#?だけは変更不可なので注意して!!&lt;br &#x2F;&gt;
これにpage_base.nimfと名前をつけ（拡張子は自由だがコンベンションとして.nimfが推奨されている）、.nimファイル内でincludeした上で、テンプレート内の関数を呼び出す。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;import markdown, ...

include &amp;quot;templates&amp;#x2F;page_base.nimf&amp;quot;
...

let pageHtml   = generatePageHtml(siteTitle, siteUrl, pageContent,...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これでHTMLファイルとして生成できる。今の設定で生成できるpublicディレクトリの内容は以下の通り。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;.
├── categories # サンプルとして色名をカテゴリに
│   ├── blue
│   ...
│   └── yellow
├── content # 1から100までのサンプル記事
│   ├── 1
│   ...
│   └── 100
├── index.html
├── main.css
└── tags　# サンプルとして色名をタグに
    ├── blue
    ...
    └── yellow
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;ただしjinja2やTera Templateにおけるextendsのような拡張機能はまだ実装されていないので、各テンプレート毎に一から実装する必要がある、というのは難点といえば難点。headerやfooterをいじるとき、ちょっと面倒かも。&lt;br &#x2F;&gt;
また、設定ファイルをいじったとき、ビルドし直さないと反映されない。&lt;br &#x2F;&gt;
さらに、静的サイトジェネレーターというのはしばしば、サイト全体の設定ファイルに自前の変数を追加し、各テンプレートで使用する…ということをやるわけだが、このSCFを使う場合は、そもそもNimのコードから書き直して実装しなければならない。ここまでくると、お世辞にも手軽なテンプレートエンジンとは言えなさそう。その意味でも、HugoやZolaの拡張性の高さ・自由度は本当にすごいと思う。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pahuomansu&quot;&gt;パフォーマンス&lt;&#x2F;h3&gt;
&lt;p&gt;現在自分が使っているRust製ジェネレーターのZola、そして以前使っていたHugoと、自作ジェネレーターCasaのパフォーマンスを比較してみる。サンプルとして作成した100記事からなるサイトを生成するのにかかった時間は以下の通り。&lt;&#x2F;p&gt;
&lt;table&gt;&lt;thead&gt;&lt;tr&gt;&lt;th align=&quot;center&quot;&gt;Casa（リリースビルド）&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Casa(通常ビルド)&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Zola&lt;&#x2F;th&gt;&lt;th align=&quot;center&quot;&gt;Hugo&lt;&#x2F;th&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;thead&gt;&lt;tbody&gt;
&lt;tr&gt;&lt;td align=&quot;center&quot;&gt;0.220s&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;0.600s&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;0.094s&lt;&#x2F;td&gt;&lt;td align=&quot;center&quot;&gt;0.101s&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;
&lt;&#x2F;tbody&gt;&lt;&#x2F;table&gt;
&lt;p&gt;ちなみに、ジェネレーターの草分け的存在・Jekyllは、 &lt;a href=&quot;https:&#x2F;&#x2F;forestry.io&#x2F;blog&#x2F;hugo-vs-jekyll-benchmark&#x2F;&quot;&gt;Hugo vs Jekyll: Benchmarked | Forestry.io&lt;&#x2F;a&gt; こちらの記事によると100記事で3〜4s程度。&lt;&#x2F;p&gt;
&lt;p&gt;ただし、サンプルに用いたファイルはわずかなmarkdownパースしか必要としない。複雑なmarkdownファイルを使うと、Zola&#x2F;Hugoへのビハインドはもっと大きくなる。&lt;&#x2F;p&gt;
&lt;p&gt;ちなみに最初はさらに遅かったので、設定ファイルの形式を変更した。元々はZolaにならってmarkdownのテキストデータと各記事のフロントマター（toml形式）を１つのファイルに同居させ、あとでsplitしてそれぞれを読み込む…ということをしていたのだが、このsplit周りのコードがかなり汚くて微妙だったのと、パフォーマンス的にこの辺で時間を食ってそう、という感じがあったので、割り切って本文のmarkdownファイルとjsonファイルは分けて作る形に切り替えた。これでビルド時間を半減。&lt;&#x2F;p&gt;
&lt;p&gt;markdownパーサはnim-markdownを使用。パフォーマンスのボトルネックがこのパーサなのでどうにかできるといいのだが、現状、Nimのパッケージライブラリにあるmarkdownパーサが実質的にはnim-markdownしかない。とりあえず高速化はここまで。&lt;br &#x2F;&gt;
とはいえ、当然markdownファイルのパース以外にも色々処理をしているわけなので、全体としてNimが確かに速いということは実感できた。正直ここまでとは思っていなかった。まだコードの内容も未熟だから、きっともっと速くできる。&lt;br &#x2F;&gt;
（ついでに言うと、やっぱりZolaはHugoよりもちょっとだけ速そうな気配）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nimza-gan&quot;&gt;Nim雑感&lt;&#x2F;h3&gt;
&lt;p&gt;以前小さなスクリプトを書いたときに「素直な言語」という手応えを得たが、今回ジェネレーターを実装したことで、ただ単に素直なだけではない、「実直でパワフルな言語」という認識に変わった。コードの書き心地がとてもシンプルで、書いたことがそのまま反映されるし、しかも速い。forループをぶん回しても涼しい顔をしている。ライブラリのさらなる充実に期待（どこかでmarkdownパーサを書いてみたい…）。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Parsing CSV file in Nim</title>
            <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/nim-csv-en/</link>
            <guid>https://kyoheiu.gitlab.io/post/nim-csv-en/</guid>
            <description>&lt;p&gt;As an exercise, I wrote a small program in Nim, the programming language that I&#x27;m learning these days.
Here, we use &lt;code&gt;parsecsv&lt;&#x2F;code&gt; library in standard lib.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;nim&quot; class=&quot;language-nim &quot;&gt;&lt;code class=&quot;language-nim&quot; data-lang=&quot;nim&quot;&gt;import parsecsv

var p: CsvParser
p.open(&amp;quot;sample1.csv&amp;quot;)
p.readHeaderRow()
while p.readRow():
  echo &amp;quot;The average of &amp;quot;, p.row[0], &amp;quot; in &amp;quot;, 
    p.headers[2], &amp;quot; is &amp;quot;, p.row[1]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;readHeaderRow&lt;&#x2F;code&gt; is a function that gets the first row of csv and makes table (in order to access to elements of the first row, use &lt;code&gt;header[i]&lt;&#x2F;code&gt;.)
&lt;code&gt;readRow&lt;&#x2F;code&gt; sees whether we have next line or not, so we use this function in while expression to work on the entire csv.&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;sh&quot; class=&quot;language-sh &quot;&gt;&lt;code class=&quot;language-sh&quot; data-lang=&quot;sh&quot;&gt;$ nim c -r csvparse.nim
[...]
The average of May in  &amp;quot;2005&amp;quot; is   0.1
The average of Jun in  &amp;quot;2005&amp;quot; is   0.5
The average of Jul in  &amp;quot;2005&amp;quot; is   0.7
The average of Aug in  &amp;quot;2005&amp;quot; is   2.3
The average of Sep in  &amp;quot;2005&amp;quot; is   3.5
The average of Oct in  &amp;quot;2005&amp;quot; is   2.0
The average of Nov in  &amp;quot;2005&amp;quot; is   0.5
The average of Dec in  &amp;quot;2005&amp;quot; is   0.0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;BTW, first exec time was 0.750s, second 0.013s, due to cache.&lt;&#x2F;p&gt;
&lt;p&gt;Nim shines when we want to build a small but need-to-be-efficient program in daily use, though of course it can be used for more complex applications.&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>NimでCSVファイルをパースする</title>
            <pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/nim-csv/</link>
            <guid>https://kyoheiu.gitlab.io/post/nim-csv/</guid>
            <description>&lt;p&gt;最近勉強中の言語Nimで、ちょっとした作業用にプログラムを書いてみた。
NimはPython風の文法で簡潔かつコンパクトに高速なプログラムを書ける言語。C &#x2F; C++ &#x2F; Objective-Cのコードにトランスパイルすることができ、Cのライブラリも使用することが可能。&lt;&#x2F;p&gt;
&lt;p&gt;今回触ったのはStandard Libaryのparsecsv。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;import parsecsv

var p: CsvParser
p.open(&amp;quot;sample1.csv&amp;quot;)
p.readHeaderRow()
while p.readRow():
  echo &amp;quot;The average of &amp;quot;, p.row[0], &amp;quot; in &amp;quot;, 
       p.headers[2], &amp;quot; is &amp;quot;, p.row[1]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;readHeaderRowはcsvの最初の行を読み込んでテーブルを作る関数。最初の行の要素にアクセスしたいときはheaders[i]を使う。
readRowは次の行があるかどうか判定してBoolを返してくれるので、whileの条件に使えばcsv全体に手続きを順に適用できる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[kyohei@myarch csvsample]$ nim c -r csvparse.nim
Hint: used config file &amp;#x27;&amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;.choosenim&amp;#x2F;toolchains&amp;#x2F;nim-1.4.2&amp;#x2F;config&amp;#x2F;nim.cfg&amp;#x27; [Conf]
Hint: used config file &amp;#x27;&amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;.choosenim&amp;#x2F;toolchains&amp;#x2F;nim-1.4.2&amp;#x2F;config&amp;#x2F;config.nims&amp;#x27; [Conf]
..............CC: stdlib_assertions.nim
CC: stdlib_io.nim
CC: stdlib_system.nim
CC: stdlib_streams.nim
CC: stdlib_lexbase.nim
CC: stdlib_parsecsv.nim
CC: csvparse.nim
Hint:  [Link]
Hint: 35986 lines; 0.750s; 48.977MiB peakmem; Debug build; proj: &amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;nim&amp;#x2F;csvsample&amp;#x2F;csvparse.nim; out: &amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;nim&amp;#x2F;csvsample&amp;#x2F;csvparse [SuccessX]
Hint: &amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;nim&amp;#x2F;csvsample&amp;#x2F;csvparse  [Exec]
The average of May in  &amp;quot;2005&amp;quot; is   0.1
The average of Jun in  &amp;quot;2005&amp;quot; is   0.5
The average of Jul in  &amp;quot;2005&amp;quot; is   0.7
The average of Aug in  &amp;quot;2005&amp;quot; is   2.3
The average of Sep in  &amp;quot;2005&amp;quot; is   3.5
The average of Oct in  &amp;quot;2005&amp;quot; is   2.0
The average of Nov in  &amp;quot;2005&amp;quot; is   0.5
The average of Dec in  &amp;quot;2005&amp;quot; is   0.0

[kyohei@myarch csvsample]$ nim c -r csvparse.nim
Hint: used config file &amp;#x27;&amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;.choosenim&amp;#x2F;toolchains&amp;#x2F;nim-1.4.2&amp;#x2F;config&amp;#x2F;nim.cfg&amp;#x27; [Conf]
Hint: used config file &amp;#x27;&amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;.choosenim&amp;#x2F;toolchains&amp;#x2F;nim-1.4.2&amp;#x2F;config&amp;#x2F;config.nims&amp;#x27; [Conf]
Hint: 7847 lines; 0.013s; 6.98MiB peakmem; Debug build; proj: &amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;nim&amp;#x2F;csvsample&amp;#x2F;csvparse.nim; out: &amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;nim&amp;#x2F;csvsample&amp;#x2F;csvparse [SuccessX]
Hint: &amp;#x2F;home&amp;#x2F;kyohei&amp;#x2F;nim&amp;#x2F;csvsample&amp;#x2F;csvparse  [Exec]
The average of May in  &amp;quot;2005&amp;quot; is   0.1
The average of Jun in  &amp;quot;2005&amp;quot; is   0.5
The average of Jul in  &amp;quot;2005&amp;quot; is   0.7
The average of Aug in  &amp;quot;2005&amp;quot; is   2.3
The average of Sep in  &amp;quot;2005&amp;quot; is   3.5
The average of Oct in  &amp;quot;2005&amp;quot; is   2.0
The average of Nov in  &amp;quot;2005&amp;quot; is   0.5
The average of Dec in  &amp;quot;2005&amp;quot; is   0.0
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;１回めの実行は0.750sかかっているが、２回めは0.013sと短縮されている。&lt;&#x2F;p&gt;
&lt;p&gt;個人的なNimの使用感としては、わずらわしいこと抜きにさくっとシンプルなプログラムを書きたいときにとても良い感じ（もちろんもっと複雑なプログラムも書けるだろうけれど）。「今時の簡潔言語」の中では一番しっくりきてます。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>JuliaによるWebスクレイピング（簡易版）</title>
            <pubDate>Thu, 14 Jan 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/juliascraping/</link>
            <guid>https://kyoheiu.gitlab.io/post/juliascraping/</guid>
            <description>&lt;p&gt;Juliaで特定のWebページの更新日のみを取得するスクリプト。試し書きに近いのであしからず。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;using HTTP

url = &amp;quot;http:&amp;#x2F;&amp;#x2F;example.com&amp;quot;

function main()
   head = HTTP.head(url)
   lastmod = head.headers[6]
   println(lastmod)
end

@time main()
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;julia&amp;gt; include(&amp;quot;scraping.jl&amp;quot;)
&amp;quot;Last-Modified&amp;quot; =&amp;gt; &amp;quot;Thu, 10 Dec 2020 00:53:40 GMT&amp;quot;
  2.787799 seconds (9.54 M allocations: 479.701 MiB, 6.53% gc time)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;関数定義部分はもうちょっとチェインっぽい感じでかっこよく書ける気もする。
使用するライブラリはHTTP.jlのみ。head.headersはarrayを返すので、[6]でarray中の要素を指定している（Juliaは1からカウント）。実際、head.headersと番号を指定せずにおくと&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;julia&quot; class=&quot;language-julia &quot;&gt;&lt;code class=&quot;language-julia&quot; data-lang=&quot;julia&quot;&gt;julia&amp;gt; head.headers
8-element Array{Pair{SubString{String},SubString{String}},1}:
           &amp;quot;Date&amp;quot; =&amp;gt; &amp;quot;Thu, 14 Jan 2021 20:35:31 GMT&amp;quot;
   &amp;quot;Content-Type&amp;quot; =&amp;gt; &amp;quot;text&amp;#x2F;html&amp;quot;
 &amp;quot;Content-Length&amp;quot; =&amp;gt; &amp;quot;9480&amp;quot;
     &amp;quot;Connection&amp;quot; =&amp;gt; &amp;quot;keep-alive&amp;quot;
         &amp;quot;Server&amp;quot; =&amp;gt; &amp;quot;Apache&amp;quot;
  &amp;quot;Last-Modified&amp;quot; =&amp;gt; &amp;quot;Thu, 10 Dec 2020 00:53:40 GMT&amp;quot;
  &amp;quot;Accept-Ranges&amp;quot; =&amp;gt; &amp;quot;none&amp;quot;
           &amp;quot;Vary&amp;quot; =&amp;gt; &amp;quot;Range,Accept-Encoding&amp;quot;
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;となる。&lt;&#x2F;p&gt;
&lt;p&gt;取得したHTMLをさらにパースしてbodyやh1など特定のタグの内容を抽出したい場合はGumbo.jlを用いる。&lt;&#x2F;p&gt;
&lt;p&gt;恐ろしく簡潔だが、ちょっと時間がかかりすぎのような気もする。ただ他言語と比較して、ということをやるまでの気力はないので、ここまでにしておきます。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;jlhuairunoshi-xing&quot;&gt;.jlファイルの実行&lt;&#x2F;h4&gt;
&lt;p&gt;ちょっと困ったのが.jlファイルの実行について。REPLモードでincludeして関数を叩く分には何の問題もないのだが、どちらかというとREPLモードに入らず直接ターミナルで実行ファイルを叩く形のほうが好みなので、方法がないか探した。
公式にはターミナルで.jlファイルのあるディレクトリにcdし、julia hoge.jlで実行可能だが、この際、.jlファイルはmoduleとしてではなく、上記のように&lt;&#x2F;p&gt;
&lt;ul&gt;
&lt;li&gt;必要な関数定義&lt;&#x2F;li&gt;
&lt;li&gt;実行したいスクリプト&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;のみを記述する。ちなみにこの場合、REPLモードでも、上記のようにinclude(&amp;quot;hoge.jl&amp;quot;)のみで実行することはできる。
逆にmodule化してしまうと、julia hoge.jlでもinclude(&amp;quot;hoge.jl&amp;quot;)でもスクリプトが実行されることはない（REPLモードの場合は、スクリプト部分がシンタックスエラーと判定されてしまう）。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>静的サイトジェネレーターZolaへ移行する</title>
            <pubDate>Thu, 07 Jan 2021 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/zola-ssg/</link>
            <guid>https://kyoheiu.gitlab.io/post/zola-ssg/</guid>
            <description>&lt;h3 id=&quot;gai-yao&quot;&gt;概要&lt;&#x2F;h3&gt;
&lt;p&gt;以前はGo製のSSG(Static Site Generator)Hugoを使っていたのだけれど、色々考えた結果、Rust製SSGのZolaに乗り換えることに。そしていじっているうちに自分で納得いくまでやりたくなってしまい、テーマも作成してみました、という話です。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;yi-xing-li-you&quot;&gt;移行理由&lt;&#x2F;h3&gt;
&lt;p&gt;HugoではAcademicという（おそらく）メジャーなthemeを使っていて、特に支障があったわけでもなかったのだけれど、気になるといえば気になっていたのが、「細かいところが気になったとき、すらすらと自分で書き直せるほどの理解を得ないまま使っている感じ」。ただしこれについては、デザインを自分で本格的にいじっていないために手になじんでいないだけかもしれない。&lt;&#x2F;p&gt;
&lt;p&gt;直接的な動機になったのは、各記事のカテゴリやタグを記事一覧でちゃんと表示してくれる、かつデザイン的に好みのthemeが見つからなかったことだったが、結果的には、Zolaに移行してテーマも自作したことで、とてもスッキリした。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;zolanituitenoge-ren-de-pros-cons&quot;&gt;Zolaについての個人的pros&#x2F;cons&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;pros&quot;&gt;pros&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;zola buildが通ればだいたい大丈夫という安心感&lt;&#x2F;li&gt;
&lt;li&gt;しかも早い。Hugoよりも体感的にはちょっとだけ早い気がする。&lt;&#x2F;li&gt;
&lt;li&gt;buildエラー時のメッセージが丁寧かつ有用
&lt;ul&gt;
&lt;li&gt;Hugoでは何も考えずthemeを使っていたのでそもそもあまりエラーが出なかった印象だが、一から独自変数ありの.htmlを組んでいく中でこれはとても有難かった。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;zola checkがけっこう使える
&lt;ul&gt;
&lt;li&gt;内部及び外部リンクをチェックしてくれるコマンドで、リンクミス・リンク切れを教えてくれる。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h4 id=&quot;cons&quot;&gt;cons&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;手間がかかる
&lt;ul&gt;
&lt;li&gt;zola init時に勝手に各ページのサンプルを生成してくれればいいのにな…と、自作themeを作りながら何回か感じた。git cloneでthemeを入れた後、全体の構造を理解した上で.htmlをいじらないといけない局面があり、SSGに詳しくない人がいきなり手を出すのはややつらい気がする。最初のSSGとしてはHugoのほうがよさそう。&lt;&#x2F;li&gt;
&lt;li&gt;そして.htmlやconfig.tomlをいじっていく際、Tera Templateという独特のテンプレートエンジンを使う必要があり、学習コストが高いとまでは言わないけれど、お目当ての機能にたどり着くのにけっこう時間はかかるというのが実感。&lt;&#x2F;li&gt;
&lt;li&gt;慣れるとそこそこ扱いやすいこのTera Template、Rust用のエンジンということなので、Rustを普段書いている人にとっては学習しておくと一石二鳥…かどうかはよくわかりません。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;themeがまだまだ少なそう
&lt;ul&gt;
&lt;li&gt;公式で紹介されているのは2021年初頭時点で29。一方さすがのHugoは公式に載っているものだけでも300近くあるようなので、ここの差は人によっては大きいと思う。ただし、結局自分好みのサイトにしようとするなら、自分でいじらないといけない（いじることのできる）範囲が広いので、自力で全部書くのであれば関係ない。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;公式ドキュメントが若干わかりにくい
&lt;ul&gt;
&lt;li&gt;トータルで見ると必要なことは全部書いてあるのだが、知りたいことがどこに書いてあるのか直感的に掴みづらい。たとえば、使用できるシンタックスハイライトのテーマ一覧がSyntax HighlightingというページではなくConfigurationにある、など。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;li&gt;hugo new post&#x2F;new.mdのような記事作成コマンドがない
&lt;ul&gt;
&lt;li&gt;人によっては若干不親切と感じられるかもしれない。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;p&gt;総合して考えると個人的にはZolaのほうが馬が合う感じで好み。いちから自分の手でちまちま構築する（必要がある）雰囲気がArchと似ていて、「これについては自分が一番よく知っているし、何かあったら自分でなんとかできるはず」という感覚を得られる。これが個人的にはけっこう大事なポイントなので。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;getting-started&quot;&gt;Getting Started&lt;&#x2F;h3&gt;
&lt;p&gt;以下は、themeを使用しない場合の導入方法です。&lt;&#x2F;p&gt;
&lt;p&gt;基本的な仕組みは、公式のドキュメントのGetting Startedに。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;$ tree
.
├── config.toml
├── content
├── sass
├── static
├── templates
└── themes
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;さらにtemplatesの中身は以下。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[templates]$ tree
.
├── base.html
├── categories
│   ├── list.html
│   └── single.html
├── index.html
├── post.html
├── post-page.html
└── tags
    ├── list.html
    └── single.html
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;templatesに入っているこれらすべてのファイルと、親ディレクトリのconfig.tomlが必須要素。（タグ等の分類を使わなければtags及びcategoriesディレクトリは不要）。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;quan-ti-gou-zao&quot;&gt;全体構造&lt;&#x2F;h4&gt;
&lt;ul&gt;
&lt;li&gt;base.html すべてのページのテンプレート。head、header、footerなどはここに書く。&lt;&#x2F;li&gt;
&lt;li&gt;index.html いわゆるトップページの内容。&lt;&#x2F;li&gt;
&lt;li&gt;post.html, post-page.html それぞれ、記事一覧と各記事ページのテンプレートになる。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;pre&gt;&lt;code&gt;( base.html &amp;gt; index.html     ) + main.scss = example.com&amp;#x2F;index.html
( base.html &amp;gt; post.html      ) + main.scss = example.com&amp;#x2F;post
( base.html &amp;gt; post-page.html ) + main.scss + content&amp;#x2F;post&amp;#x2F;hoge.md   = example.com&amp;#x2F;post&amp;#x2F;hoge
( base.html &amp;gt; post-page.html ) + main.scss + content&amp;#x2F;hoge&amp;#x2F;index.md  = example.com&amp;#x2F;hoge
content&amp;#x2F;post&amp;#x2F;_index.md = content&amp;#x2F;post以下の記事群についてのメタデータ
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;このように、雛形の.htmlをベースにして（記事の場合は.mdファイルの各変数が代入され）そこに.scssから生成されるCSSファイルが適応されて最終的なhtmlが出力される、という流れになっている。この流れを可能にしているのがTera Template流の変数の仕組み。&lt;&#x2F;p&gt;
&lt;p&gt;content&#x2F;hoge&#x2F;index.mdとcontent&#x2F;hoge&#x2F;_index.mdの違いは、前者はexample.com&#x2F;hogeへアクセスしたときに表示されるページとしてレンダリングされるが、後者はcontent&#x2F;hoge以下の記事群についてのメタデータを記したファイルであるということ。&lt;&#x2F;p&gt;
&lt;p&gt;たとえばexample.com&#x2F;aboutに直接aboutページを載せたいときは、content&#x2F;about&#x2F;index.mdにその内容を書く。逆に、記事一覧など、content&#x2F;hoge以下の記事群に対応する変数はcontent&#x2F;hoge&#x2F;_index.mdに記載しておく。（この説明はちょっと怪しいけど…）&lt;&#x2F;p&gt;
&lt;h3 id=&quot;tips&quot;&gt;tips&lt;&#x2F;h3&gt;
&lt;p&gt;以上が分かればあとは自分好みに仕上げていくだけだが、個人的に詰まったところ・記録しておきたいところを書いておく。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;hugo-academic-karanoyi-xing&quot;&gt;Hugo(Academic)からの移行&lt;&#x2F;h4&gt;
&lt;p&gt;Academicの.mdテンプレートはフロントマター（タイトルや投稿日などの記事のメタデータ）の区切りが+++でなく---になっているので、逐一変換する必要がある。記事数が多い場合は何らかのスクリプトを組まないと厳しい。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;sintatukusuhairaito&quot;&gt;シンタックスハイライト&lt;&#x2F;h4&gt;
&lt;p&gt;config.tomlに好みのテーマを書き、各.mdのコードブロック先頭に言語を明示することで適用される。対応しているテーマがまだ少ないので、こだわりのある人は先に公式をチェックしておきましょう。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;nei-bu-rinku&quot;&gt;内部リンク&lt;&#x2F;h4&gt;
&lt;p&gt;独特の内部リンク文法を使用しており、たとえば記事内で&#x2F;post&#x2F;hoge.mdにリンクを貼りたいときは@&#x2F;post&#x2F;hoge.mdとなる。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;taxonomies&quot;&gt;taxonomies&lt;&#x2F;h4&gt;
&lt;p&gt;Zolaにおけるタグやカテゴリなどのtaxonomiesは各記事のフロントマターに明示するだけではダメで、templatesにTAXONOMIES&#x2F;list.html, TAXONOMIES&#x2F;single.htmlという２種類のテンプレートを作る必要がある。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;scss&quot;&gt;scss&lt;&#x2F;h4&gt;
&lt;p&gt;cssのメタ言語だが、学習コストはかなり低いので触っておいて損はないと思う。といっても自分はscss独自の機能はほぼ使用していないけれど…。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;index-htmlnizhi-jie-ji-shi-yi-lan-wobiao-shi-suru&quot;&gt;index.htmlに直接記事一覧を表示する&lt;&#x2F;h4&gt;
&lt;p&gt;set_section関数を使用してpage.htmlを拾った上で、for構文を用いて表示する。&lt;&#x2F;p&gt;
&lt;p&gt;全記事でなく一部のみを表示したい場合はループカウントすることになるが、Tera Templateはloop.indexという特殊変数を用いてカウントするので注意。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;config-extra-variable&quot;&gt;config.extra.variable&lt;&#x2F;h4&gt;
&lt;p&gt;config.tomlの[extra]（自作の設定）でなるべく変数定義することでコードがクリーンになる気がする。ただし、.scss内で自作変数を使うことはできないっぽい。.scssでなく直接.cssを書いて置いておくのであれば使えそう。&lt;&#x2F;p&gt;
&lt;h4 id=&quot;shu-shi&quot;&gt;数式&lt;&#x2F;h4&gt;
&lt;p&gt;数式の表示はMathJaxを使用した。関連する部分のコードを貼っておくので参考までに。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;html&quot; class=&quot;language-html &quot;&gt;&lt;code class=&quot;language-html&quot; data-lang=&quot;html&quot;&gt;  {% if page.extra.math %}
  &amp;lt;script&amp;gt;
    MathJax = {
      tex: {
        inlineMath: [[&amp;#x27;$&amp;#x27;, &amp;#x27;$&amp;#x27;], [&amp;#x27;\\(&amp;#x27;, &amp;#x27;\\)&amp;#x27;]]
      }
    };
  &amp;lt;&amp;#x2F;script&amp;gt;
  &amp;lt;script type=&amp;quot;text&amp;#x2F;javascript&amp;quot; id=&amp;quot;MathJax-script&amp;quot; async
    src=&amp;quot;https:&amp;#x2F;&amp;#x2F;cdn.jsdelivr.net&amp;#x2F;npm&amp;#x2F;mathjax@3&amp;#x2F;es5&amp;#x2F;tex-chtml.js&amp;quot;&amp;gt;
  &amp;lt;&amp;#x2F;script&amp;gt;
  {% endif %}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;matomeruto&quot;&gt;まとめると&lt;&#x2F;h3&gt;
&lt;p&gt;わかってくると楽しい、そういうジェネレーターです。興味がある方はぜひ。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;theme&quot;&gt;theme&lt;&#x2F;h3&gt;
&lt;p&gt;自分で構築さえできれば、それそのものをテーマとして配布することができる。手順も簡単で、通常のサイトディレクトリにtheme.tomlを追加するだけ。&lt;&#x2F;p&gt;
&lt;p&gt;自分のサイトをテーマ化して独立させたものをGitLabに載せています。&lt;br &#x2F;&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;gitlab.com&#x2F;kyoheiu&#x2F;emily_zola_theme&quot;&gt;Kyohei Uto &#x2F; emily_zola_theme · GitLab&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Steamサーバー接続時トラブルを解決する（Arch Linux）</title>
            <pubDate>Wed, 23 Dec 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/steam-server-error/</link>
            <guid>https://kyoheiu.gitlab.io/post/steam-server-error/</guid>
            <description>&lt;h3 id=&quot;huan-jing&quot;&gt;環境&lt;&#x2F;h3&gt;
&lt;p&gt;OS: Arch Linux x86_64&lt;br &#x2F;&gt;
Kernel: 5.9.14-arch1-1&lt;br &#x2F;&gt;
Steamは&lt;code&gt;pacman&lt;&#x2F;code&gt;のパッケージを使用。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;wen-ti&quot;&gt;問題&lt;&#x2F;h3&gt;
&lt;p&gt;前提として、「ブラウザなどのネットワーク接続は異常なし」。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;ある日突然、Steamで購入したはずのゲームをダウンロードできなくなる。（ダウンロードアイコンをクリックしてもダウンロードが始まらない／一瞬で停止する）&lt;&#x2F;li&gt;
&lt;li&gt;上記を解決するべくSteamを再インストールしてみたところ、今度はログインができなくなる。エラーメッセージは &lt;strong&gt;&amp;quot;Steam is having trouble connecting to the Steam servers&amp;quot;&lt;&#x2F;strong&gt;.&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;h3 id=&quot;yuan-yin&quot;&gt;原因&lt;&#x2F;h3&gt;
&lt;p&gt;僕の場合は、少し前にネットワークへの接続方法を&lt;code&gt;NetworkManager&lt;&#x2F;code&gt;から&lt;code&gt;systemd-networkd&lt;&#x2F;code&gt;に切り替えた際、DHCP接続の設定が抜けていたことが原因だった模様。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;dui-ce&quot;&gt;対策&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;systemd-networkd&lt;&#x2F;code&gt;でWi-FiにDHCP接続する場合は、&lt;&#x2F;p&gt;
&lt;h4 id=&quot;1&quot;&gt;(1)&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;&#x2F;etc&#x2F;systemd&#x2F;network&#x2F;interface.network&lt;&#x2F;code&gt;に&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;[Match]
Name=interface
[Network]
DHCP=yes
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;と書いておき、&lt;strong&gt;同時に&lt;&#x2F;strong&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;2&quot;&gt;(2)&lt;&#x2F;h4&gt;
&lt;p&gt;別途&lt;code&gt;dhcpcd&lt;&#x2F;code&gt;をインストールして&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;# systemctl start dhcpcd.service
# systemctl enable dhcpcd.service
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;しておかなければならない。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;NetworkManager&lt;&#x2F;code&gt;を使っていた元々の設定では、このあたりはクリアーできていたようなのだが、&lt;code&gt;networkd&lt;&#x2F;code&gt;へ切り替えたタイミングでDHCPまわりが抜けた結果起こった問題と思われる。&lt;&#x2F;p&gt;
&lt;p&gt;しかし(2)が抜けた状態でも、ブラウザやターミナルでのインターネット接続は問題なく行えていたので、&lt;code&gt;dhcpcd&lt;&#x2F;code&gt;不在によるトラブルだということを突き止めるまで時間がかかってしまった。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;cf&quot;&gt;cf&lt;&#x2F;h3&gt;
&lt;p&gt;https:&#x2F;&#x2F;github.com&#x2F;ValveSoftware&#x2F;steam-for-linux&#x2F;issues&#x2F;2085
https:&#x2F;&#x2F;github.com&#x2F;ValveSoftware&#x2F;steam-for-linux&#x2F;issues&#x2F;4855&lt;&#x2F;p&gt;
&lt;p&gt;関連していそうなissue。「Steam以外はふつうにネット接続できている」というのがミソ。&lt;code&gt;networkd&lt;&#x2F;code&gt;以外を使っていても、同症状の場合は一度DHCP接続を確認してみるとよいかもしれない。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Google Assistantに話しかけた内容をメールで自分に送信する</title>
            <pubDate>Tue, 06 Oct 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/memo-on-googlehome/</link>
            <guid>https://kyoheiu.gitlab.io/post/memo-on-googlehome/</guid>
            <description>&lt;p&gt;Google Assistantに話しかけると、スプレッドシートに入力され、さらに内容がメールで自分に送られてくる、という仕組みを作ったのでメモ。要するに音声メモ。&lt;&#x2F;p&gt;
&lt;p&gt;流れは以下の通り。&lt;br &#x2F;&gt;
Google Assistant -&amp;gt; [IFTTT] -&amp;gt; スプレッドシート -&amp;gt; [GAS] -&amp;gt; Gmail送信&lt;&#x2F;p&gt;
&lt;p&gt;最初はIFTTTでSlackへの直接投稿を狙っていたのだが、自宅のGoogle homeでは機能しなかった。スマートフォンのAssistantでは問題なかったので、homeの仕様かもしれないが、似た症例を見つけられず、結果的に送信部分はGAS、という今の形をとることに。IFTTTとGASに分ければ、Gmailでなく他の手段に切り替えたいときも比較的イージーに変更できそう、という点もメリット。&lt;&#x2F;p&gt;
&lt;p&gt;まず、IFTTT経由でのスプレッドシートへの入力について。&lt;br &#x2F;&gt;
THISは以下の通り。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;a.png&quot; alt=&quot;IFTTT_THIS&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;THATはこちら。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;b.png&quot; alt=&quot;IFTTT_THAT&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;日付の&lt;code&gt;CreatedAt&lt;&#x2F;code&gt;、text ingredientが代入される&lt;code&gt;TextField&lt;&#x2F;code&gt;に加えて、定形であるunsentを入力しておく。&lt;br &#x2F;&gt;
スプレットシートはこのようになる。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;img src=&quot;c.png&quot; alt=&quot;IFTTT_THIS&quot; &#x2F;&gt;&lt;&#x2F;p&gt;
&lt;p&gt;このスプレッドシートからスクリプトエディタを起動。&lt;br &#x2F;&gt;
コードはこちら。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;htc&quot; class=&quot;language-htc &quot;&gt;&lt;code class=&quot;language-htc&quot; data-lang=&quot;htc&quot;&gt;var recipient = &amp;#x27;mailaddress&amp;#x27;;
var subject = &amp;#x27;memo from Google Assistant&amp;#x27;;
var sheet = SpreadsheetApp.getActiveSheet();
var last_row = sheet.getLastRow();

function main() {
  for(var i = 2; i &amp;lt;= last_row; i++){
    let isSent = sheet.getRange(i, 3);
    if(isSent.getValue() == &amp;#x27;unsent&amp;#x27;){
      var body = sheet.getRange(i, 2).getValue();
      GmailApp.sendEmail(recipient, subject, body);
      isSent.setValue(&amp;#x27;sent&amp;#x27;);
    }
  }
}
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;GAS、というかJavaScriptを触ったことがほとんどないので変なところがありそうだが、今のところ動いている。&lt;&#x2F;p&gt;
&lt;p&gt;家事をしているときに忘れていた用事や入れておいたほうがいいtodoを思いつきがちなので、すぐにGoogle nest等に話しかけることでメモがとれるのはかなり使い勝手がいい。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Arch Linuxインストールメモ(2020)</title>
            <pubDate>Sun, 20 Sep 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/archinstall/</link>
            <guid>https://kyoheiu.gitlab.io/post/archinstall/</guid>
            <description>&lt;h1 id=&quot;2021-03-21-konomemohagu-ku-xian-xing-baziyondehashi-emasen-ji-lu-tositecan-siteimasu-archwikiwodu-mimasiyou&quot;&gt;(2021-03-21) このメモは古く、現行バージョンでは使えません。記録として残しています。ArchWikiを読みましょう。&lt;&#x2F;h1&gt;
&lt;p&gt;Arch Linuxインストールの覚書。将来の自分へのメモとして。&lt;&#x2F;p&gt;
&lt;p&gt;liveインストールの時点でどの程度パッケージを入れておくかは自由だが、インストール自体が初めての場合は&lt;code&gt;pacstrap&lt;&#x2F;code&gt;段階では基本パッケージ、エディタ、ネットワーク関係（これも選択肢は複数ある）くらいにとどめておき、後でX以下を入れていくほうが理解が進むのでいいと思う。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;insutoruhou-toraburunowei-ran-fang-zhi-ce&quot;&gt;インストール後トラブルの未然防止策&lt;&#x2F;h3&gt;
&lt;ul&gt;
&lt;li&gt;ネットワークに接続できない -&amp;gt; インストール時にネットワーク周りのパッケージを導入しておく。&lt;&#x2F;li&gt;
&lt;li&gt;&lt;code&gt;pacman&lt;&#x2F;code&gt;が見つからない -&amp;gt; インストール時に&lt;code&gt;base-devel&lt;&#x2F;code&gt;を入れておく。&lt;&#x2F;li&gt;
&lt;&#x2F;ul&gt;
&lt;h3 id=&quot;hazimeni&quot;&gt;はじめに&lt;&#x2F;h3&gt;
&lt;p&gt;UEFIモードでliveUSBを起動すること&lt;&#x2F;p&gt;
&lt;h3 id=&quot;mazuwifijie-sok&quot;&gt;まずwifi接続&lt;&#x2F;h3&gt;
&lt;p&gt;wifi-menu&lt;&#x2F;p&gt;
&lt;h3 id=&quot;pateisiyon&quot;&gt;パーティション&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;risutowoque-ren&quot;&gt;リストを確認&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;fdisk -l&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pateisiyonbureiku&quot;&gt;パーティションブレイク&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;sgdisk --zap-all &#x2F;dev&#x2F;nvme0n1&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;pateisiyonfen-ge-kai-shi&quot;&gt;パーティション分割開始&lt;&#x2F;h4&gt;
&lt;pre&gt;&lt;code&gt;gdisk &amp;#x2F;dev&amp;#x2F;nvme0n1
Command (? for help): o
This option deletes all partitions and creates a new protective MBR.
Proceed? (Y&amp;#x2F;N): y

Command (? for help): n
Partition number (1-128, default 1): default
First sector (34-xxxxxxxxx, default = xxxx) or {+-}size{KMGTP}: default
Last sector (xxxx-xxxxxxxxx, default = xxxxxxxxx) or {+-}size{KMGTP}: +500M
Hex code or GUID (L to show codes, Enter = 8300): ef00

Command (? for help): n
Partition number (2-128, default 2): default
First sector (34-xxxxxxxxx, default = xxxxxx) or {+-}size{KMGTP}: default
Last sector (xxxxxx-xxxxxxxxx, default = xxxxxxxxx) or {+-}size{KMGTP}: default
Hex code or GUID (L to show codes, Enter = 8300): default

Command (? for help): w

Do you want to proceed? (Y&amp;#x2F;N): y
OK: writing new GUID partition table (GPT) to &amp;#x2F;dev&amp;#x2F;nvme0n1
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;huomatuto&quot;&gt;フォーマット&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;mkfs.fat -F32 &amp;#x2F;dev&amp;#x2F;nvme0n1p1
mkfs.ext4 &amp;#x2F;dev&amp;#x2F;nvme0n1p2
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;maunto&quot;&gt;マウント&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;mount &amp;#x2F;dev&amp;#x2F;nvme0n1p2 &amp;#x2F;mnt
mkdir &amp;#x2F;mnt&amp;#x2F;boot
mount &amp;#x2F;dev&amp;#x2F;nvme0n1p1 &amp;#x2F;mnt&amp;#x2F;boot
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;mirarisutonobian-ji&quot;&gt;ミラーリストの編集&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;vi &#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;shi-ji-he-wase&quot;&gt;時計合わせ&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;timedatectl set-ntp true&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;patukeziinsutorukai-shi&quot;&gt;パッケージインストール開始&lt;&#x2F;h3&gt;
&lt;h4 id=&quot;ji-ben-patukezi&quot;&gt;基本パッケージ&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt base linux linux-firmware base-devel man-deb man-pages&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;netutowakuguan-xi&quot;&gt;ネットワーク関係&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt networkmanager nm-connection-editor network-manager-applet&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;tekisutoedeita&quot;&gt;テキストエディタ&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt nano vi nvim&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;desukutotupuhuan-jing-x&quot;&gt;デスクトップ環境（X）&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt  xorg-server xorg-apps xorg-xinit&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;desukutotupuhuan-jing-wm&quot;&gt;デスクトップ環境（WM）&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt i3&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;i3guan-lian&quot;&gt;i3関連&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt vifm feh picom rxvt-unicode rofi parcellite&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;ri-ben-yu-zhou-ri&quot;&gt;日本語周り&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt fcitx fcitx-mozc fcitx-im fcitx-configtool&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h4 id=&quot;sonota&quot;&gt;その他&lt;&#x2F;h4&gt;
&lt;p&gt;&lt;code&gt;pacstrap &#x2F;mnt chromium xf86-video-intel lightdm lightdm-gtk-greeter&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;fstabzuo-cheng&quot;&gt;Fstab作成&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;genfstab -U &#x2F;mnt &amp;gt;&amp;gt; &#x2F;mnt&#x2F;etc&#x2F;fstab&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;chroot&quot;&gt;chroot&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;arch-chroot &#x2F;mnt&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;taimuzon&quot;&gt;タイムゾーン&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;ln -sf &#x2F;usr&#x2F;share&#x2F;zoneinfo&#x2F;Asia&#x2F;Tokyo &#x2F;etc&#x2F;localtime&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;adjtimesheng-cheng&quot;&gt;adjtime生成&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;hwclock --systohc&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;lang&quot;&gt;LANG&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;vi &amp;#x2F;etc&amp;#x2F;locale.gen
	en_US.UTF-8 UTF-8
	ja_JP.UTF-8 UTF-8

locale-gen
echo LANG=en_US.UTF-8 &amp;gt; &amp;#x2F;etc&amp;#x2F;locale.conf
export LANG=en_US.UTF-8
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;hosutonemu&quot;&gt;ホストネーム&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;echo hostname &amp;gt; &amp;#x2F;etc&amp;#x2F;hostname
vi &amp;#x2F;etc&amp;#x2F;hosts
127.0.0.1	localhost
::1		localhost
127.0.1.1	hostname.localdomain	hostname
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;rootpasuwado&quot;&gt;rootパスワード&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;passwd&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;ripozitoriatupudeto&quot;&gt;リポジトリアップデート&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;pacman -Syy&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;maikurokodoatupudeto-insutoru&quot;&gt;マイクロコードアップデート　インストール&lt;&#x2F;h3&gt;
&lt;p&gt;&lt;code&gt;pacman -S intel-ucode&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;h3 id=&quot;boot-loader&quot;&gt;boot-loader&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;pacman -S grub efibootmgr
mkdir &amp;#x2F;boot&amp;#x2F;efi
mount &amp;#x2F;dev&amp;#x2F;nvme0n1p1 &amp;#x2F;boot&amp;#x2F;efi
grub-install --target=x86_64-efi --bootloader-id=GRUB --efi-directory=&amp;#x2F;boot&amp;#x2F;efi
grub-mkconfig -o &amp;#x2F;boot&amp;#x2F;grub&amp;#x2F;grub.cfg
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h3 id=&quot;zhong-liao-zai-qi-dong&quot;&gt;終了・再起動&lt;&#x2F;h3&gt;
&lt;pre&gt;&lt;code&gt;exit
umount -R &amp;#x2F;mnt
shutdown now
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
</description>
        </item>
        <item>
            <title>systemdを使ってプログラムを定期実行する</title>
            <pubDate>Tue, 25 Aug 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/systemd-service/</link>
            <guid>https://kyoheiu.gitlab.io/post/systemd-service/</guid>
            <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;haskellscraping01&#x2F;&quot;&gt;HaskellによるWebスクレイピング&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;posttoslack&#x2F;&quot;&gt;HaskellでSlackに投稿する&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;systemdを使ってプログラムを定期実行する（この記事）&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;linux上でプログラムを定期実行する手段は主に&lt;code&gt;cron&lt;&#x2F;code&gt;(とそのフォーク）と&lt;code&gt;systemd&lt;&#x2F;code&gt;を使うものの２種類あるが、今回は&lt;code&gt;systemd&lt;&#x2F;code&gt;を使ってみた。&lt;code&gt;cron&lt;&#x2F;code&gt;のフォークである&lt;code&gt;cronie&lt;&#x2F;code&gt;も試してみたのだが、&lt;code&gt;&#x2F;etc&#x2F;&lt;&#x2F;code&gt;以下にさしあたり必要でないディレクトリが作られたり、設定ファイルが個人的に扱いづらかったりであまり肌に合わなかった。&lt;br &#x2F;&gt;
&lt;code&gt;systemd&lt;&#x2F;code&gt;を使うメリットとしては、他のserviceと同様&lt;code&gt;systemd&lt;&#x2F;code&gt;管理下で一元的に扱え、動作状況などの&lt;code&gt;journal&lt;&#x2F;code&gt;も一覧で確認できること、依存関係を非常に簡単に設定できるので今回のようなネットワーク通信を前提とする実行ファイルの場合は特に取り回しが楽であること、あたりかと思う。デメリットは、ある程度込み入った定期実行設定をしたければ、.serviceとは別に.timerが必要であること。&lt;&#x2F;p&gt;
&lt;p&gt;実際の.serviceの内容は以下のようになる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;toml&quot; class=&quot;language-toml &quot;&gt;&lt;code class=&quot;language-toml&quot; data-lang=&quot;toml&quot;&gt;[Unit]
Description=scraping
Requires=network-online.target
After=network-online.target

[Service]
Type=simple
WorkingDirectory=&amp;#x2F;home&amp;#x2F;user&amp;#x2F;xxxx
ExecStart=&amp;#x2F;home&amp;#x2F;user&amp;#x2F;.local&amp;#x2F;bin&amp;#x2F;xxxx-exe

[Install]
WantedBy=multi-user.target
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;.service作成後、&lt;code&gt;# systemctl enable&lt;&#x2F;code&gt;で起動時実行をオンにしておけばOK。&lt;br &#x2F;&gt;
ネットワークがつながった後でないとスクレイピングに失敗するため、&lt;code&gt;[Unit]&lt;&#x2F;code&gt;の&lt;code&gt;Requires&lt;&#x2F;code&gt;と&lt;code&gt;After&lt;&#x2F;code&gt;は必須。逆に言うとここさえ押さえれば、システム起動 -&amp;gt; ネットワーク確立 -&amp;gt; 実行という流れを作れるので、実際にはこの依存関係の設定で実行時間をある程度コントロールできるとも言える。一日一回とりにいけば十分なので、今回は.timerは作成しなかった。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>HaskellでSlackに投稿する</title>
            <pubDate>Mon, 24 Aug 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/posttoslack/</link>
            <guid>https://kyoheiu.gitlab.io/post/posttoslack/</guid>
            <description>&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;haskellscraping01&#x2F;&quot;&gt;HaskellによるWebスクレイピング&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;HaskellでSlackに投稿する（この記事）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;systemd-service&#x2F;&quot;&gt;systemdを使ってプログラムを定期実行する&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;scalpelで更新情報を抽出した後、保存されているテキストデータと異なっていた場合は、その旨をSlackへ通知を入れたい。
そのための関数は&lt;code&gt;Main.hs&lt;&#x2F;code&gt;とは別に&lt;code&gt;Lib.hs&lt;&#x2F;code&gt;へ保存する。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;Lib.hs&lt;&#x2F;code&gt;&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;{-# LANGUAGE OverloadedStrings #-}

module Lib where

import Network.Curl as NC

webhookurl :: URLString
webhookurl = &amp;quot;https:&amp;#x2F;&amp;#x2F;hooks.slack.com&amp;#x2F;services&amp;#x2F;xxxx&amp;#x2F;xxxxxxxxxxxxxxxxx&amp;quot;

message :: [String]
message = [&amp;quot;payload={\&amp;quot;text\&amp;quot;: \&amp;quot;UPDATE: Check http:&amp;#x2F;&amp;#x2F;example.com&amp;#x2F;\&amp;quot; }&amp;quot;]

sendUDMessage = curlPost webhookurl message
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;最初は&lt;code&gt;slack-api&lt;&#x2F;code&gt;あたりを使おうかと色々探っていたのだが、単にSlack内のチャンネルに投稿するだけであれば、Incoming Webhooksを使って投稿するのが一番手っ取り早い。&lt;&#x2F;p&gt;
&lt;p&gt;cf: &lt;a href=&quot;https:&#x2F;&#x2F;api.slack.com&#x2F;messaging&#x2F;webhooks&quot;&gt;Sending messages using Incoming Webhooks | Slack&lt;&#x2F;a&gt;&lt;&#x2F;p&gt;
&lt;p&gt;コード内でWebhooksのURLが丸裸になるのが微妙だが、セキュリティ面を厳密に考慮する必要のない私的ミニプロジェクトなのでよしとする。&lt;br &#x2F;&gt;
Webhooksを叩くには、たとえばlinuxのターミナルからであれば&lt;code&gt;curl post&lt;&#x2F;code&gt;でいける。これをHaskellで実現するには、&lt;code&gt;Network.Curl&lt;&#x2F;code&gt;ライブラリの&lt;code&gt;curlPost&lt;&#x2F;code&gt;で十分。&lt;br &#x2F;&gt;
&lt;code&gt;message&lt;&#x2F;code&gt;の形式はSlackの仕様に合わせる必要があるが、投稿内容自体は件のWebサイトへのリンクがあれば事足りるので、全体として非常にシンプルにモジュールを作れた。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>HaskellによるWebスクレイピング</title>
            <pubDate>Sun, 23 Aug 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/haskellscraping01/</link>
            <guid>https://kyoheiu.gitlab.io/post/haskellscraping01/</guid>
            <description>&lt;p&gt;RSSを吐かず、実際に訪れないと更新されたかどうか確認できないWebサイトの情報を追うために、ささやかだがスクレイピング・プロジェクトを作った。
流れとしてはこういう感じになる。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;Haskell(&lt;code&gt;scalpel&lt;&#x2F;code&gt;)により、更新情報の通知エリアのみを抜き出す&lt;&#x2F;li&gt;
&lt;li&gt;抜き出してきた情報をローカルの&lt;code&gt;update.txt&lt;&#x2F;code&gt;の中身と比較し、同一であれば何もしない、異なっていればそれを&lt;code&gt;update.txt&lt;&#x2F;code&gt;に上書きした上でSlackのチャンネルへ通知（投稿）&lt;&#x2F;li&gt;
&lt;li&gt;このプログラムを、linux起動時にネットワークを確保した上で走るように&lt;code&gt;systemd&lt;&#x2F;code&gt;を使って.serviceを作成&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;この記事では(1)と(2)の&lt;code&gt;update.txt&lt;&#x2F;code&gt;の上書きまでをまとめる。続く部分は以下の記事に。&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;HaskellによるWebスクレイピング（この記事）&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;posttoslack&#x2F;&quot;&gt;HaskellでSlackに投稿する&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;li&gt;&lt;a href=&quot;https:&#x2F;&#x2F;kyoheiu.gitlab.io&#x2F;post&#x2F;systemd-service&#x2F;&quot;&gt;systemdを使ってプログラムを定期実行する&lt;&#x2F;a&gt;&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;&lt;code&gt;Main.hs&lt;&#x2F;code&gt;は以下の通り。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;{-#LANGUAGE OverloadedStrings#-}

module Main where

import qualified Data.ByteString.Char8 as B
import Text.HTML.Scalpel
import Data.Maybe
import Lib

url :: URL
url = &amp;quot;http:&amp;#x2F;&amp;#x2F;example.com&amp;quot;

filePath :: FilePath
filePath = &amp;quot;update.txt&amp;quot;

data NewsText
    = NewsText { time :: B.ByteString
               , contents :: B.ByteString } deriving (Show,Read,Eq)

main = do
    new &amp;lt;- scrapeURL url information
    old &amp;lt;- B.readFile filePath
    let new2 = B.pack $ show $ fromJust new
    if new2 == old then print &amp;quot;no update.&amp;quot;
                   else do
                       Lib.sendUDMessage
                       B.writeFile filePath new2
    where
            information :: Scraper B.ByteString [NewsText]
            information = chroots (&amp;quot;div&amp;quot; @: [hasClass &amp;quot;information&amp;quot;]) newsTexts

            newsTexts :: Scraper B.ByteString NewsText
            newsTexts = do
                time &amp;lt;- text $ &amp;quot;dt&amp;quot;
                contents &amp;lt;- text $ &amp;quot;dd&amp;quot;
                return $ NewsText time contents
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;HaskellにおけるWebスクレイピング用のライブラリは他にいくつかあるようだけれど、&lt;code&gt;scalpel&lt;&#x2F;code&gt;は豊富な機能を持ち、たいていのことは可能という印象を受ける。今回の作業においてはオーバーキル気味かもしれないが、一回いじっておくとわりとすんなり他のケースに対しても応用できる、素直なライブラリのように感じた。&lt;br &#x2F;&gt;
&lt;code&gt;scalpel&lt;&#x2F;code&gt;を使う部分は初心者にも大して難しくなかった。&lt;code&gt;div&lt;&#x2F;code&gt;の&lt;code&gt;class&lt;&#x2F;code&gt;でまず絞り、さらにそこからタグで絞って抜き出す、という感じだ。きちんとやるならもっとエラーケースについて考えないといけないはずだが今回はパス。&lt;code&gt;scrapeURL&lt;&#x2F;code&gt;は&lt;code&gt;StringLike str =&amp;gt; URL -&amp;gt; Scraper str a -&amp;gt; IO (Maybe a)&lt;&#x2F;code&gt;となっているので、仮に該当するタグが消失していても&lt;code&gt;Nothing&lt;&#x2F;code&gt;が返ってくる。シンプルだが&lt;code&gt;Maybe&lt;&#x2F;code&gt;の威力を感じる部分。&lt;br &#x2F;&gt;
結局未解決なのは、抜き出してくるテキストに日本語が含まれている場合、&lt;code&gt;Data.Text&lt;&#x2F;code&gt;系を採用しても正確に日本語を拾えない点。これはこちらの文字列の拾い方が悪いのか、対象のWebサイトの仕様なのかよくわからない（要調査）。今回の狙いは更新の有無のみをテキストの「イコールorノットイコール」で判別し、通知する、というものなので、文字化けは許容範囲と判断した。&lt;br &#x2F;&gt;
その上で、&lt;code&gt;Data.Bytestring.Char8&lt;&#x2F;code&gt;を採用しているのは、&lt;code&gt;String&lt;&#x2F;code&gt;はパフォーマンス上一応避けておきたいというのと、過去のテキストと現在のテキストそれぞれを読み込む際のすり合わせのしやすさから。&lt;code&gt;now&lt;&#x2F;code&gt;と&lt;code&gt;old&lt;&#x2F;code&gt;の型が違っていると、内容が同じでも違うものと判断してしまうので、型をちゃんと見なくてはいけない。Visual Studio Codeのエクステンション&lt;code&gt;Haskell&lt;&#x2F;code&gt;に最近&lt;code&gt;haskell-ide-engine&lt;&#x2F;code&gt;が統合されたので、型チェックにはとても有用だった。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>リストモナドの非決定性／可能性について</title>
            <pubDate>Sun, 24 May 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/listmonad/</link>
            <guid>https://kyoheiu.gitlab.io/post/listmonad/</guid>
            <description>&lt;p&gt;勉強中、リストモナドの挙動が興味深かったので、ざっくり調べてみた結果をとりあえずまとめてみる。&lt;&#x2F;p&gt;
&lt;p&gt;リストは次のように実装される。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;Data List = Empty | cons a (List a)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;そして、&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;Prelude&amp;gt; zipWith (+) [1,2,3] [4,5,6]
[5,7,9]

Prelude&amp;gt; concatMap (\x -&amp;gt; [x, x^2]) [1,2,3]
[1,1,2,4,3,9]

Prelude&amp;gt; [1,2,3] ++ [4,5,6]
[1,2,3,4,5,6]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;まずはその中に入っているものはとにかく入っているのだという前提で学んでいく。&lt;br &#x2F;&gt;
こうしたリストの使い勝手の良さはHaskellのよいところの１つだと思うが、さらに面白いのは、実は&lt;code&gt;Fanctor, Applicative, Monad&lt;&#x2F;code&gt;各クラスのインスタンスであるという点。つまり、（&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B07SFCMP66&#x2F;&quot;&gt;入門Haskellプログラミング&lt;&#x2F;a&gt;の表現をまず借りると）上記したような「コンテナとしてのリスト」という側面と別に、「コンテクストとしてのリスト」が存在している。&lt;&#x2F;p&gt;
&lt;p&gt;「コンテクストとしてのリスト」、つまりモナドリストは、たとえば次のような使い方をされる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;Prelude&amp;gt; (+) &amp;lt;$&amp;gt; [1,2,3] &amp;lt;*&amp;gt; [4,5,6]
[5,6,7,6,7,8,7,8,9]

Prelude&amp;gt; (++) &amp;lt;$&amp;gt; [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;] &amp;lt;*&amp;gt; [&amp;quot;cat&amp;quot;,&amp;quot;dog&amp;quot;] 
[&amp;quot;white cat&amp;quot;,&amp;quot;white dog&amp;quot;,&amp;quot;black cat&amp;quot;,&amp;quot;black dog&amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Will Kurtによると、モナドとしてのリストを理解するには「非決定論的な計算」という考え方をするのが最善だという。&lt;code&gt;&amp;lt;*&amp;gt;&lt;&#x2F;code&gt;でつながれたそれぞれのリストは「そのうちのどれであるかが決定されていない」ものであり、計算結果はありうる結果すべてを表現している…。&lt;br &#x2F;&gt;
プログラミングの世界で非決定論的、なんていう言葉を目にするとは思っていなかっただけに、これには驚かされた。&lt;&#x2F;p&gt;
&lt;p&gt;コンテクストという言葉は、おそらく厳密に言えば圏論をしっかり理解しないと腑に落ちないワードだと思う（圏論を理解していないので断言もできない）のだが、Haskellでのモナドを頭に入れるだけであれば次のように考えるとよさそうだ。&lt;&#x2F;p&gt;
&lt;p&gt;コンテナとコンテクスト、という二種類のデータのあり方は、pure function 純粋関数とunpure function 非純粋関数にそれぞれ対応している。&lt;br &#x2F;&gt;
関数が純粋であるとはこの場合、side effectを持たず、その関数にある引数を与えたとき、必ず同じ返り値が出てくる、という意味だ。これは、関数の役割が、ただその関数の定義と引数のみから完全に表現できる、ということでもある。&lt;br &#x2F;&gt;
それは数学の純粋性にどこか似ている。定義、命題、そういったクリアーなモジュールとして在るのが純粋関数、そういう風に考える。&lt;br &#x2F;&gt;
では非純粋とはなにかといえば、「それ自体」以外の役割、something elseを持つかもしれないもの、ということになる。関数と引数が持つデータ以外に何かを引き連れていたり、何かを生んだり、何かを表示したり…といった、つまりside effectを持つかもしれないものが非純粋関数だ。これを扱うために&lt;code&gt;Fanctor, Applicative, Monad&lt;&#x2F;code&gt;という考え方がある。&lt;&#x2F;p&gt;
&lt;p&gt;次に、純粋なものとしてのリストと、非純粋なものとしてのリスト、それぞれをコンテナ／コンテクストとして呼ぶ「意味」は何か、ということを考える。どちらも、ある種の比喩を含む表現だと思う。この比喩が面白いと思うのだが、まずコンテナのほうは「箱」だ。しかもフタが空いていて、何かを追加したり取り出したりするのは自由だが、とにかく中にはこれこれが入っているということが「確定している」。だから計算結果にはゆらぎがない（ように見える）。&lt;br &#x2F;&gt;
一方、コンテクストとは、「何かを理解するために役立つ、状況や事象、情報」のことである。つまり、その何かというのは、コンテクスト(=something else)なしでは完全には意味をとれない。意味が決定されていない。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;Prelude&amp;gt; (++) &amp;lt;$&amp;gt; [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;] &amp;lt;*&amp;gt; [&amp;quot;cat&amp;quot;,&amp;quot;dog&amp;quot;] 
[&amp;quot;white cat&amp;quot;,&amp;quot;white dog&amp;quot;,&amp;quot;black cat&amp;quot;,&amp;quot;black dog&amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上の式は、白か黒かが決定されておらず、犬か猫かも決定されていない、というように読むこともできる。結果は、すべてのあり得る可能性を拾い尽くしたものになる。&lt;&#x2F;p&gt;
&lt;p&gt;もちろんこれは、あえて文学的に表現すれば…ということで、実際にはこの式は&lt;code&gt;do&lt;&#x2F;code&gt;構文を用いると次のようになる。&lt;br &#x2F;&gt;
（参考: &lt;a href=&quot;https:&#x2F;&#x2F;kazu-yamamoto.hatenablog.jp&#x2F;entry&#x2F;20090313&#x2F;1236935179&quot;&gt;リストモナドの動作原理を考える - あどけない話&lt;&#x2F;a&gt;）&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;sample = do
    x &amp;lt;- [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;]
    y &amp;lt;- [&amp;quot;cat&amp;quot;,&amp;quot;dog&amp;quot;]
    return (x ++ y)

*Main&amp;gt; sample
[&amp;quot;white cat&amp;quot;,&amp;quot;white dog&amp;quot;,&amp;quot;black cat&amp;quot;,&amp;quot;black dog&amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;上の&lt;code&gt;sample&lt;&#x2F;code&gt;関数を脱糖するとこうなる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;sample = [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;] &amp;gt;&amp;gt;= \x -&amp;gt; [&amp;quot;cat&amp;quot;,&amp;quot;dog&amp;quot;] &amp;gt;&amp;gt;= \y -&amp;gt; return (x ++ y)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;リストモナドにおいて、&lt;code&gt;return&lt;&#x2F;code&gt;と&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;はそれぞれ&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;return x = [x]
l &amp;gt;&amp;gt;= f = concatMap f l
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;このように定義されているから、&lt;code&gt;sample&lt;&#x2F;code&gt;関数はさらに&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;sample = concatMap (\x -&amp;gt; [&amp;quot;cat&amp;quot;,&amp;quot;dog&amp;quot;] &amp;gt;&amp;gt;= \y -&amp;gt; [x ++ y]) [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;]
       = concatMap (\x -&amp;gt; concatMap (\y -&amp;gt; [x ++ y]) [&amp;quot;cat&amp;quot;,&amp;quot;dog&amp;quot;]) [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;と変形できる。&lt;br &#x2F;&gt;
これを内側、外側の順に計算すると、&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;sample = concatMap (\x -&amp;gt; [x ++ &amp;quot;cat&amp;quot;, x ++ &amp;quot;dog&amp;quot;]) [&amp;quot;white &amp;quot;,&amp;quot;black &amp;quot;]
       = [&amp;quot;white cat&amp;quot;,&amp;quot;white dog&amp;quot;,&amp;quot;black cat&amp;quot;,&amp;quot;black dog&amp;quot;]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;リストモナドの計算に非決定性／すべてのありうる可能性…といったsomething elseが現れる根拠は、この式変換でいうと&lt;code&gt;concatMap&lt;&#x2F;code&gt;の存在だろう。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;:t concatMap
concatMap :: Foldable t =&amp;gt; (a -&amp;gt; [b]) -&amp;gt; t a -&amp;gt; [b]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;ところで、&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;の型は&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;:t (&amp;gt;&amp;gt;=)
(&amp;gt;&amp;gt;=) :: Monad m =&amp;gt; m a -&amp;gt; (a -&amp;gt; m b) -&amp;gt; m b
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;こうなっている。&lt;br &#x2F;&gt;
&lt;code&gt;concatMap&lt;&#x2F;code&gt;とは引数の順番が違うが、&lt;code&gt;flip&lt;&#x2F;code&gt;を使ってもよいと考えると&lt;code&gt;concatMap&lt;&#x2F;code&gt;のほうはこうなる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;:t flip concatMap
flip concatMap :: Foldable t =&amp;gt; t a -&amp;gt; (a -&amp;gt; [b]) -&amp;gt; [b]
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これを&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;と見比べてみると、&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;の&lt;code&gt;m a&#x2F;m b&lt;&#x2F;code&gt;がconcatMapでは&lt;code&gt;t a&#x2F;[b]&lt;&#x2F;code&gt;になっているだけで、構造としては同じだ。「モナドな何かについて、モナドでない何かをとってモナドな何かを返す関数を適用することで、モナドな何かを返す」…これが&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;だとすれば、「&lt;code&gt;Foldable&lt;&#x2F;code&gt;な何かについて、リストでない何かをとってリストを返す関数を適用することで、リストを返す」ものが&lt;code&gt;concatMap&lt;&#x2F;code&gt;だというわけだ。一般論としての&lt;code&gt;&amp;gt;&amp;gt;=&lt;&#x2F;code&gt;と&lt;code&gt;concatMap&lt;&#x2F;code&gt;の関連性（正確ではないかもしれないが、抽象／具体の関係と呼んでみる）が、こう表現すると明らかになってくる。つまり、要素をリストに入れ、リストを返すという「リスト化」が、&lt;code&gt;&amp;lt;*&amp;gt;&lt;&#x2F;code&gt;でつながれたそれぞれの引数について不足なく行われる結果、可能性全体を表現するかのようなリストが生成される、というふうに考えることができる。&lt;&#x2F;p&gt;
&lt;p&gt;ここで文学的な解釈にあえて戻ってみると、結局、非決定性／可能性とは全体性なのだ、ということができるような気がする。こぼさずすべてを取り尽くすことが非決定性／可能性を生む。逆に言えば、その一部をとらないーすくわず、捨て去るたび毎に、それは凝固し、決定的になっていく。同時に、可能性がなくなり、固定されていく。こんな風に言い換えることもできるかもしれない。決まっていないことは可能性であり、決めることはゆらぎがなくなっていくことだと。当たり前といえば当たり前なのだが、あまりにも豊かすぎる表現のように感じられる。モナドという概念は、やっぱり面白い。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>フィボナッチ数列（memoization）</title>
            <pubDate>Mon, 04 May 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/memofib/</link>
            <guid>https://kyoheiu.gitlab.io/post/memofib/</guid>
            <description>&lt;h2 id=&quot;memoization&quot;&gt;memoization(?)&lt;&#x2F;h2&gt;
&lt;p&gt;次に、memoizationによるフィボナッチ数列関数の作成にトライしてみる。&lt;br &#x2F;&gt;
memoizationとは日本語だとメモ化とも呼ばれるプログラミングの手法で、「一度計算したものを記録しておき、必要なときに取り出すようにする」効率化のこと、らしい。&lt;&#x2F;p&gt;
&lt;p&gt;前回のslowFibが遅い理由は、一度計算してしまえばそのあと再利用できる項を愚直に展開して項数を増やしているからだ。これを解決するのに、memoizationの発想は有用ではないだろうか、というわけ。&lt;br &#x2F;&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;wiki.haskell.org&#x2F;Memoization&quot;&gt;wiki.haskell.org&lt;&#x2F;a&gt;を参考に、memoizationを実装してみる。リストに計算結果を記録しておき、都度それを取り出す、というものだ。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;memoFib1 = (map fib [0..] !!)
            where
                fib 0 = 1
                fib 1 = 1
                fib n = memoFib1 (n-1) + memoFib1 (n-2)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;*Main&amp;gt; memoFib1 30
1346269
(0.01 secs, 120,256 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これは確かに速い。&lt;br &#x2F;&gt;
ところが、次のように少しだけ変形をすると、結果は全く異なるものになる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;memoFib2 n = (map fib [0..]) !! n
            where
                fib 0 = 1
                fib 1 = 1
                fib n = memoFib2 (n-1) + memoFib2 (n-2)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;*Main&amp;gt; memoFib2 30
1346269
(1.46 secs, 2,312,682,608 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;実は最初自分なりに実装したのが&lt;code&gt;memoFib2&lt;&#x2F;code&gt;のほうだったので、だいぶ混乱した。なぜこのような違いが出るのか理解ができなければ、他のケースでmemoizationを使っていくことができない。&lt;br &#x2F;&gt;
どうしてもわからなかったので、r&#x2F;Haskellで質問してみたら、あっさり&lt;a href=&quot;https:&#x2F;&#x2F;www.reddit.com&#x2F;r&#x2F;haskell&#x2F;comments&#x2F;a3va9p&#x2F;why_pointfree_makes_difference_to_this_simple&#x2F;&quot;&gt;過去ログの回答&lt;&#x2F;a&gt;をもらえた。感謝。&lt;br &#x2F;&gt;
以下、まずこの回答について。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;ramudaji-suan-biao-xian-niyorubian-xing&quot;&gt;ラムダ計算表現による変形（？）&lt;&#x2F;h2&gt;
&lt;p&gt;上記の回答によると、それぞれの&lt;code&gt;memoFibx&lt;&#x2F;code&gt;はラムダ計算表現を用いて次のように変形できる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;memoFib1 = let fibList = map fib [0..] in (fibList !!)
&amp;lt;-&amp;gt; memoFib1 = let fibList = map fib [0..] in \n -&amp;gt; fibList !! n

memoFib2 n = let fibList = map fib [0..] in fibList !! n
&amp;lt;-&amp;gt; memoFib2 n = \n -&amp;gt; let fibList = map fib [0..] in fibList !! n
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;したがって、結局&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;(memoFib1) let fibList = map fib [0..] in \n -&amp;gt; fibList !! n
(memoFib2) \n -&amp;gt; let fibList = map fib [0..] in fibList !! n
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;この２つの式の差はなにか、ということになる。&lt;br &#x2F;&gt;
&lt;code&gt;Fib1&lt;&#x2F;code&gt;では&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;が一度だけ計算されるが、Fib2では[0..n]までその都度計算されてしまう。これが上記回答の趣旨だった。&lt;&#x2F;p&gt;
&lt;p&gt;しかしこれがよく分からない。&lt;code&gt;Fib2&lt;&#x2F;code&gt;でnが２回出てきているあたりが怪しいようにも思うが、そもそも最初の関数定義に&lt;code&gt;fibList&lt;&#x2F;code&gt;が登場していないので、いまいち腑に落ちない感じがある。もちろん、ラムダ計算表現に慣れていないから飲み込みづらいということも否定できない。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;guan-shu-ben-ti-towherejie-noguan-xi-karakao-ezhi-su&quot;&gt;関数本体とwhere節の関係から考え直す&lt;&#x2F;h2&gt;
&lt;p&gt;そこで、最初の&lt;code&gt;memoFib2&lt;&#x2F;code&gt;を、次のように&lt;code&gt;where&lt;&#x2F;code&gt;節を用いて表現し直してみる。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;memoFib3 n = fibList !! n
    where
        fibList = map fib [0..] 
        fib 0 = 1
        fib 1 = 1
        fib n = (fibList !! (n-1)) + (fibList !! (n-2))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;*Main&amp;gt; memoFib3 30
1346269
(0.01 secs, 121,112 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;redditの回答にヒントを得て、&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;を１行目から外し、実質の中身をすべて&lt;code&gt;where&lt;&#x2F;code&gt;節内でまとめようとしたものだ。この&lt;code&gt;memoFib3&lt;&#x2F;code&gt;は問題なく計算を行える。&lt;br &#x2F;&gt;
これを、次の関数定義と見比べると、何が問題なのかが見えてくるように思う。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;memoFib4 n = (map fib [0..]) !! n
    where
        fib 0 = 1
        fib 1 = 1
        fib n = (map fib [0..] !! (n-1)) + (map fib [0..] !! (n-2))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre&gt;&lt;code&gt;*Main&amp;gt; memoFib4 30
1346269
(1.31 secs, 2,075,739,480 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Fib3では、&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;が一度だけ計算され、&lt;code&gt;fibList&lt;&#x2F;code&gt;に保存される。&lt;code&gt;fib n&lt;&#x2F;code&gt;も&lt;code&gt;memoFib3&lt;&#x2F;code&gt;も、この&lt;code&gt;fibList&lt;&#x2F;code&gt;から値をとってきているので、計算が速くなる。&lt;br &#x2F;&gt;
一方、&lt;code&gt;Fib4&lt;&#x2F;code&gt;は&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;が３回登場している。これはその都度&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;を計算しているということだから、遅い。&lt;&#x2F;p&gt;
&lt;p&gt;これを踏まえて元の定義をもう一度見てみると、話は実は非常に単純で、最初の&lt;code&gt;Fib2&lt;&#x2F;code&gt;では、&lt;code&gt;fib&lt;&#x2F;code&gt;は&lt;code&gt;memoFib2&lt;&#x2F;code&gt;に、そして&lt;code&gt;memoFib2&lt;&#x2F;code&gt;は&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;に結びついている。したがって&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;が最低限以上の回数計算されている。一方、&lt;code&gt;memoFib1&lt;&#x2F;code&gt;がポイントフリーで表現されているということは、&lt;code&gt;map fib [0..]&lt;&#x2F;code&gt;は最終的に必要になった段階でようやく評価される、ということを実質的に意味している。このポイントフリーと遅延評価の関係を意識できていないと、大変混乱する羽目になる、というわけだった。&lt;br &#x2F;&gt;
適当に人のコードを写経すると理解不足なところが出てくる、という教訓。&lt;&#x2F;p&gt;
&lt;p&gt;ところでmemoizationに話を戻すと、この場合、&lt;code&gt;fibList = map fib [0..]&lt;&#x2F;code&gt; がその役割を担っている。&lt;code&gt;slowfib&lt;&#x2F;code&gt;からスタートしてみると、&lt;code&gt;map f xs&lt;&#x2F;code&gt;で計算結果を記録していくmemoizationのやり方はとても自然に感じられる。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>フィボナッチ数列（Haskellタプリング法）</title>
            <pubDate>Sun, 03 May 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/tuplingfib/</link>
            <guid>https://kyoheiu.gitlab.io/post/tuplingfib/</guid>
            <description>&lt;h2 id=&quot;naive-fib&quot;&gt;naive fib&lt;&#x2F;h2&gt;
&lt;p&gt;まずnaiveな定義から。&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;slowFib 0 = 1
slowFib 1 = 1
slowFib n = slowFib (n-1) + slowFib (n-2)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;*Main&amp;gt; slowFib 30
1346269
(1.54 secs, 929,853,032 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;n=30くらいまではなんとか耐えられるが、びっくりするくらい遅い。&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B004VB3V0K&#x2F;&quot;&gt;Learn You a Haskell for Great Good&lt;&#x2F;a&gt;に特に注釈無しで記載されているので、学習中の人は一度は試してみたことがあると思う。Haskellってもしかして遅いのかな？ と学習者を不安にさせる遅さだ。&lt;br &#x2F;&gt;
&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;4048930532&#x2F;&quot;&gt;Haskellによる関数プログラミングの思考法&lt;&#x2F;a&gt;によると、この関数の計算量はO(Φ^n)（Φ=(1+√5)&#x2F;2, 黄金律）なので、指数オーダーで計算量が増えていくことになるが、黄金律と言われてもあまりピンとこないのでもう少しこねてみる。&lt;br &#x2F;&gt;
計算を分解してみると、たぶん次のようになるはずだ。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;slowFib n
= slowFib (n-1) + slowFib (n-2)
= (slowFib (n-2) + slowFib (n-3)) + (slowFib (n-3) + slowFib (n-4))
= (slowFib (n-3) + slowFib (n-4)) + (slowFib (n-4) + slowFib (n-5)) + (slowFib (n-4) + slowFib (n-5)) + (slowFib (n-5) + slowFib (n-6))
...
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;２行めでは２項だったのが３行めでは４項、４行めで８項になっているので、ここまでは項数は^2で増えていく。もちろんすべての項が一律に倍の項数になるわけではなく、前の項から順番に、いずれ&lt;code&gt;slowFib 1(0)&lt;&#x2F;code&gt;に達するので、それ以上は項数は増えない。そして全体でみると、２より少し小さいくらいの数字（＝黄金律）の指数オーダーで項数が増えていく。…ということだと思う。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;tapuringufa&quot;&gt;タプリング法&lt;&#x2F;h2&gt;
&lt;p&gt;&lt;a href=&quot;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;B07SFCMP66&#x2F;&quot;&gt;入門Haskellプログラミング&lt;&#x2F;a&gt;にあったヒントをもとに実装したもの。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;fasterFib 1 (a,b) = a
fasterFib n (a,b) = fasterFib (n-1) (a+b,a)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;*Main&amp;gt; fasterFib 30 (1,1)
1346269
(0.01 secs, 117,312 bytes)

*Main&amp;gt; fasterFib 50 (1,1)
20365011074
(0.01 secs, 127,296 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;第一引数はカウンタで、これが1になるまで1つずつ減らしていく。減らしていく過程で第二引数のペアが足され、次のペアを生成する。これは（たぶん）タプリング法と呼ばれる手法なのだが、なぜこれが速いのか、自分で実装しておきながら理屈がいまいちピンとこなかったので、分解してみる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;fasterFib 30 (1,1)
= fasterFib 29 (2,1)
= fasterFib 28 (3,2)
= fasterFib 27 (5,3)
...
= fasterFib 1 (1346269,832040)
= 1346269
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;項数がどの行も同じ１つで済んでいるということが、こういうふうに書いてみれば明らかだ。
&lt;a href=&quot;http:&#x2F;&#x2F;https:&#x2F;&#x2F;www.amazon.co.jp&#x2F;dp&#x2F;4048930532&#x2F;&quot; title=&quot;Haskellによる関数プログラミングの思考法&quot;&gt;Haskellによる関数プログラミングの思考法&lt;&#x2F;a&gt;は少し違う形で実装していて、&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;--fib2 n = (fib n, fib (n+1))と考えて
fib2 0 = (0,1)
fib2 n = (b,a+b)
	where
		(a,b) = fib 2 (n-1)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;としている。著者によると、「タプリング法では引数を追加して関数を一般化するのではなく、結果を追加して関数を一般化する」(p.161)。&lt;br &#x2F;&gt;
&lt;code&gt;fasterFib&lt;&#x2F;code&gt;は引数（左辺）のほうに追加しているが、実質的には&lt;code&gt;fib n = fib (n-1) + fib (n-2)&lt;&#x2F;code&gt;という計算の結果を引数として追加しているので、変形タプリング法と呼べる、かもしれない。&lt;code&gt;fib2&lt;&#x2F;code&gt;のほうは逆に、式の右辺にペアの形で追加している。タプル（ペア）の形で計算の結果をまとめて関数内で用いる、というのがタプリング法の肝であるようだ。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Haskellの素因数分解</title>
            <pubDate>Sat, 02 May 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/primefactors/</link>
            <guid>https://kyoheiu.gitlab.io/post/primefactors/</guid>
            <description>&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;headPrimeFactor :: Integer -&amp;gt; Integer
headPrimeFactor n = if fstprime == []
                    then n
                    else head fstprime
                        where
                            fstprime = filter primes [2..sqrt&amp;#x27;]
                            primes x = n `mod` x == 0
                            sqrt&amp;#x27; = floor $ sqrt $ fromIntegral n

primeFactorsList :: Integer -&amp;gt; [Integer]
primeFactorsList 1 = []
primeFactorsList n = (headPrimeFactor n) : primeFactorsList (n `div` (headPrimeFactor n))
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;h2 id=&quot;memo&quot;&gt;メモ&lt;&#x2F;h2&gt;
&lt;p&gt;たとえば&lt;code&gt;primeFactorsList 24 = [2, 2, 2, 3]&lt;&#x2F;code&gt;となるような関数&lt;code&gt;primeFactorsList&lt;&#x2F;code&gt;を作りたい。&lt;br &#x2F;&gt;
このリストがどう定義できるかを考えると、まず先頭の2というのは、24を[2..]で順番に割っていったときの最初の約数とおくことができる。さらにその次の2は、最初の約数である2で24を割った12について、[2..]で順番に割っていったときの最初の約数である。&lt;br &#x2F;&gt;
つまり、リストの&lt;code&gt;head&lt;&#x2F;code&gt;をとっていき、それを再帰でコンスしていくというのが、Haskellによる素因数分解の素朴な解法となるはずだ。&lt;&#x2F;p&gt;
&lt;p&gt;&lt;code&gt;headPrimeFactor&lt;&#x2F;code&gt;は&lt;code&gt;primeFactorsList&lt;&#x2F;code&gt;の補助関数で、nの平方根の整数部分までの整数のうち、nの約数となるものを&lt;code&gt;filter primes&lt;&#x2F;code&gt;で抽出し、その先頭の数字を返すもの。ただし、nが素数の場合はリストが空になるので、よく考えず&lt;code&gt;head&lt;&#x2F;code&gt;を使うとエラーが出てしまう（というか出た）。これを回避するために、リストが空である場合とそうでない場合で分岐を作らないといけない（&lt;code&gt;maybeHead&lt;&#x2F;code&gt;で&lt;code&gt;Nothing | Just Integer&lt;&#x2F;code&gt;を返すバージョンも書いてみたが、&lt;code&gt;head&lt;&#x2F;code&gt;を使う場合と使わない場合で分けたほうが当然ながらシンプル）。空の場合はnを、そうでない場合は最も小さい約数を返す関数となる。&lt;br &#x2F;&gt;
これを再帰的にコンスしていくのが&lt;code&gt;primeFactorsList&lt;&#x2F;code&gt;で、仕組みとしては上に書いた通り。&lt;&#x2F;p&gt;
&lt;p&gt;適当な整数を素因数分解してみると、次のようになる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;*Main&amp;gt; primeFactorsList 2039801
[23,131,677]
(0.01 secs, 170,624 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;pre data-lang=&quot;bash&quot; class=&quot;language-bash &quot;&gt;&lt;code class=&quot;language-bash&quot; data-lang=&quot;bash&quot;&gt;*Main&amp;gt; primeFactorsList 2380479237540923
[29,82085490949687]
(3.48 secs, 2,754,399,560 bytes)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;ひとつの整数の素因数分解として速いか遅いか、まだよくわからないけれど…。 
もう少し工夫したやり方があるような気もするなぁ。&lt;&#x2F;p&gt;
</description>
        </item>
        <item>
            <title>Haskellで種類の数を数える（重複の削除）</title>
            <pubDate>Fri, 01 May 2020 00:00:00 +0000</pubDate>
            <link>https://kyoheiu.gitlab.io/post/dataset/</link>
            <guid>https://kyoheiu.gitlab.io/post/dataset/</guid>
            <description>&lt;p&gt;複数の要素を扱うための基礎的なライブラリをいろいろテストしてみる題材として、こちらの問題を使用させてもらう。&lt;&#x2F;p&gt;
&lt;p&gt;At Coder abc164 C - gacha &lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;atcoder.jp&#x2F;contests&#x2F;abc164&#x2F;tasks&#x2F;abc164_c&lt;&#x2F;p&gt;
&lt;blockquote&gt;
&lt;p&gt;実行時間制限: 2 sec &#x2F; メモリ制限: 1024 MB
配点 : 300点
問題文
くじ引きをN回行い、i回目には種類が文字列Siで表される景品を手に入れました。
何種類の景品を手に入れましたか？&lt;&#x2F;p&gt;
&lt;p&gt;制約
1 &amp;lt;= N &amp;lt;= 2*(10^5)
Siは英小文字のみからなり、長さは1以上10以下&lt;&#x2F;p&gt;
&lt;&#x2F;blockquote&gt;
&lt;p&gt;たとえば入力が&lt;&#x2F;p&gt;
&lt;pre&gt;&lt;code&gt;3
apple
orange
apple
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;の場合は、appleとorangeの２種類を入手することになるので、正解の出力は2となる。&lt;&#x2F;p&gt;
&lt;p&gt;結局のところ、「種類の数」をどう定義するか（Haskellではどう定義できるか）を考えるわけだが、&lt;&#x2F;p&gt;
&lt;ol&gt;
&lt;li&gt;ひとつひとつの要素が、すでにあるリストに含まれていないかを、再帰関数でチェックしていった結果生成されるリストのlength&lt;&#x2F;li&gt;
&lt;li&gt;要素のかたまりを、同じ要素のかたまりに分けたときの、そのかたまりの数&lt;&#x2F;li&gt;
&lt;&#x2F;ol&gt;
&lt;p&gt;たとえばこういったふうにおくことができると思う。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;zai-gui-guan-shu-dejie-ku&quot;&gt;再帰関数で解く&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;risutowoyong-itazai-gui-guan-shu&quot;&gt;リストを用いた再帰関数&lt;&#x2F;h3&gt;
&lt;p&gt;まずリストで再帰関数を作ったバージョン。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;--TLE
import Control.Monad

delDupe :: [String] -&amp;gt; [String] -&amp;gt; [String]
delDupe [] _ = []
delDupe (x:xs) lst
    | x `notElem` lst = x : delDupe xs (x : lst)
    | otherwise       = delDupe xs lst

main = do
    n &amp;lt;- readLn
    s &amp;lt;- replicateM n getLine
    print $ length $ delDupe s []
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;delDupe&lt;&#x2F;code&gt;は、与えられるリストを&lt;code&gt;(x:xs)&lt;&#x2F;code&gt;とし、重複がなければ&lt;code&gt;x&lt;&#x2F;code&gt;を第二引数の&lt;code&gt;lst&lt;&#x2F;code&gt;に加えつつ、&lt;code&gt;x&lt;&#x2F;code&gt;を含むリストを返す再帰関数。
しかしこれでは遅く、18の入力のうち７つがTLEとなってしまう。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;nubnozheng-ti&quot;&gt;nubの正体&lt;&#x2F;h3&gt;
&lt;p&gt;あとで気づいたのだが、Preludeにはリストの重複を削除する関数&lt;code&gt;nub&lt;&#x2F;code&gt;が標準でついているので、次のように書けることは書ける。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;import Control.Monad

main = do
    n &amp;lt;- readLn
    s &amp;lt;- replicateM n getLine
    print $ length $ nub s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;が、これは実は最初の「再帰での重複チェック→新たなリストの生成」と実行時間・メモリ使用量ともに変わらなかった。Preludeの&lt;code&gt;nub&lt;&#x2F;code&gt;の定義はこちら。&lt;&#x2F;p&gt;
&lt;p&gt;https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;base-4.12.0.0&#x2F;docs&#x2F;src&#x2F;Data.OldList.html#nub&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;-- | &amp;#x2F;O(n^2)&amp;#x2F;. The &amp;#x27;nub&amp;#x27; function removes duplicate elements from a list.
-- In particular, it keeps only the first occurrence of each element.
-- (The name &amp;#x27;nub&amp;#x27; means \`essence\&amp;#x27;.)
-- It is a special case of &amp;#x27;nubBy&amp;#x27;, which allows the programmer to supply
-- their own equality test.
--
-- &amp;gt;&amp;gt;&amp;gt; nub [1,2,3,4,3,2,1,2,4,3,5]
-- [1,2,3,4,5]
nub                     :: (Eq a) =&amp;gt; [a] -&amp;gt; [a]
nub                     =  nubBy (==)

-- | The &amp;#x27;nubBy&amp;#x27; function behaves just like &amp;#x27;nub&amp;#x27;, except it uses a
-- user-supplied equality predicate instead of the overloaded &amp;#x27;==&amp;#x27;
-- function.
--
-- &amp;gt;&amp;gt;&amp;gt; nubBy (\x y -&amp;gt; mod x 3 == mod y 3) [1,2,4,5,6]
-- [1,2,6]
nubBy                   :: (a -&amp;gt; a -&amp;gt; Bool) -&amp;gt; [a] -&amp;gt; [a]
#if defined(USE_REPORT_PRELUDE)
nubBy eq []             =  []
nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -&amp;gt; not (eq x y)) xs)
#else
-- stolen from HBC
nubBy eq l              = nubBy&amp;#x27; l []
  where
    nubBy&amp;#x27; [] _         = []
    nubBy&amp;#x27; (y:ys) xs
       | elem_by eq y xs = nubBy&amp;#x27; ys xs
       | otherwise       = y : nubBy&amp;#x27; ys (y:xs)
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これは最初に作った再帰関数そのものだから、結果が同じになって当然なのだった。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;sortsitemiru&quot;&gt;sortしてみる&lt;&#x2F;h2&gt;
&lt;h3 id=&quot;sortsitegroup-risuto&quot;&gt;sortしてgroup（リスト）&lt;&#x2F;h3&gt;
&lt;p&gt;そこで２つめの、&lt;code&gt;sort&lt;&#x2F;code&gt;して重複をまとめる方法。
まずはリストを用いると、このようになる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;--AC
import Control.Monad
import Data.List as List

main = do
    n &amp;lt;- readLn
    s &amp;lt;- replicateM n getLine
    print $ length . group $ List.sort s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;Data.Listの&lt;code&gt;sort&lt;&#x2F;code&gt;関数をかませたリストに、隣接する同要素をリスト内リストにまとめる&lt;code&gt;group&lt;&#x2F;code&gt;関数をさらにかませてリスト内要素の長さをとるという手順。
かなり泥臭いやり方だが、再帰や&lt;code&gt;nub&lt;&#x2F;code&gt;よりも速いというのはちょっとおもしろい。&lt;&#x2F;p&gt;
&lt;h3 id=&quot;data-vectornouniqguan-shu-woyong-iru&quot;&gt;Data.Vectorのuniq関数を用いる&lt;&#x2F;h3&gt;
&lt;p&gt;リスト以外のデータ構造ではどうだろう。&lt;br &#x2F;&gt;
まずData.Vectorから。普通に入門書を読んでいるだけだとまず遭遇しないライブラリだが、海外のQ&amp;amp;AサイトではSequenceとどっちがいいの、といった質問でたまに見かける名前だ。&lt;&#x2F;p&gt;
&lt;p&gt;Data.Vector&lt;br &#x2F;&gt;
https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;vector-0.12.0.1&#x2F;docs&#x2F;Data-Vector.html&lt;&#x2F;p&gt;
&lt;p&gt;これはポリフォーミックなarrayで、リスト操作とarray操作のいいとこどりをしたものである、とHackageでは説明されている。
一通りの標準的な関数は装備されているが、ここで用いたいのは&lt;code&gt;uniq&lt;&#x2F;code&gt;関数。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;uniq :: Eq a =&amp;gt; Vector a -&amp;gt; Vector a
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;隣接した同じ要素を&lt;code&gt;drop&lt;&#x2F;code&gt;できるものだが、「隣接している」ことが条件なのでsortedが前提となる。
そこで&lt;code&gt;sort&lt;&#x2F;code&gt;関数と組み合わせて次のようにする。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;--AC
import Control.Monad
import qualified Data.Vector as V
import qualified Data.List as L

main = do
    n &amp;lt;- readLn
    s &amp;lt;- replicateM n getLine
    print $ length . V.uniq . V.fromList $ L.sort s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;これでも一応問題はクリアだが、実はリストによる&lt;code&gt;group . sort&lt;&#x2F;code&gt;のほうが若干早いということも分かった。
感覚的には必要のない重複を&lt;code&gt;drop&lt;&#x2F;code&gt;できる&lt;code&gt;uniq&lt;&#x2F;code&gt;関数のほうがmake senseではあるのだけれど、&lt;code&gt;V.fromList&lt;&#x2F;code&gt;でO(n)かかってしまっているので致し方ないというところだろうか。&lt;&#x2F;p&gt;
&lt;h2 id=&quot;data-setnosizeguan-shu&quot;&gt;Data.Setのsize関数&lt;&#x2F;h2&gt;
&lt;p&gt;もうひとつ、Data.Setを見てみる。その名の通り、集合論をベースにした、同型の要素のSetを扱えるライブラリだ。&lt;&#x2F;p&gt;
&lt;p&gt;Data.Set&lt;br &#x2F;&gt;
https:&#x2F;&#x2F;hackage.haskell.org&#x2F;package&#x2F;containers-0.6.2.1&#x2F;docs&#x2F;Data-Set.html&lt;&#x2F;p&gt;
&lt;p&gt;このライブラリが楽しいのは、&lt;code&gt;Set.fromList&lt;&#x2F;code&gt;でリストからSetを生成する過程で、重複要素が自動的に&lt;code&gt;drop&lt;&#x2F;code&gt;される点。この自動&lt;code&gt;drop&lt;&#x2F;code&gt;がいかにも自然に感じられるところがmake senseだ。&lt;br &#x2F;&gt;
Data.Setを用いたコードは次のようになる。&lt;&#x2F;p&gt;
&lt;pre data-lang=&quot;hs&quot; class=&quot;language-hs &quot;&gt;&lt;code class=&quot;language-hs&quot; data-lang=&quot;hs&quot;&gt;--AC
import Control.Monad
import qualified Data.Set as Set
 
main = do
    n &amp;lt;- readLn
    s &amp;lt;- replicateM n getLine
    print $ Set.size $ Set.fromList s
&lt;&#x2F;code&gt;&lt;&#x2F;pre&gt;
&lt;p&gt;&lt;code&gt;Set.size&lt;&#x2F;code&gt;はリストでいう&lt;code&gt;length&lt;&#x2F;code&gt;だが、これはO(1)。&lt;br &#x2F;&gt;
実行結果も、リスト版&lt;code&gt;group . sort&lt;&#x2F;code&gt;と大差がつくわけではないものの、最速。&lt;br &#x2F;&gt;
集合論的な発想を武器にできれば、色々な場面でかなり効率的にデータ処理ができそうな予感がする。&lt;&#x2F;p&gt;
</description>
        </item>
    </channel>
</rss>
